
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Có 4 nguyên lý thiết kế hướng đối tượng:		│
│		1. Tính trừu tượng / súc tích	| Abstraction	│
│		2. Tính đóng gói / cô lập	| Encapsulation	│
│		3. Tính kế thừa / tái sử dụng	| Inheritance	│
│		4. Tính đa hình / đa xạ		| Polymorphism	│
│								│
│	Có 5 kỹ thuật thiết kế hướng đối tượng:			│
│								│
│		=> Định hướng thiết kế hướng đối tượng		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[LẬP TRÌNH HƯỚNG ĐỐI TƯỢNG VỚI JAVA]

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Kiểu dữ liệu	(Data type)	≈	Lớp		(Class)		│
│	Biến		(Variable)	≈	Đối tượng	(Object)	│
│	Vùng tin	(Field)		≈	Thuộc tính	(Property)	│
│	Hàm		(Function)	≈	Phương thức	(Method)	│
│										│
│	Đối tượng <tênĐốiTượng> là một / thuộc phân loại <TênLớp>		│
│	với các thông tin <thuộcTính> và các hành động <phươngThức>		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================
==========================================================================================
==========================================================================================

[JAVA CĂN BẢN]

--------------------------------------------------------------------------------

	[LỊCH SỬ HÌNH THÀNH]

Năm 1991, Java được James Gosling và những người bạn đồng nghiệp phát triển tại Sun Microsystems, Inc.. Được tạo ra nhằm mục đích viết phần mềm cho các sản phẩm gia dụng, và có tên chính thức là Oak (cây sồi) vì đối diện văn phòng của ê-kíp là cây sồi.

Năm 1995, Oak được phát hành nhưng phải đổi tên vì bị trùng tên thương mại với Oak Technology. Sau nhiều cuộc thảo luận, tên gọi Java được quyết định sử dụng, dựa theo tên của một loại cà phê được trồng tại Indonesia.

Năm 2009, Sun Microsystem được Oracle Corporation tiếp quản (mua lại).

------------------------------------------------------------

Write once, run anywhere (WORA) / Write once, run everywhere (WORE) - Viết một lần, thực thi mọi nơi, là khẩu hiệu được Sun Microsystems tạo ra vào năm 1995 để minh họa cho khả năng đa nền tảng của ngôn ngữ Java.
	- Một chương trình Java có thể được phát triển trên bất kỳ thiết bị nào, sau đó được biên dịch thành mã byte tiêu chuẩn (bytecode - mã nhị phân) và ​​sẽ chạy được trên bất kỳ thiết bị nào có cài đặt máy ảo Java (JVM).
	- Giúp tiết kiệm công sức khi không cần viết từng phiên bản phần mềm khác nhau cho từng nền tảng hoặc hệ điều hành mà ứng dụng cần được triển khai trên đó.

Cũng giống như việc tuy các thiết bị khác nhau, nhưng chỉ cần cài đặt một trình duyệt có khả năng đọc được các tập tin HTML thì kết quả hiển thị sẽ giống nhau.

--------------------------------------------------------------------------------

	[CÁC ĐẶC ĐIỂM CỦA NGÔN NGỮ JAVA]

	1. Đơn giản: Cú pháp đơn giản, gần giống với C/C++ nhưng đã được loại bỏ đi những thứ phức tạp (ví dụ: con trỏ, tên thư viện / tệp tiêu đề...).
	2. Hướng đối tượng: Thuần hướng đối tượng, tất cả đều là lớp và đối tượng.
	3. Độc lập nền tảng: Chỉ cần cài máy ảo Java tương thích với hệ điều hành đang sử dụng là đã có thể thực thi được chương trinh Java.
	4. Phân tán: Cho phép sử dụng tài nguyên (lớp) được nạp vào từ nhiều nơi khác (ví dụ: internet...).
	5. Mạnh mẽ: 
	6. An toàn: Khi thao tác trên Java là ta chỉ tương tác bên trong một môi trường ảo - hộp cát (sandbox) và phải được cấp phép để hoạt động, chứ không thao tác trực tiếp lên hệ điều hành và cũng không can thiệp trực tiếp vào phần cứng.
	7. Khả chuyển: Nhờ vào khả năng "độc lập nền tảng" mà có thể thực thi chương trình ở bất kì đâu.
	8. Đa luồng: Có nhiều luồng để xử lý thông tin với những mức độ ưu tiên và sự phân bổ nguồn lực của CPU khác nhau, 
	9. Linh động: 

--------------------------------------------------------------------------------

* Các phiên bản JDK:

	1. Java SE (Standard Edition): Phần lõi (core) của Java.

	2. Java EE (Enterprise Edition): Công nghệ Java phức tạp dành do web, phiên bản dành cho các doanh nghiệp và sử dụng bên trong nhiều công nghệ phức tạp.

	3. Java ME (Micro Edition): Dành cho các thiết bị di động (không có hệ điều hành).

--------------------------------------------------------------------------------

	[CƠ CHẾ HOẠT ĐỘNG]

Mã nguồn của một chương trình Java sẽ có phần mở rộng là *.java.

―――――――――――――――――   Biên dịch, tạo ra   ―――――――――――――――――
│ MãNguồnJ.java │---------------------->│ MãNguồnJ.class│
―――――――――――――――――			―――――――――――――――――
						^
						|
						| Thông dịch,
						| thực thi
						|
―――――――――――――――――         Hỗ trợ        ―――――――――――――――――
│    Thư viện   │---------------------->│  Máy ảo Java  │
―――――――――――――――――			―――――――――――――――――

(* Tham khảo thêm: https://stackoverflow.com/questions/1326071/is-java-a-compiled-or-an-interpreted-programming-language)

Để chạy được một chương trình Java, trong C:\Program Files\Java\jdk-phiên-bản\bin sẽ có:

------------------------------------------------------------

	1. javac.exe (Compiler - Biên dịch): Mã nguồn gốc (*.java) sẽ được biên dịch để trở thành mã trung gian dạng nhị phân (được gọi là bytecode / portable code / class file) với phần mở rộng là *.class.
	
		- Sau khi đã có được tập tin bytecode (*.class), thì có thể đem đi thực thi ở bất kì đâu và trên bất kì hệ thống nào mà không cần phải biên dịch lại nữa.

		-> Chỉ viết và biên dịch một lần, sau đó có thể thực thi ở bất kì đâu.
			(Biên dịch tập tin *.java -> *.class)

		[Có thể viết và thực thi Unit Test để đảm bảo chất lượng của mã nguồn trước khi đóng gói ứng dụng.]

------------------------------------------------------------

	2. java.exe (Interpreter - Thông dịch): Thay vì được thực thi trên hệ điều hành, ứng dụng sẽ được thực thi trên một hệ thống đặc biệt được gọi là máy ảo Java (Java Virtual Machine - JVM).

		- Máy ảo này chỉ quan tâm đến tập tin *.class và thực hiện thông dịch trên tập tin này để tạo ra mã máy (machine code / machine language), mà không cần quan tâm đến mã nguồn nữa.

		- Trên bất kì hệ thống nào, miễn là nếu đã được cài máy ảo Java tương ứng với hệ điều hành đang sử dụng, thì đều sẽ thực thi được chương trình Java.
		
		- Điều đặc biệt và tất nhiên ở đây là kết quả thực thi chương trình trên tất cả các máy ảo là giống nhau hoàn toàn - kết quả thống nhất. Giúp bảo vệ được mã nguồn (quyền sở hữu trí tuệ).

		-> Máy ảo giúp giúp tương thích với mọi loại hệ điều hành và phần cứng.
			(Thông dịch tập tin *.class và thực thi trực tiếp)

------------------------------------------------------------

	3. jar.exe (Archive / Packaging - Đóng gói): việc đóng gói thành một tập tin duy nhất - bên trong chứa nhiều tập tin hình ảnh, âm thanh, mã máy kèm thư viện từ bên ngoài (nén tất cả thành tập tin *.war, *.jar, *.apk, *.ear...)... không phải là công việc của IDE hay JDK.
	
		- Lúc này, ta phải sử dụng thêm một công cụ được gọi là Ant / Maven / Gradle, những công cụ này đều đã được đính kèm trong quá trình cài đặt IDE.
		
		- Việc đóng gói tất cả mọi thứ thành một tập tin duy nhất sẽ giúp tiết kiệm dung lượng và đơn giản hóa quá trình tải xuống.

		-> Đóng gói mã máy và thư viện thành một tập tin duy nhất và cho ra ứng dụng.
			(Đóng gói tập tin *.class -> *.jar, *.war, *.apk, *.ear...)

[IDE đã thay người dùng lo những phần biên dịch, thông dịch, đóng gói... chỉ bằng những nút nhấn.]

(* Tham khảo thêm: https://niithanoi.edu.vn/java-platform-la-gi.html)

--------------------------------------------------------------------------------

	[CÁC THUẬT NGỮ VỀ DỰ ÁN TRONG JAVA]

	――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
	│									   │
	│  ――――――――――――――――――――――――――――――――――――――――――――――   ―――――――――――――――――――――  │
	│  │						│   │ Các công cụ       │  │
	│  │	――――――――――――――	  ――――――――――――――――――	│   │ phát triển khác:  │  │
	│  │	│ JVM (java) │	  │  thư-viện.jar  │	│   │ javac, jar, jdb,  │  │
	│  │	――――――――――――――	  ――――――――――――――――――	│   │ javadoc, API...   │  │
	│  │						│   │                   │  │
	│  │			  ――――――――――――――――――	│   │                   │  │
	│  │			  │ Tập tin hỗ trợ │	│   │                   │  │
	│  │			  ――――――――――――――――――	│   │                   │  │
	│  │						│   │                   │  │
	│  ――――――――――――――――――――――――――――――――――――――――――――――   ―――――――――――――――――――――  │
	│			JRE						   │
	│									   │
	――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
							JDK

(* Tham khảo thêm:
	- https://www.geeksforgeeks.org/differences-jdk-jre-jvm/
	- https://howtodoinjava.com/java/basics/jdk-jre-jvm/)

------------------------------------------------------------

	[CÀI ĐẶT MÔI TRƯỜNG]

* JDK (Java Development Kit): bộ công cụ / bộ đồ nghề (kit) chuyên được cài lên máy tính của lập trình viên để giúp phát triển phần mềm bằng ngôn ngữ Java.

	- Mỗi hệ điều hành sẽ có một bộ cài đặt riêng, giúp tạo nên tính độc lập nền tảng.

	- Bản thân nó cũng là một chương trình, bên trong bao gồm:
		+ Môi trường để thực thi chương trình Java (Java Runtime Environment - JRE).
		+ Trình biên dịch (Compiler).
		+ Trình thông dịch (Interpreter) / Máy ảo Java (Java Virtual Machine - JVM).
		+ Trình đóng gói (Archiver).
		+ Trình tạo tài liệu (Javadoc)
		+ ...

	- Mặc định, JDK trên Windows sẽ được cài đặt trong đường dẫn: C:\Program Files\Java\jdk-phiên-bản.

	- Thường được cài đặt khi người dùng có nhu cầu phát triển ứng dụng hoặc đôi khi là triển khai một ứng dụng web với JSP.

	-> Đóng vai trò như một trình biên dịch (Compiler) và hỗ trợ thực thi (Run) chương trình.

----------------------------------------

* JRE (Java Runtime Environment / Java RTE): phiên bản thu gọn hơn so với JDK.
	- Không hỗ trợ lập trình (tạo ra chương trình mới), chỉ hỗ trợ thực thi chương trình.
	- Thường được cài đặt lên máy tính của người dùng.
	- Chứa những thư viện vừa đủ để chạy chương trình Java (mã bytecode).
		+ ClassLoader.
		+ Bytecode Verifier.
		+ Interpreter / JVM.
	- Bên trong vẫn bao gồm các thư viện và các tập tin mà JVM sử dụng lúc thực thi.
		+ Deployment technologies
		+ User interface toolkits
		+ Integration libraries
		+ Other base libraries
		+ Lang and util base libraries
		+ Java Virtual Machine (JVM)

----------------------------------------

* JVM (Java Virtual Machine): máy ảo Java là một chương trình nhỏ thuộc JRE.

	- Hay còn được biết đến như một trình thông dịch (Interpreter), chịu trách nhiệm thực thi từng dòng lệnh một của chương trình.
		+ Là một thể hiện (instance) của JRE.
		+ Nơi chuyển *.class thành mã máy.
		+ Nơi thực sự gọi hàm main().

	- Cũng chạy ngầm giống như các dịch vụ (service) trong hệ điều hành.
		+ Hoạt động trước cả khi ứng dụng được chính thức thực thi và hoạt động song song với hệ điều hành.
		+ Máy ảo Java cũng giống như một hệ điều hành riêng biệt và có thể được xem như một hệ điều hành thu nhỏ, bên trong cũng có các thông số, có biến môi trường riêng...

	- Tính khả chuyển: có nhiệm vụ thông dịch bytecode (*.class) thành machine code (mã máy), tùy theo môi trường tương ứng mà mỗi hệ điều hành khác nhau sẽ có các máy ảo khác nhau.

	- Tính độc lập với nền tảng: cung cấp môi trường thực thi cho chương trình Java.

	- Việc cài đặt máy ảo là điều bắt buộc nếu muốn thực thi chương trình Java.
	
	- Có nhiệm vụ chuyên đi giám sát những vùng RAM được cấp cho những ứng dụng được viết bằng ngôn ngữ Java.

	Ví dụ: máy ảo Java có quyền...
		- Tự động gửi thông báo và ngắt ứng dụng khi phát sinh lỗi (Lỗi ngoại lệ - Exception).
		- Tự động thu hồi vùng nhớ không còn được trỏ đến (Bộ thu gom rác - Garbage Collector).
		- ...

--------------------

* Các thành phần / kiến trúc bên trong của JVM bao gồm:

----------

	* ClassLoader: Có nhiệm vụ nạp lớp với các thao tác...

		1. Loading: Đọc tập tin *.class, tạo dữ liệu dạng nhị phân và lưu vào Method Area. Có thể hiểu, thông tin của mỗi tập tin *.class sẽ được chứa trong một Method Area.
			- Bootstrap Class Loader.
			- Extension ClassLoader.
			- Application ClassLoader.

		2. Linking
			- Verification: Đảm bảo tập tin *.class đúng định dạng, được tạo bởi một trình biên dịch hợp lệ.
			- Preparation: Cấp phát vùng nhớ cho các biến tĩnh và khởi tạo giá trị mặc định.
			- Resolution: Tìm kiếm trong Method Area để định vị thực thể được tham chiếu, sau đó thực hiện thay thế các tham chiếu bằng giá trị thực sự.

		3. Initialization: Toàn bộ thuộc tính tĩnh đã được gán giá trị như trong code đã định nghĩa.

----------

	* Runtime Data Area (JVM Memory): Được chia thành các thành phần...

		1. Class / Method Area (Code Segment):
			- Chứa metadata (tên lớp...).
			- Toàn bộ mã nguồn (phương thức, chỉ dẫn...) đã được biên dịch.

		2. Stacks Area:
			- Chứa khuôn gốc (???).
			- Biến cục bộ của phương thức.
			- Các tham số của phương thức.
			- Biến đối tượng (tham chiếu, con trỏ) được khai báo cục bộ.
			- Kết quả hoạt động trung gian (kết quả tạm).

		3. Heap Area: Chứa các đối tượng và thuộc tính của đối tượng, mảng.
			+ Permgen (Metaspace): Được đổi tên thành Metaspace bắt đầu từ Java 8. Là một vùng Heap đặc biệt và tồn tại vĩnh viễn; chứa thuộc tính và phương thức tĩnh, biến đơn giản và các tham chiếu đến đối tượng tĩnh.

		4. Program Counter (PC) Registers: Lưu địa chỉ của lệnh đang và sắp thực thi.

		5. Native Method Stack: Giúp thực thi các phương thức native (không phải Java)

----------

	* Execution Engine: Một phần mềm để kiểm tra toàn bộ hệ thống (phần mềm và phần cứng).

		1. Interpreter.

		2. JIT Compilier.

		3. Hotspot Profiler.

		4. Garbage Collector.

		+ Native Method Interface:
		+ Native Method Libraries: Chứa các thư viện (C/C++) mà Executing Engine cần.

--------------------

(* Tham khảo thêm:
	- https://www.geeksforgeeks.org/jvm-works-jvm-architecture
	- https://www.baeldung.com/java-permgen-metaspace)

------------------------------------------------------------

	[TỔ CHỨC VÀ QUẢN LÝ THƯ VIỆN - LỚP]

	* import: Là từ khoá để khai báo, đưa lớp từ gói ở bên ngoài vào trong lớp/gói (chương trình) của người sử dụng.

		- Sau khi khai báo, người dùng có thể thoải mái tạo mới đối tượng hoặc gọi hàm (non-static), sử dụng giống hệt việc lớp đó nằm gọn trong lớp do người dùng thiết kế, từ đó giúp cho mã nguồn ngắn gọn và dễ đọc hơn.

		* Cú pháp: import <tên-thư-viện-theo-phân-cấp-thư-mục>.<LớpCầnSửDụng>;

		- Khi import lớp khác gói (package/namespace), nếu muốn sử dụng toàn bộ lớp chứa trong gói đó, ta có thể sử dụng ".*" để đại diện cho tất cả các lớp.

			Ví dụ: import java.util.*;

		- Nếu thiếu từ khoá import nhưng vẫn muốn sử dụng thì phải chỉ rõ đường dẫn chứa lớp đó.

			Ví dụ 1: Để sử dụng được lớp Scanner.

				// Có import
				import java.util.Scanner;
				Scanner myObj = new Scanner(System.in);

				// Không có import
				java.util.Scanner myObj = new java.util.Scanner(System.in);

			Ví dụ 2: Sử dụng lớp Date để lấy ngày hiện tại.

				// Có import
				import java.util.Date;
				Date today = new Date();

				// Không có import
				java.util.Date today = new java.util.Date();

	* import static: Cho phép những hàm static, khi được nơi khác sử dụng sẽ không cần phải thông qua tên lớp.

		- Nhưng không giống như những câu lệnh import thông trường, việc import static bắt buộc sẽ phải chỉ định rõ tên hàm cần sử dụng hoặc phải có ".*" đằng sau tên lớp với hàm ý nói rằng sử dụng tất cả các hàm static có trong lớp đó.

		- Nếu không chỉ định rõ tên hàm cần sử dụng mà chỉ có tên lớp trong câu lệnh import thì trình biên dịch của IDE sẽ hiển thị thông báo lỗi.

			Ví dụ:
				// Sử dụng tất cả các hàm static trong lớp mà không cần tên lớp
				import static org.junit.Assert.*;

				// Quy định rõ hàm static nào sẽ được gọi mà không cần tên lớp
				import static com.ou.mathutil.util.MathUtil.getFactorial;

				// Sẽ bị báo lỗi
				import static com.ou.mathutil.util.MathUtil;

* Package: ngăn tủ / nhà kho - nơi cất / chứa khuôn (class), để sau này có thể lấy ra và sử dụng lại trong tương lai (đem sang "sân" main() để tiến hành đúc).
	- Vì việc tạo ra khuôn (lớp - class) là cả một quá trình khó khăn, mà giang hồ lại hiểm ác, nên tất cả các khuôn sau khi thiết kế xong phải được cất trong tủ (package).
	- Trong một ngăn tủ, được phép có nhiều ngăn tủ nhỏ hơn.

	-> Phân cấp mức tổ chức thông tin.

		* default package: ngăn tủ để thông báo không có ngăn tủ nào.
	- Mọi lớp bắt buộc phải nằm trong package, nếu thiếu đi tên package (nằm trong <default package>) thì sẽ gặp những rủi ro trong vấn đề viết code, chẳng hạn như không thể import thư viện được, không thể tạo đối tượng... vì không xác định được câu lệnh đang sử dụng nằm ở đâu trong lớp.

	- Sau khi đã được cất lớp vào trong một ngăn tủ...
		+ Những lớp (class) nằm chung trong một ngăn tủ có thể thấy thông tin (thuộc tính và phương thức) công khai và thoải mái sử dụng những gì được phép.
		+ Nhưng lớp (class) khác gói nếu muốn gọi đến để sử dụng thì ở đầu chương trình (lớp cần sử dụng) phải thông báo / khai báo việc sử dụng bằng câu lệnh import.

		-> Để hai lớp khác ngăn tủ có thể thấy nhau thì bắt buộc phải sử dụng câu lệnh import như một cách để thông báo cho nhau về ngăn tủ chứa đồ chơi, nhưng "khi hai ta về một nhà" (nằm chung một ngăn tủ) thì có thể sử dụng trực tiếp mà không cần import.

----------------------------------------

* Quy tắc đặt tên gói (Package / Namespace) trong code: được thống nhất để tổ chức dữ liệu cho các dự án hoặc các công ty trên toàn thế giới, giúp các dự án có thể sống chung với nhau.

	- Đặt ngược theo tên miền (Domain name).

		Ví dụ 1: so sánh giữa tên miền và tên gói
			- Tên miền: https://www.microsoft.com/
			- Tên gói: com.microsoft....

		Ví dụ 2: so sánh giữa tên miền và tên gói
			- Tên miền: https://katalon.com/
			- Tên gói: com.katalon...

		Ví dụ 3: tên gói
			// Nơi chứa sẽ phần chính sẽ sử dụng
			com.hoangthuan.mathutil.core

			// Nơi chứa hàm main() để chạy ứng dụng
			com.hoangthuan.mathutil.main

	- Dấu chấm trong tên gói chính là phân cấp tổ chức thư mục (folder).

		Ví dụ: <tên-miền>.<tên-công-ty>.<tên-dự-án>.<tên-gói-thư-viện>
			com
			   microsoft
				sqlserver
				   jdbc
				      ... class để sử dụng Java và kết nối sang SQL Serever
				   adonet
				      ... class để sử dụng C# và kết nối sang SQL Serever

				visualstudio
				   adonet
				      ... class khác để kết nối sang adonet của SQL Serever

				vscode

			// Tên gói: com.microsoft.sqlserver.adonet

	- Giúp dễ dàng kiểm soát và quản lý các tập tin mã nguồn, vị trí, các mối quan hệ giữa các lớp... từ đó cũng sẽ dễ dàng hơn trong việc sử dụng và bảo trì.

	- Ngoài ra, việc đặt tên đảo ngược còn sẽ giúp các gói của một đơn vị / tổ chức / công ty sẽ được tự động gom nhóm và nằm ở cạnh nhau, dù cho có phải sống cùng với những gói của các cá nhân / tổ chức khác.

	-> Giúp gom nhóm và phân chia các dự án/gói thư viện (*.jar, *.dll), cây thư mục mã nguồn (source code) của cùng 1 công ty (sau này là của các công ty khác, của toàn cầu), để sau này còn có thể cùng sống chung với nhau nhau mà lại không bị trộn lẫn với nhau.

	Ví dụ: Xây dựng một thư viện bao gồm các lớp để quản lý CôngDân. Lớp CôngDân sẽ được sử dụng để làm gốc và cho phép các lớp khác kế thừa.

		congdan

		   lucluongvutrang
			congan
			quandoi
			   phongkhongkhongquan
			   lucquan
			   haiquan
			      taungam

		   congchuc
			   
		   doanhnghiep
			   
		   hocsinhsinhvien
			mamnon
			tieuhoc
			trunghoccoso
			trunghocphothong
			daihoccaodang
			   daihoc
			      taptrung
			      thuongxuyen

		* Khi muốn khai báo sử dụng:
			congdan.lucluongvutrang.quandoi.lucquan.taungam
			congdan.hocsinhsinhvien.daihoccaodang.daihoc.taptrung

------------------------------------------------------------

* Java Build Path: Đối với Eclipse IDE, đây là nơi (đường dẫn) dẫn đến thư viện (*.jar) chứa những lớp sẽ sử dụng trong dự án, với định dạng đuôi là tập tin *.jar.

	- Trong đó, "JRE System Library" là lớp chuẩn, được Java cung cấp sẵn sau khi cài đặt JDK.

	- Để cài đặt thư viện do người dùng tự thiết kế (tải tập tin *.class hoặc *.jar từ bên ngoài về) vào trong dự án:
		1.1. [Mở chậm] Nhấn chọn dự án -> Project -> Properties -> Java Build Path
		1.2. [Mở nhanh] Chuột phải vào dự án cần sử dụng thư viện.
		2.2. Build Path -> Configure Build Path...
		3. Tại thẻ Libraries, chọn Classpath.
		4.1. Add External Class Folder... (Đối với thư mục chứa tập tin *.class)
		4.2. Add External JARs... (Đối với tập tin *.jar)
		5. Tìm đến thư mục chứa / tập tin thư viện trên ổ đĩa
		6. Chọn thư mục bin (chứa các tập tin *.class bên trong) / Chọn tập tin *.jar
		7. Apply and Close.

* Workplace: là một khái niệm của Eclipse IDE, có công dụng nhóm các dự án lại với nhau.

--------------------------------------------------------------------------------

	[CÁC LOẠI DỰ ÁN & CÔNG CỤ BUILD]

* Sự phụ thuộc (Dependency): Việc "sống còn" hoàn toàn nhờ vào những nhân tố bên ngoài.
	- Trong thế giới phần mềm, phần phụ thuộc là những thứ mà ứng dụng cần có / yêu cầu để có thể thực thi thành công.
	- Cụ thể, trong Java, đây thường là những thư viện được đưa từ bên ngoài vào như: lombok, jdbc...

Việc quản lý các thư viện theo truyền thống sẽ rất tốn thời gian vì:
	- Tải các thư viện về và thêm chúng vào trong dự án một cách thủ công, lặp lại điều tương tự mỗi khi thư viện phát hành bản cập nhật mới.
	- Nếu tự thiết kế một tập lệnh để tự động tải và cập nhật thư viện thì phải luôn đảm bảo rằng đường dẫn (URL) không bị thay đổi.
	- Khi các thư viện khác nhau nhưng lại phụ thuộc vào nhau (thư viện này sử dụng thư viện kia), việc quản lý sẽ bắt đầu gặp khó khăn.

* Công cụ quản lý sự phụ thuộc (Dependency Management Tool): Được ra đời để giúp giải quyết các khó khăn của việc quản lý thư viện trong phần mềm.

* Công cụ build (Build Tool): Công cụ giúp tự động chuyển đổi mã nguồn thành ứng dụng (*.jar, *.war, *.apk...). Bao gồm một loạt các công việc cần phải làm:
	1. Quản lý mã nguồn & thư viện lập trình
	2. Biên dịch mã nguồn thành mã nhị phân
	3. Đóng gói mã nhị phân
	4. Chạy các bộ kiểm thử
	5. Triển khai ứng dụng lên môi trường sản phẩm

Trong Java, có một số công cụ là sự kết hợp giữa Công cụ quản lý sự phụ thuộc (Dependency Management Tool) và Công cụ build (Build Tool).
	- Đây là những chương trình nhị phân chuyên chạy ngầm trên máy tính của lập trình viên.
	- Khi biên dịch và đóng gói ứng dụng, các IDE sẽ gọi đến các công cụ này để hỗ trợ, nhưng vẫn có thể cài rời để thực hiện gọi các câu lệnh bằng cửa sổ dòng lệnh mà không cần sử dụng đến IDE.
	- Mỗi công cụ khác nhau, ra đời vào những thời điểm khác nhau, sẽ có những cách để quản lý tài nguyên trong dự án khác nhau.
	- Nhưng đích đến cuối cùng vẫn chỉ là chuyển đổi mã nguồn thành ứng dụng (*.jar, *.war, *.apk...).

	-> Các loại dự án sẽ khác nhau về cách tổ chức nhưng vẫn có chung mục đích là ra được ứng dụng.

Cũng giống như sự khác nhau về cách tổ chức thư mục khi Windows cho phép có nhiều phân vùng ổ đĩa, còn macOS chỉ cho phép có một phân vùng nhưng lại có thể chia thư mục; song kết quả cuối cùng vẫn là lưu trữ được dữ liệu và tập tin / thực mục của hai bên vẫn có thể hoán đổi được cho nhau.

	-> Các loại dự án sẽ khác nhau về cách tổ chức nhưng vẫn có chung mục đích là ra được ứng dụng.

----------------------------------------

* Các tiêu chuẩn / cách thức tổ chức dự án, biên dịch và đóng gói mã nguồn (*.java) trong Java.

	- Ant (2000) + Ivy (2004): Xuất hiện từ rất sớm, nhưng lại có nhiều hạn chế trong việc quản lý thư viện phụ thuộc, nên sẽ chuyển qua Maven hoặc Gradle.
	- Maven (2004):
	- Gradle (2012):

	-> Phong cách tổ chức dự án, lưu trữ dữ liệu trong những thư mục nào.
		(Khác hành trình nhưng chung đích đến - Chỉ khác nhau về cách tổ chức thư mục trong dự án, còn các tập tin ra cho vẫn giống nhau.)

		Khi tạo dự án, biên dịch và đóng gói bằng các IDE.
			-> Java sẽ gọi công cụ Ant / Maven...
			-> Ant / Maven... sẽ gọi javac.exe
			-> ...

(* Tham khảo thêm: https://medium.com/@257ramanrb/ant-vs-maven-vs-gradle-cd8ab4c2735f)

------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Các IDE sẽ gọi các công cụ (Ant, Maven) để biên dịch và đóng gói,	│
│	sẽ gọi máy ảo Java (JVM) để thực thi chương trình			│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

	[CẤU TRÚC THƯ MỤC (THEO NETBEANS)]

Khi đóng gói (Clean and Build Project | Shift + F11) ứng dụng Java bằng Ant trên NetBeans sẽ tạo ra hai thư mục được tổ chức theo cây phân cấp thư mục là "build" và "dist".

	* Thư mục "build": Bên trong chứa các tập tin *.class.
		-  có được sau khi biên dịch (compile / Run Project - F6) mã nguồn.
		- Vì về nguyên tắc, muốn chạy được ứng dụng thì bắt buộc phải đi qua quá trình biên dịch để có được tập tin *.class.

		-> Biên dịch (F6) mã nguồn để đem đi thực thi ở nhiều nơi.

		(Trong Eclipse sẽ có những thư mục tương ứng là "bin" và trong IntelliJ sẽ là thư mục "out".)

	* Thư mục "dist": Bên trong chứa các tập tin *.jar, bản chất đây chỉ là một tập tin đã được nén lại và có thể giải nén bình thường (giống như tập tin *.zip, *.rar, *.7z...).
		- Có được sau khi đóng gói (compile + build / Build Project - F11) ứng dụng.
		- Có thể thay đổi phần mở rộng của tập tin thành *.zip, *.rar, *.7z... hoặc trực tiếp giải nén luôn tập tin *.jar, lúc này, ta sẽ thu được những tập tin *.class giống hệt như bên thư mục "build".

		-> Đóng gói (F11) mọi thứ để đem đi bán, tặng, sử dụng trong dự án khác...

------------------------------------------------------------

	[CÁCH TỔ CHỨC MÃ NGUỒN & THƯ MỤC CỦA ANT VS. MAVEN]

[ANT]								[MAVEN]

----------------------------------------

		| Mã nguồn bắt buộc phải nằm trong đây |
src\								src\
								    main\
								        java\
    package\							            package\
        *.java							                *.java

		| Nơi chứa Unit Test |
test\								src\
								    test\
								        java\
    package\							            package\
        *.java							                *.java

----------------------------------------

		| Nơi chứa tập tin đã được biên dịch (compile),
		  bao gồm cả mã nguồn và mã kiểm thử (Unit Test) |
build\								target\
    classes\							    classes\
        *.class							        *.class

    test\							    test-classes\
        classes\
            *.class						        *.class

		| Nơi chứa tập tin đã được đóng gói (archive) |
dist\								target\
    *.jar, *.war						    *.jar, *.war

----------------------------------------

		| Nơi liệt kê những công việc cần phải làm
		  để biên dịch và đóng gói ứng dụng
		  (cách cấu hình các thư viện) |
build.xml							pom.xml

		| Công cụ để thực hiện biên dịch và đóng gói |
ant.bat								mvn.bat

	(C:\Program Files\NetBeans-số-phiên-bản\netbeans\java\maven\bin)

(C:\Program Files\NetBeans-số-phiên-bản\netbeans\extide\ant\bin)

----------------------------------------

		| Nơi chứa thư viện *.jar (JDK) |
Libraries							Java Dependencies
Test Libraries							Test Dependencies

		| Nơi chứa tập tin cấu hình .xml |
nbproject							Project Files

------------------------------------------------------------

	[THỰC THI, BIÊN DỊCH VÀ ĐÓNG GÓI MÀ KHÔNG SỬ DỤNG IDE]

Sử dụng CMD để biên dịch và thực thi chương trình mà không cần sử dụng đến IDE.

	Ví dụ: để biên dịch và thực thi ứng dụng bằng CMD

		Bước 01: Đi đến thư mục chứa tập tin *.java

		Bước 02: Gõ câu lệnh biên dịch vào CMD. Sau khi gõ xong, một tập tin *.class sẽ xuất hiện chung với nơi lưu trữ tập tin *.java
			| javac -encoding ISO-8859-1 Tên-Tập-Tin.java

		Bước 03: Gõ câu lệnh thông dịch vào CMD. Lúc này, trình thông dịch sẽ tự động hiểu và đi tìm tập tin *.class để thực thi
			| java Tên-Tập-Tin

----------------------------------------

Ngoài việc đi kèm với các IDE và bắt buộc phải sử dụng IDE, ta hoàn toàn có thể sử dụng trình soạn thảo văn bản + cài riêng các "công cụ" và sử dụng thông qua các câu lệnh (ant, mvn... + tham số dòng lệnh) để tạo dự án theo đúng cấu trúc, biên dịch và đóng gói ứng dụng.
	-> Viết code, biên dịch và đóng gói là những tiến trình độc lập với nhau.

	Ví dụ: để biên dịch và đóng gói một dự án Java thủ công bằng Ant

		Bước 01: Sao chép đường dẫn chứa tập tin ant.bat (Ví dụ: NetBeans 12.0)
			 (C:\Program Files\NetBeans-12.0\netbeans\extide\ant\bin)

		Bước 02: Thiết lập biến môi trường để nhờ Windows nhớ giùm đường dẫn

		Bước 03: Trở lại thư mục chứa mã nguồn, nơi có tập tin build.xml

		Bước 04: Gọi bằng câu lệnh CMD để biên dịch và đóng gói ứng dụng
			| ant
				// Giống những gì mà GitHub Actions workflows đã làm,
				// nhưng không cần truyền tập tin build.xml, vì Ant sẽ tự động đi tìm

==========================================================================================

[CÔNG CỤ ANT]

--------------------------------------------------------------------------------

	[CÁCH THÊM THƯ VIỆN VÀO DỰ ÁN]

	Bước 01: Tải thư viện tại: https://mvnrepository.com/

	* Với NetBeans:
		Bước 02: Nhấn chuột phải vào thư mục Libraries -> Add JAR/Folder...

	* Với Eclipse:
		Bước 02: Nhấn chuột phải vào dự án -> Properties

		Bước 03: Chọn Java Build Path -> Chuyển sang thẻ Libraries

		Bước 04: Chọn Classpath -> Add External JARs...

==========================================================================================

[CÔNG CỤ MAVEN]

--------------------------------------------------------------------------------

	[QUY TẮC ĐẶT TÊN CHO DỰ ÁN MAVEN]

Khi tạo một dự án bằng Maven, tên / thông tin của dự án sẽ đòi hỏi phức tạp và chỉnh chu hơn.

	- Tên dự án (Project Name): được sử dụng để đóng gói dự án sau này. Đặt chữ thường, viết liền nhau và ngăn cách bằng dấu gạch nối.

		Ví dụ: math-util-junit5

	- Tên tạo phẩm (Artifact Id): tên của tập tin *.jar, được tạo ra sau khi build và được sử dụng để đem đi triển khai hoặc phân phối, nhưng không kèm theo phiên bản. Được tự động đặt trùng với tên dự án.

		Ví dụ: math-util-junit5

	- Tên miền (Group Id): tên thương hiệu của tổ chức. Đặt theo tên miền đảo ngược.

		Ví dụ: com.hoangthuan

	- Phiên bản (Version): đánh số phiên bản khi biên dịch và đóng gói ứng dụng.

		Ví dụ: 1.0-SNAPSHOT, RELEASE

	- Tên gói (Package): nơi chứa mã nguồn. Đặt theo tên miền đảo ngược.

		Ví dụ: com.hoangthuan.mathutil, org.apache.maven, org.apache.commons

--------------------------------------------------------------------------------

	[TẬP TIN CẤU HÌNH POM.XML]

* POM (Project Object Model): mô hình các thành phần của dự án.

	- Mọi thứ trong dự án này đều là đối tượng (Object), có những thuộc tính (Property) và phương thức (Method).
	
	- Mọi thành phần của dự án đều sẽ được tổ chức theo hướng đối tượng.

		* Cú pháp:

			<biến>giá-trị</biến>

			<thuộcTính>giá-trị</thuộcTính>

------------------------------------------------------------

	1. Ghi những thông tin của dự án (ví dụ: tên dự án, phiên bản đóng gói, JDK sử dụng...).

		Ví dụ: các thông tin khi tạo dự án Maven bằng NetBeans

			<project>Vùng chứa những thông tin chung của dự án

				<modelVersion>4.0.0</modelVersion>

				<groupId>com.hoangthuan</groupId>

				<artifactId>math-util-junit5</artifactId>

				<version>1.0-SNAPSHOT</version>

				<packaging>jar</packaging>


				<properties>
					<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
					<maven.compiler.source>11</maven.compiler.source>
					<maven.compiler.target>11</maven.compiler.target>
				</properties>

			</project>

------------------------------------------------------------

	2. Ghi những thư viện (Library) sẽ sử dụng trong dự án, nhưng nay được gọi bằng một tên mới là "phụ thuộc" (Dependency).

		* Đối với Ant:
			+ Cần phải tải các tập tin thư viện *.jar và tự thêm các thư viện này vào trong dự án một cách thủ công.

			+ Nếu các tập tin thư viện có phụ thuộc lẫn nhau (tập tin này cần gọi đến tập tin khác), thì ta cũng phải tự đi mò và thêm thủ công vào.

		* Đối với Maven:
			+ Chỉ cần khai báo tên thư viện chính cần sử dụng. Thông qua IDE, Maven sẽ tự động tải thư viện về và thêm vào dự án giùm.

			+ Nếu các tập tin thư viện có phụ thuộc lẫn nhau, Maven cũng sẽ tự đi tìm để tải về và tự thêm vào dự án giùm.

		-> Chỉ cần khai báo thư viện phụ thuộc (Dependency), phần còn lại sẽ do Maven và IDE lo.

------------------------------------------------------------

	3. Ghi những việc mà Maven cần phải làm cho dự án.
		Build thế nào?
		Chạy bộ test ra sao? // Giống tập tin build-impl.xml của Ant
		Đóng gói ứng dụng ra sao?
		Đem ứng dụng đi đâu?

		-> Sử dụng thêm những thư viện hỗ trợ thực thi (plugin).

------------------------------------------------------------

// "Maven sẽ tải những thư viện phụ thuộc này ở đâu?"

Cộng đồng những người dùng Maven đã tạo nên một Server (Maven Central Repository) để tập trung toàn bộ những thư viện lại. Cách thức hoạt động giống như NuGet.
	| https://mvnrepository.com/

	- Nơi chứa toàn bộ những tập tin thư viện (*.jar) mà thế giới cần sử dụng.

	- Có sẵn luôn câu lệnh để khai báo thư viện, ta chỉ việc sao chép và dán vào trong tập tin pom.xml là đã có thể sử dụng được.

	- Maven sẽ tự động đi vào đây để tải thư viện về nếu khai báo theo đúng định dạng.

------------------------------------------------------------

// "Khai báo các thư viện như thế nào?"
//	-> Các thư viện cần sử dụng.

Trong vùng <project>, song song / ngang hàng với vùng <properties>.
	- Nhập thêm cặp thẻ <dependencies></dependencies> (dạng số nhiều).
	- Sau đó dán câu lệnh khai báo những thư viện cần sử dụng (mà trước đó đã sao chép trên Central Repository) vào bên trong cặp thẻ <dependencies></dependencies>

	Ví dụ: khai báo dependency

		<project>

		    <properties>
			...
		    </properties>

		    <dependencies>

			    <!-- Khai báo dependency tại đây -->
			    <dependency>
				...
			    </dependency>

		    </dependencies>

		</project>

------------------------------------------------------------

// "Các thư viện đã tải về sẽ nằm ở đâu trong ổ đĩa?"

Mặc định, Maven sẽ tải toàn bộ những thư viện cần thiết về máy tính cục bộ và đặt ở một thư mục sử dụng chung.

	- Nơi chứa toàn bộ thư viện trong kho thư viện nhà người ta (Maven Repository), mà ta đã kéo về kho nhà mình dưới máy cục bộ.

	- Nằm trong đường dẫn: C:\Users\Tên-Người-Dùng\.m2\repository
		* m2: Maven 2 là một phiên bản thành công của Maven khi thay đổi toàn bộ cấu trúc lõi.

	- Quy tắc đặt tên miền đảo ngược sẽ bắt đầu phát huy tác dụng khi nó sẽ giúp ta dễ dàng tìm đến thư mục chứa thư viện mà ta cần, dù phải sống chung với rất nhiều thư viện đến từ rất nhiều tổ chức khác nhau hoặc nhiều thư viện khác nhau của cùng một tổ chức.

		Ví dụ: nơi chứa những thư viện đã tải từ Maven Repository về
			- Để đi tìm JUnit 5 (Jupiter), ta đi theo đường dẫn org\junit\jupiter
			- Để đi tìm kho thư viện "nhà làm", ta đi theo đường dẫn com\hoangthuan

------------------------------------------------------------

// "Làm những hành động cụ thể gì sau khi đã khai báo thư viện?"
//	-> Các hành động cần phải làm.

Mặc định, ta chỉ mới khai báo những thư viện sẽ sử dụng trong dự án, chứ chưa nói rõ sẽ làm gì.

Vì vậy, cần phải chỉ rõ những hành động mà Maven cần phải làm:

	- Các thư viện (Dependency) chỉ là những lớp (Class) được đóng gói lại, thường sử dụng để tham khảo vào trong code và gọi thông qua câu lệnh import, còn những thư viện trợ giúp / phụ trợ cho quá trình biên dịch và đóng gói của Maven sẽ nằm trong phần plugin.
	
	- Plugin vẫn là thư viện (những đoạn code đã được biên dịch), chạy song song với JVM, nhưng được sử dụng với mục đích bổ sung / sửa đỗi thêm tính năng cốt lõi cho Maven, chẳng hạn như để hỗ trợ cho việc biên dịch, đóng gói hoặc chạy một tiến trình nào đó.

	- Trong vùng <project>, song song / ngang hàng với vùng <properties>, nằm ngay phía sau phần <dependencies>.
		+ Nhập thêm cặp thẻ <build></build> và cặp thẻ <plugins></plugins> (dạng số nhiều) ở bên trong vùng <build>.
		+ Sau đó viện trợ thêm các "đồ chơi" (plugin) đi kèm với quá trình build để hỗ trợ cho việc chạy Unit Test.

	- Tuy đây là một bộ thư viện dependency, nhưng lại sử dụng như plugin. Vì vậy, phải bỏ cặp thẻ <dependency></dependency> sau khi sao chép và dán.

	Ví dụ: khai báo plugin

		<project>

		    <properties>
			...
		    </properties>

		    <dependencies>

			    <dependency>
				...
			    </dependency>

			    <build>
				<plugins>

				    <!-- Khai báo plugin tại đây -->
				    <plugin>
					...
				    </plugin>

				</plugins>
			    </build>

		    </dependencies>

		</project>

--------------------------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Thư viện phụ thuộc cung cấp hàm để tham chiếu,	│
│	plugin sẽ hỗ trợ cho việc thực thi		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

	[NHỮNG LOẠI DỰ ÁN MẪU TRONG MAVEN - ARCHETYPE]

Bên cạnh việc tạo một dự án bằng Maven như truyền thống, cũng sẽ có những dự án liên quan đến những Framework phức tạp (ví dụ: kotlin, spring...), đòi hỏi cấu trúc thư mục dự án cũng phải phức tạp hơn.
	- Bên cạnh đó, những dự án khác nhau (ví dụ: web app, desktop, console...) thì cách tổ chức thư mục cũng sẽ khác nhau.
	- Vì vậy, Maven đã đưa thêm một cơ chế để hỗ trợ tạo nhanh một cấu trúc dự án được gọi là Archetype (nguyên mẫu).

* Archetype (nguyên mẫu): Là một loại / kiểu mẫu / giàn khung (template) có sẵn tuỳ theo loại dự án, đã được cộng đồng Maven tạo sẵn.
	- Thống nhất rằng thư mục src sẽ là nơi chứa toàn bộ mã nguồn và thư mục target sẽ là nơi chứa toàn bộ những tập tin được xuất ra trong quá trình làm dự án.	
	- Còn lại, tuỳ vào những dự án khác nhau mà sẽ có cấu trúc thư mục cũng sẽ khác nhau.

	-> Danh sách những dự án mẫu với các thư viện tham chiếu và những tập tin chuẩn.

		Ví dụ 1: trong IntelliJ, để sử dụng dự án mẫu dành cho OOP cơ bản
			New Project -> Maven -> 
				org.apache.maven.archetypes:maven-archetype-quickstart

		Ví dụ 2: trong NetBeans, để sử dụng dự án mẫu dành cho OOP cơ bản
			New Project -> Java with Maven -> Project from Archetype
				maven-archetype-quickstart

--------------------------------------------------------------------------------

	[SỬ DỤNG MAVEN "THỦ CÔNG" BẰNG CỬA SỔ DÒNG LỆNH]

	* Cấu trúc thư mục trong Maven:

		my-app
		|-- target\
		|-- pom.xml
		`-- src
		    |-- main
		    |   |-- java
		    |   |   `-- com
		    |   |       `-- mycompany
		    |   |           `-- app
		    |   |               `-- App.java
		    |   |
		    |   |-- resources
		    |   |   `-- META-INF
		    |   |       |-- application.properties // Cấu hình, ví dụ: đa ngôn ngữ...
		    |   |
		    |   `-- webapp // Dành riêng cho dự án ứng dụng web
		    |       `-- WEB-INF
		    |           |-- App.JSP
		    |
		    `-- test
		        |-- java
		        |   `-- com
		        |       `-- mycompany
		        |           `-- app
		        |               `-- AppTest.java
			|
		        `-- resources
		            `-- test.properties


Apache là tổ chức chịu trách nhiệm duy trì những dạng chuẩn của Java, cung cấp sẵn một số dự án mẫu (có sẵn giàn khung), cho phép tạo nhanh một dự án bằng cửa sổ dòng lệnh:

	Bước 01: Tải phiên bản mới nhất của Maven (Binary zip archive):
		| https://maven.apache.org/download.cgi

	Bước 02: Giải nén vào một thư mục trên ổ đĩa C:
		| Ví dụ: C:\Program Files

	Bước 03: Thiết lập biến môi trường, bên trong lưu địa chỉ đường dẫn thư mục:
		JAVA_HOME: nơi cài đặt JDK, cho biết Java được cài đặt ở đâu, là "mái nhà" chung để tìm về dành cho những ai muốn tìm Java.
		Path:
			- %JAVA_HOME%\bin (Thư mục bin của JDK - nơi chứa những câu lệnh của JDK để thực sự chạy).
			- %M2_HOME%\bin (Thư mục bin của Maven - nơi chứa những câu lệnh của Maven để thực sự chạy).
		M2_HOME: [Tuỳ chọn] nơi cài đặt Maven, cho biết Maven được cài đặt ở đâu, là "mái nhà" chung để tìm về dành cho những dự án sử dụng Maven.
		M2: [Tuỳ chọn] thư mục M2_HOME\bin (sau đó có thể đưa M2 vào trong Path).

	Bước 04: Chuyển đến thư mục cần chứa dự án bằng cách mở cửa sổ dòng lệnh trực tiếp trên thanh địa chỉ của trình quản lý tập tin (File Explorer) hoặc sử dụng câu lệnh cd (Change Directory), sau đó gõ lệnh (trên cùng một dòng) để tải dự án mẫu về:
		| mvn archetype:generate // Liệt kê danh sách các dự án sẵn có
					 // vào trực tiếp cửa sổ dòng lệnh,
					 // nhưng nếu muốn in ra một tập tin văn bản:
					 // "> tên-tập-tin.txt"

			-DgroupId=com.hoangthuan // Tên thương hiệu của người sử dụng
			-DartifactId=math-util // Tên dự án do người sử dụng tự đặt

			// Mặc định của dự án (nếu không khai báo):
			// - Phiên bản: 1.0-SNAPSHOT
			// - Tên gói: Trùng với tên thương hiệu

			-DarchetypeGroupId=org.apache.maven.archetypes // Nơi làm ra mẫu dự án
			-DarchetypeArtifactId=maven-archetype-quickstart // Tên của mẫu dự án
			-DarchetypeVersion=1.4 // Phiên bản của mẫu dự án

			-DinteractiveMode=false // Không cần hỏi nhiều

			// D là viết tắt của Define

		| mvn archetype:generate -DgroupId=com.hoangthuan -DartifactId=math-util -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false

	Bước 05: Sau khi đã có dự án mẫu, có thể biên dịch và đóng gói ứng dụng bằng câu lệnh:
		| mvn package

			// * Lưu ý: lần đầu biên dịch và đóng gói sẽ tốn thời gian để tải thêm các thư viện hỗ trợ

	Bước 06: Sau khi đã sửa đổi mã nguồn, có thể dọn dẹp (xoá thư mục target), biên dịch (thành *.class) và đóng gói lại (thành *.jar) bằng câu lệnh:
		| mvn clean package

	Bước 07: Gọi máy ảo Java (JVM) để thực thi tập tin *.jar và chỉ rõ nơi chứa hàm main():
		| java -cp target\*.jar <tên.miền / tên.gói>.<TênLớp / TênỨngDụng>

			// cp (class path): chi ra đường dẫn (tên lớp) của tập tin chứa hàm main()

		| java -cp target\math-util-1.0-SNAPSHOT.jar com.hoangthuan.App

	Bước 08: Biến tập tin *.jar thành tập tin thực thi đích thực, không cần chỉ ra đường dẫn chứa hàm main(), bằng cách mở tập tin pom.xml, chỉnh sửa "maven-jar-plugin" và thêm những dòng sau trực tiếp vào plugin:

                    <configuration>
                        <archive>
                            <manifest>
                                <!-- <mainClass>com.hoangthuan.App</mainClass> -->
                                <mainClass>tên.miền / tên.gói.TênLớp / TênỨngDụng</mainClass>
                            </manifest>
                        </archive>
                    </configuration>

	Bước 09: Lúc này, chỉ việc gọi máy ảo Java (JVM) để thực thi trực tiếp tập tin *.jar và bỏ qua bước "chỉ rõ đường dẫn chứa hàm main()":
		| java -jar target\*.jar
		| java -jar target\math-util-1.0-SNAPSHOT.jar

	Bước 10: Đưa thư viện *.jar vào kho chứa cục bộ .m2\repository\:
		| mvn install

			// * Lưu ý: lần đầu sẽ tốn thời gian
			//	    để tải thêm các thư viện hỗ trợ

------------------------------------------------------------

Quá trình buld của Maven sẽ diễn ra theo tiến trình:
	Build Life Cycles
	> Build Phases
	> Build Goals

	Default
		compile -> *.class
			// Mỗi lệnh nhỏ bên trong
			// sẽ tương đương với một plugin (goal)
		package -> *.jar, *.war
		test
		install // Đóng gói và đưa tập tin *.jar vào kho cục bộ .m2
		deploy // Đưa lên Server chứa code chung
	Clean
	Site

==========================================================================================
==========================================================================================
==========================================================================================

[ÔN TẬP KIẾN THỨC VỀ LẬP TRÌNH CƠ BẢN
 VÀ NHỮNG ĐIỀU KHÁC BIỆT TRONG JAVA SO VỚI C]

==========================================================================================

[BIẾN & GIÁ TRỊ - VARIABLE & VALUE]

Cách lập trình và cách hoạt động của máy tính đều dựa trên tư duy của con người, con người hành xử như thế nào thì máy tính cũng sẽ hành xử theo giống hệt vậy.

Khi có quá nhiều thông tin (số liệu/dữ liệu - data) xung quanh cuộc sống, thì con người sẽ có xu hướng:
	- Đặt tên gọi cho các giá trị để dễ phân biệt (Identify).
	- Tổng quát hoá thành công thức (Function).
	- Phân loại thông tin (Classify).

--------------------------------------------------------------------------------

Biến là tên gọi cho những dữ liệu được đưa vào máy tính (RAM) nhằm mục đích lưu trữ và xử lý sau này.

	- Chiếm một số Byte nhất định tuỳ vào kiểu dữ liệu mà nó sẽ chứa nên trong.

	- Dữ liệu được chứa có thể là:

		+ Giá trị đơn giản / nguyên thuỷ / sơ cấp (Single / Primitive / Non-Object value): Cùng một tên biến nhưng bên trong chỉ chứa một giá trị / thông tin.
			-> Bên trong chứa giá trị có thể thay đổi, nhưng tại một thời điểm chỉ chứa được duy nhất một giá trị.
				(Một tên gọi để nói về một thứ duy nhất.)

		+ Giá trị phức tạp / phức hợp / có cấu trúc (Complex / Composite / Object value): Cùng một tên biến nhưng bên trong chứa nhiều giá trị/thông tin và mang theo nhiều ý nghĩa.
			- Là một sự kết hợp khi bên trong sẽ bao gồm nhiều giá trị đơn giản khác hoặc thậm chí là những giá trị phức tạp khác nữa.
			- Sử dụng bằng tên gọi và đi sâu vào bên trong thông qua dấu chấm '.', còn phức tạp thì vẫn sẽ còn chấm '.' được, có thể đến vô tận nếu vẫn còn phức tạp.
			-> Bên trong chứa những biến và giá trị có thể là đơn giản hoặc phức tạp khác.
				(Một tên gọi để nói về một thứ gồm nhiều thứ khác bên trong.)

			Ví dụ: một biến tên là "sếp", có thể hiểu đây là

				// Một giá trị phức tạp
				1. Ca sĩ Sơn Tùng M-TP.

					// Những biến và giá trị đơn giản khác

					// Biến			  // Giá trị
					+ tênThật		: Nguyễn Thanh Tùng.
					+ nămSinh		: 1994.
					+ quêQuán		: thành phố Thái Bình.
					+ sốBàiHát		: ≈ 100.
					+ sốBộPhimĐãĐóng	: ≈ 10.
					+ thuNhập		: ≈ 100.000.000.000 vnđ.
					+ cảmXúc		: bất ngờ khi biết
								  em trai Mono của mình
								  trình diễn ca khúc đầu tiên
								  trong sự nghiệp ca sĩ.

				2. Người quản lý và trả tiền lương.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Biến là một vùng RAM được đặt tên, chiếm một vùng nhớ nhất định trong RAM,	│
│	được sử dụng để chứa giá trị đơn giản (primitive) hoặc phức tạp (object)	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

* In dữ liệu (Print):

	- Mặc định (có tự động xuống dòng):
		| System.out.println("");
	
	- In nhưng không tự động xuống dòng:
		| System.out.print("");

	- In giống định dạng của C (không tự động xuống dòng):
		| System.out.printf("");

	- In ra chữ màu đỏ để thông báo lỗi:
		| System.err.println("");

	* Lưu ý: vì câu lệnh in dữ liệu là in ra dưới dạng chuỗi, nên ngôn ngữ Java sẽ tự động chuyển những biến trong câu lệnh thành dạng chuỗi trước khi bắt đầu ghép nối.

--------------------------------------------------------------------------------

* Giá trị trực tiếp (Literal value): mọi giá trị (số, chữ, chuỗi...) nếu đã xuất hiện trực tiếp trong code, không cần phải thông qua trung gian (bên ngoài đưa vào, tính toán mà có...), đều được gọi là literal value.
	- Phải thấy được trực tiếp mặt (nằm trơ trọi) thì mới được gọi là literal value.
	- Có nhiệm vụ trực tiếp cung cấp một giá trị cố định cho biến hoặc cho câu điều kiện, vòng lặp; giúp tối ưu hoá hiệu suất và giúp code dễ đọc hơn khi giá trị đã sẵn có thay vì phải đợi một bên khác cung cấp.
	- Nếu chưa xuất hiện (giấu trong một biến và đợi nhập từ bán phím, đợi tính toán...) thì sẽ không được gọi là literal value.

	-> Những giá trị xuất hiện trực tiếp (nằm trơ trọi) trong code.
	
	* Các loại giá trị trực tiếp (literal) trong Java:
		- Số nguyên (int, short, byte, long): [0-9]
			+ Số nguyên thập phân: 69, -96
			+ Số nguyên bát phân (hệ cơ số 8): 061 (49 của hệ 10), 0765 (501 của hệ 10)
			+ Số nguyên thập lục phân (hệ cơ số 16): 0XC (12 của hệ 10), 0x54 (84 của hệ 10), -0X6BF8 (-27640 của hệ 10)
		- Số thực (float, double): 0.1, 3.14, -0.00987
		- Kí tự (char): 'A'
		- Chuỗi (String): "age"
		- Luận lý (Boolean): true, false
		- Null: null

		Ví dụ: Trực tiếp gán giá trị cho tên biến.

			int age = 23;
			String message = "Hello, world!";

	- Mọi số nguyên xuất hiện trong code sẽ được hiểu là kiểu integer (int) chứ không phải là short, long, địa chỉ... và sẽ chiếm 4 Byte.

		+ Vì chỉ chứa được tối đa 2 tỉ 1 (4 byte - 9 số  0), nên sẽ bị tràn miền nếu cố tình gán một giá trị lớn hơn giá trị được phép nhận (ví dụ: 3 tỉ).

		+ Để lưu trữ được một số nguyên lớn hơn 2 tỉ 1, ta phải sử dụng kiểu long. Nhưng vì không được Java ưu tiên trong việc sử dụng, nên kiểu long (9 byte - 16 số 0) phải đi kèm với hậu tố (suffix) với kí tự 'L' hoặc 'l' ở cuối để ám chỉ đang nói về kiểu long.

		+ Số 0 là một con số rất đặc biệt, mặc dù tại ngữ cảnh tham chiếu trong RAM thì đây lại được xem là "đáy RAM" - vùng NULL, nhưng đồng thời vẫn được xem là literal value, vì có xuất hiện trong code dưới dạng một con số.

		Ví dụ: khi nói về giá trị 15 tỉ kiểu long.

			// Khai báo biến kiểu số nguyên - long
			long money = 14_000_000_000;

			// Sẽ gặp lỗi vì mặc định số nguyên sẽ có kiểu integer,
			// vì vậy, nếu có sử dụng kiểu long
			// thì phải sử dụng thêm kí tự 'L' ở cuối giá trị
			long money = 14_000_000_000L;

	- Tương tự như kiểu số thực, Java cũng sẽ sử dụng double (8 byte - 308 số 0) làm kiểu số thực mặc định (trong khi ngôn ngữ C sẽ ưu tên cho float). Vì vậy, để sử dụng float (4 byte - 38 số 0) thì phải đi kèm hậu tố (suffix) với kí tự 'F' hoặc 'f' ở cuối.

		Ví dụ: khi nói về số PI kiểu float.
			float pi = 3.14F;

		* Lưu ý: khi sử dụng các đặc tả kiểu dữ liệu trong câu lệnh printf(), đối với số thực, Java chỉ sử dụng chung đặc tả %f cho cả hai kiểu dữ liệu float và double.

----------------------------------------

* Lưu ý: mảng không còn được xem là literal value, vì bên trong nó ẩn chứa nhiều giá trị chứ không trực tiếp hiển thị ra bên ngoài.

------------------------------------------------------------

* Final / Constant: Là một từ khoá có thể xuất hiện ở nhiều nơi trong một lớp (class).

	- Thuộc tính (Property): Là một vùng RAM không cho phép thay đổi giá trị, mà giá trị chỉ có thể gán song song với lúc khai báo.

		Ví dụ: Khai báo hằng số bằng từ khoá final.
			final double PI = 3.14;

	- Phương thức (Method): Trong kế thừa, lớp Cha "gia trưởng, bảo thủ" sẽ không cho phép lớp Con vượt mặt (Override), mọi xử lý đều phải sử dụng phương thức của Cha.

		Ví dụ: Khai báo phương thức với từ khoá final.
			public String MyString(double d) {...}

	- Tên lớp (Class): Trong kế thừa, lớp final sẽ không cho phép mở rộng để tạo lớp Con, giống như việc quyết định "tự cung" để tuyệt tự.

		Ví dụ: Khai báo lớp với từ khoá final.
			public final class Math extends Object {...}

-----------------------------------------------------------------------------------------
|		|	 Tên lớp	| Tên thuộc tính	| Tên phương thức	|
|---------------|-----------------------|-----------------------|-----------------------|
|		| Trong kế thừa, đây là	| Là một vùng RAM	| Trong kế thừa, lớp Cha|
|		| "tự cung" để tuyệt tự,| không cho phép	| "gia trưởng, bảo thủ"	|
| final		| không cho phép	| thay đổi giá trị,	| không cho phép lớp Con|
|		| mở rộng (extends)	| mà giá trị chỉ có thể	| vượt mặt, mọi xử lý	|
|		| để tạo lớp Con	| gán trong lúc khai báo| đều phải sử dụng	|
|		|			|			| phương thức của Cha	|
-----------------------------------------------------------------------------------------

--------------------------------------------------------------------------------

* Định dạng dữ liệu: để phân cách giữa các phần khi một con số quá lớn, ta có thể Sử dụng kí tự gạch dưới '_' để định dạng trong lúc viết code (thường để phân cách phần nghìn).

	- Việc này chỉ giúp code dễ đọc hơn, sẽ không xuất hiện khi in ra màn hình.

	Ví dụ:
		int n = 2_100_000_000;

--------------------------------------------------------------------------------

* Tiền tố (prefix): quy định cách để lưu trữ một con số dưới một hệ cơ số nào đó.

	- Hệ 16 (hexa): 0x

		Ví dụ:
			// Các con só nằm sau tiền tố '0x'
			// sẽ bị giới hạn từ 0-9 và từ A-F
			int n = 0xFA;

	- Hệ 8 (oct): 0

		Ví dụ:
			// Các con só nằm sau tiền tố '0'
			// sẽ bị giới hạn từ 0-7
			int n = 077;	// Nhưng kết quả in ra
					// vẫn sẽ là hệ 10: 63

			// Bị lỗi vì chỉ lưu được số từ 0-7
			int n = 091;

--------------------------------------------------------------------------------

* Kí tự và chuỗi (Char & String): mỗi kí tự trong Java sẽ chiếm đến 2 Byte (16 bit) vì có hỗ trợ Unicode.
	- Nhờ vậy, ta có thể thoải mái sử dụng tiếng Việt khi in kết quả ra màn hình.
	- Chuỗi (một đống các kí tự ở với nhau) trong Java được xem là một giá trị phức tạp (thay vì đơn giản), vì có liên quan đến mảng.

Nhưng để lưu được một chuỗi (mảng kí tự), thay vì phải sử dụng mảng kí tự giống trong C, Java sử dụng hẳn một kiểu dữ liệu phức tạp được gọi là String (với chữ 'S' được viết hoa).

	Ví dụ:
		// Chuỗi này phức tạp vì có cả chữ hoa và thường,
		// có khoảng trắng...
		String name = "Nguyễn Hoàng Thuận";

--------------------------------------------------------------------------------

* Luận lý (Boolean): một biểu thức so sánh, một mệnh đề (câu phát biểu) sẽ rơi vào một trong hai trạng thái - đúng hoặc sai

	* Quy ước trạng thái:
		- Đúng: True (1 | > 0)
		- Sai: False (0)
		(Đây là trạng thái, không phải giá trị.)
		
Java sử dụng kiểu dữ liệu đơn boolean (1 bit/1 Byte) để lưu trạng thái đúng hoặc sai, thay vì sử dụng biến int để lưu con số 0 hoặc 1 giống như trong C.

	Ví dụ:
		boolean marriedStatus = true;

		if (marriedStatus == true)
			System.out.println("Đánh đồn có địch mới vui");
		else
			System.out.println("Vườn hồng có lối nhưng chưa ai vào");
			
		System.out.println("Luôn luôn có hy vọng");

==========================================================================================

[CẤU TRÚC CHƯƠNG TRÌNH - CƠ BẢN]

	/*	Ngôn ngữ C	*/	|	/*	Ngôn ngữ Java	*/
					|	
	// Khai báo thư viện		|	// Khai báo thư viện, gói
	#include <stdio.h>		|	package tên-gói;
					|	import tên-gói;
					|	
					|	// Tên lớn
					|	public class VarNFun {
					|	
	// Hàm con			|		// Hàm con
	void print() {...}		|		public static void print() {...}
					|	
	// Hàm main()			|		// Hàm main()
	int main() {...}		|		public static void main(...) {...}
					|	
	// Hàm con			|		// Hàm con
	void print() {...}		|		public static void print() {...}
					|	
					|	}

--------------------------------------------------------------------------------

Khi trong một chương trình gồm nhiều main() khác nhau, những sẽ luôn luôn có một main() làm mặc định.
	- Đây có thể là hàm main() được tạo mặc định trong lần đầu tiên tạo dự án.
	- Hoặc có thể là hàm main() đầu tiên do người dùng tự tạo ra.

Vì vậy, khi sử dụng NetBeans...
	- Nếu sử dụng F6 (Run Project) thì hàm main() mặc định ấy sẽ được gọi, bất kể tập tin nào đang được mở lên và sử dụng (chỉnh sửa).
	- Nếu muốn sử dụng một hàm main() khác, trước tiên ta phải mở hàm main() đó lên, sau đó nhấn Shift + F6 (Run File).

Nhưng ta vẫn có thể thay đổi và chỉ ra đâu mới là hàm main() mặc định trong NetBeans.
	1. Chọn dự án.
	2. Chuột phải > Properties
	3. Run
	4. Main Class > Browse... > Select Main Class

==========================================================================================
==========================================================================================
==========================================================================================

[LỚP & ĐỐI TƯỢNG - CLASS & OBJECT]

Trong cuộc sống, rất nhiều thứ được sáng tạo dựa trên những thứ đã có sẵn.

	Ví dụ: Ở thời điểm hiện tại, vì mọi sự sống trên Trái Đất đều xoay tròn quanh ôxy, nên các kỹ thuật để tìm kiếm các hành tinh và sự sống khác ngoài Trái Đất đều là dò tìm khí ôxy trong khí quyển.

--------------------------------------------------------------------------------

	* Đối: đáp lại, trả lại, hướng về, chĩa vào.

		Ví dụ 1: đối đáp, đối xử, đối phó, đối đầu...

		Ví dụ 2: môn đương hộ đối
			(Nếu một bên có "môn" - cửa lớn
				thì bên còn lại phải có "môn" để đương lại;
				bên một bên có "hộ" - cửa nhỏ
				thì bên còn lại phải có "hộ" để đối lại.)

	* Tượng: hình dáng, trạng thái hiện ra trước mắt.

		Ví dụ: hình tượng, cảnh tượng, hiện tượng, khí tượng - trạng thái của khí quyển...

------------------------------------------------------------

* Đối tượng (Object): hiện tượng (TƯỢNG) phải tìm cách đối phó, xử lý (ĐỐI).

	- Là một nhóm người dùng có cùng một hoặc nhiều đặc điểm hoặc mẫu hành vi xác định.

		Ví dụ:
			- Đối tượng chính sách.
			- Đối tượng Đảng.
			- Đối tượng người thiểu số.
			- Đối tượng nam.
			- Đối tượng nữ.
			- Đối tượng già.
			- Đối tượng trẻ.
			- Đối tượng gây án.
			- Đối tượng truy nã.
			- Đối tượng bị tình nghi.

	- Chỉ người, sự vật và hiện tượng [ở trước mặt] mà con người tác động tới, nhắm tới - đặt mục tiêu/mục đích tới (trong suy nghĩ hoặc hành động).

		Ví dụ:
			- Đối tượng điều chỉnh của pháp luật.
			- Đối tượng nghiên cứu.
			- Đối tượng khảo sát.
			- Đối tượng phục vụ.
			- Đối tượng dự thi.

	- Trong tình yêu đôi lứa, để chỉ người được yêu (người yêu, người tình) - người đang hoặc định sẽ tìm hiểu trước khi yêu hoặc kết hôn.
		(Vẫn với ý nghĩa là người mà mình dành sự quan tâm đến.)

		Ví dụ:
			- Đối tượng phù hợp để hẹn hò.
			- "Và bi kịch của tình yêu ở chỗ,
			   người ta không bao giờ yêu đối tượng như nó đang là,
			   mà luôn chỉ yêu đối tượng phải như mình mong muốn,
			   như nó phải là."
				(https://www.phunuonline.com.vn/em-bao-anh-di-di-sao-anh-lai-di-luon--a1412652.html)


		* Vị ngữ: Là một từ hoặc cụm từ đứng sau chủ ngữ (hoặc trạng ngữ) để nêu hoạt động, trạng thái, tính chất, bản chất, đặc điểm... và trả lời cho câu hỏi: Là gì? Là ai? Làm sao? Như thế nào?... nhằm cung cấp thêm các thông tin lên quan đến chủ ngữ (hoặc trạng ngữ).
			Ví dụ: Hùng và Ngân là hai cán bộ xã.
				* Vị ngữ ở đây là cụm từ "hai cán bộ xã":
					- Trả lời cho câu hỏi "Là ai?".
					- Cung cấp thêm thông tin cho chủ ngữ "Hùng và Ngân".

	- Trong tiếng Anh, tân ngữ (object) thuộc thành phần vị ngữ của câu, là đối tượng (danh từ hoặc đại từ) bị tác động bởi động từ hoặc giới từ. Dựa vào vị trí cũng như ý nghĩa của tân ngữ trong câu, ta chia ra 3 loại tân ngữ:
		1. Tân ngữ trực tiếp (Direct Object): Đối tượng đầu tiên nhận tác động của hành động (động từ).
		2. Tân ngữ gián tiếp (Indirect Object): Đối tượng mà hành động xảy ra trực tiếp lên chính đối tượng đó.
		3. Tân ngữ của giới từ (Object of a Preposition): Đối tượng đứng đằng sau và bị tác động bởi một giới từ trong câu.

		Ví dụ: 
			1. Tân ngữ trực tiếp (Direct Object):
				- Tôi yêu cô ấy.
					(Động từ: yêu | TNTT: cô ấy)
				- Con mèo bắt chuột.
					(Động từ: bắt | TNTT: chuột)
				- Tôi không có tài khoản ngân hàng.
					(Động từ: không có | TNTT: tài khoản ngân hàng)

			2. Tân ngữ gián tiếp (Indirect Object):
				- Cô ấy đã cho anh ta một cơ hội.
					(Động từ: cho | TNGT: anh ta | TNTT: cơ hội)
				- Anh ấy đưa tôi quyển sách.
					(Động từ: đưa | TNGT: tôi | TNTT: quyển sách)
				- Người quản lý luôn nói với nhân viên sự thật.
					(Động từ: nói | TNGT: nhân viên | TNTT: sự thật)

			3. Tân ngữ của giới từ (Object of a Preposition):
				- Tôi đi ăn tối với người yêu.
					(Động từ: đi ăn | Giới từ: với | TNcGT: người yêu)
				- Tony sống ở gần tôi.
					(Động từ: sống | Giới từ: gần | TNcGT: tôi)
				- Quyển sách nằm trên bàn.
					(Động từ: nằm | Giới từ: trên | TNcGT: bàn)

------------------------------------------------------------

	* Các khái niệm ngoài đời thực gắn liền với đối tượng:

		* Thuộc tính (Property): đặc tính vốn có của một sự vật, nhờ đó sự vật tồn tại và qua đó con người nhận thức được sự vật, phân biệt được sự vật này với sự vật khác. Là những đặc tính để đối tượng tự thấu hiểu và mô tả về chính mình.

			Ví dụ 1: con người có các đặc tính như mắt, mũi, tay, chân...

			Ví dụ 2: màu sắc là thuộc tính của cả vật thể và ánh sáng.

		* Phương thức (Method): phương pháp, biện pháp, cách thức, hành động, việc làm có mục đích.

			Ví dụ: một người sẽ có thể thực hiện hành động nói, đi, ăn, uống,...

--------------------------------------------------------------------------------

* Lớp (Class): tập hợp những sự vật, con người có cùng đặc tính.

	- Tập hợp người cùng một lứa tuổi, cùng thế hệ hay cùng có chung những đặc trưng xã hội nào đó.
		Ví dụ:
			- Lớp người già.
			- Lớp thanh niên.
			- Lớp đàn em.
			- Lớp công nhân.
			- Lớp học.

	- Tập hợp nhiều vật cùng một chất để chồng lên nhau (đặt/đắp chồng lên nhau để thành một toàn thể).
		Ví dụ:
			- Lớp lá để gói.
			- Lớp giấy bồi.
			- Lớp đất.
			- Lớp cát.
			- Lớp đá.

==========================================================================================

[ĐỐI TƯỢNG TRONG LẬP TRÌNH - OBJECT]

Lập trình hướng đối tượng cũng được lấy cảm hứng từ ngoài đời thật: Dựa theo sự phân loại và gom những đối tượng có những cùng điểm chung (về thuộc tính và phương thức) vào cùng một nhóm.
	- Vì mọi thứ xung quanh đời sống đều được xem là đối tượng, nên bước đầu ta sẽ tìm kiếm và nhận diện đối tượng.
	- Sau đó chuyển đổi những đối tượng trong thực tế vào trong lập trình được gọi là mô hình hoá (modeling).
	- Mong muốn tạo ra một chương trình giống với đời thực để người dùng có thể nhanh chóng sử dụng được mà không cần phải đào tạo.

	-> Lập trình hướng đối tượng (Object Oriented Programming).

* Đối tượng (Object / Instant): Thực thể / Sự vật / Đồ vật (Thứ - Thing) và sự kiện (Event) cụ thể xung quanh chúng ta, hữu hình hoặc vô hình.
	* Hữu hình (Tangible): Là những thứ cụ thể, có thể cảm nhận được bằng giác quan (thấy, chạm vào,...).
	* Vô hình (In-Tangible):
		- Là những thứ trừu tượng, mơ hồ.
		- Chỉ là những khái niệm do con người đặt ra (với mục đích quản lý,...).
		- Không thể cảm nhận được bằng giác quan, nhưng vẫn có thể nhận biết được về sự tồn tại bằng nhận thức.

		Ví dụ:
			* Hữu hình - Cụ thể (Tangible):
				- Hoá đơn tiền điện.
				- Quyển sách.
				- Chiếc xe.
				- ...

			* Vô hình - Mơ hồ (In-Tangible):
				- Bình luận / Đánh giá của khách hàng.
				- Nhóm hàng.
				- Khu vực.
				- Chuyên ngành.
				- Lớp học.
				- Ma, quỷ.
				- ...

			* Sự kiện (Event):
				- Buổi đấu giá.
				- Buổi bầu cử.

	- Bên trong chứa đựng nhiều thông tin (cần một không gian rộng lớn để lưu trữ - Heap).
	
	- Với những đặc điểm và hành vi được liệt kê, từ đó cho phép ta chạm / mô tả / nhận diện được đối tượng hoặc thậm chí là đếm được chúng để phân biệt với những đối tượng khác - xác định một sự duy nhất.

	-> Những gì cụ thể chứa thông tin và có thể phân biệt được (bằng cách mô tả / đếm).
		(Sau đó lựa ra các đặc điểm quan trọng để tạo thành khuôn - lớp.)

		=> Đối tương cụ thể.

	- Trong lập trình, một đối tượng cụ thể là một phiên bản thực tế được tạo ra (được đúc ra từ một khuôn).
		+ Đối tượng mới chính là thực thể hoạt động trong hệ thống chứ không phải là khuôn.
		+ Cho phép ta trực tiếp sử dụng (tên) đối tượng để truy xuất những thông tin công khai của đối tượng.

	- Mặc dù hai đối tượng có thể giống nhau hoàn toàn về mặt thông tin / trạng thái (state) vì được đúc ra từ cùng một khuôn, nhưng chúng vẫn là hai đối tượng độc lập nhau.

		Ví dụ: khi các cặp đôi yêu nhau và rủ nhau đi chơi.

			- Đặt hình nền điện thoại đôi.
				-> Vẫn là hai hình nền điện thoại độc lập.

			- Đi xe đôi.
				-> Vẫn là hai chiếc xe độc lập.

			- Mua đồ đôi / đồ cặp.
				-> Vẫn là hai món đồ độc lập.

			- Ăn món đôi.
				-> Vẫn là hai phần ăn độc lập.

			- Mua vé xem phim đôi.
				-> Vẫn là hai vé xem phim độc lập.

			- Tô tượng đôi.
				-> Vẫn là hai bức tượng độc lập.

--------------------------------------------------------------------------------

Bên trong mỗi đối tượng sẽ chứa nhiều thông tin và được mô tả/phân biệt thông qua các:
	- Tên gọi tắt / định danh (Object Variable / Object Reference): tên gọi để xác định / nhận dạng.
	- Các đặc điểm / thuộc tính và giá trị đi kèm (Instance Variable): vẫn tồn tại dù có thể không thể nhìn thấy được.
	- Các hành vi / hành động/phương thức (Behavior / Method): có hoạt động/động đậy và biến đổi.
	-> Bên cạnh tên gọi, các đối tượng sẽ có thêm thuộc tính và phương thức.
		(Nhiều thứ được gói lại trong một khuôn để tạo nên cái "chất" của một đối tượng.)

		Ví dụ 1: khi nói về một đối tượng con người.

			// Tên đối tượng
			Tên gọi tắt: sếpTùng
				- Thuộc tính:

					// Biến và giá trị đơn giản

					// Biến		  // Giá trị
					tênThật		: Sơn Tùng M-TP.
					nămSinh		: 1994
					quêQuán		: thành phố Thái Bình
					sốBàiHát	: ≈ 100 bài
					sốBộPhimĐãĐóng	: ≈ 10 bộ

				- Phương thức:
					caHát()
					sángTácNhạc()
					đóngPhim()
					đóngQuảngCáo()

		Ví dụ 2: khi một đối tượng đang đèo crush thì bỗng va quẹt với một đối tượng khác.

			// Tên đối tượng
			Tên gọi tắt: simpLord
				- Thuộc tính:

					// Biến và giá trị đơn giản

					// Biến		  // Giá trị
					tênThật		: Cơ Thiếu Hoàng
					tênPhụHuynh	: quốc trưởng Trần Dần
					nămSinh		: 1996
					trườngHọc	: Đại học Bách khoa
					khoaTheoHọc	: Khoa Cơ khí

				- Phương thức:
					gáyBẩn("Mày có biết bố mày là ai không?");
					xưngTên("Bố mày là: " + tênPhụHuynh);

------------------------------------------------------------

* Lưu ý: Theo định nghĩa về đối tượng ("bên trong chứa đựng nhiều thông tin và có thể phân biệt được")...
	- Không chỉ riêng con người và con vật mới được xem là đối tượng.
	- Những món đồ vật xung quanh chúng ta, nếu nhân cách hoá lên, chúng vẫn được xem là một đối tượng.
		+ Bên cạnh những đặc điểm bên ngoài có thể dễ dàng nhìn thấy, chúng vẫn có những hành vi.
		+ Những hành vi này chủ yếu cũng là để tương tác và phục vụ cho con người.

			Ví dụ:
				- Tủ bị "khoá".
				- Trái tim "đập".
				- Máy tính bị "đơ".
				- Sóng wifi bị "chậm".
				- Điều khiển từ xa bấm không "ăn".
				- Máy quạt "kêu".
				- Chuông điện thoại "reo".
				- Xe "chạy".
				- Tivi "dò" kênh.
				- Hàng quán "đóng" cửa.
				- Lá thu "kêu" xào xạc.
				- ...

		+ Đây hoàn toàn là những hành vi có sẵn khi được thiết kế, tuy có nhận mệnh lệnh từ một đối tượng nào đó khác, nhưng cuối cùng những đối tượng được "nhân cách hoá" này vẫn phải tự mình thực thi.

			Ví dụ:
				- Bãi đỗ xe tự động sẽ tự biết để cất và lấy xe giùm khách khi được chủ xe yêu cầu.
				- Ứng dụng cung cấp dịch vụ giao đồ ăn ngăn không cho người dùng đặt món khi chủ quán muốn tạm nghỉ bán.
				- Khoá vân tay sẽ quyết định cho phép hoặc không cho phép mở khoá dựa vào dấu vấn tay được đưa vào.
				- ...

	-> Nhìn đối tượng rộng hơn - ở mức thực thể thống (có hoạt động và thay đổi trạng thái).

		Ví dụ 1: Một tin nhắn cũng được xem là đối tượng.

				// Biến		  // Giá trị
				tênNgườiGửi	: 
				tênNgườiNhận	: 
				thờiGianGửi	: 
				nộiDung		: 
				cóBiểuTượng	: 

		Ví dụ 2: Một giá đựng sách / tài liệu / hồ sơ cũng được xem là đối tượng.

				// Biến		  // Giá trị
				tênLoạiKệ	: 
				chiềuCao	: 
				chiềuRộng	: 
				cânNặng		: 
				chấtLiệu	: 
				giáTiền		: 

		Ví dụ 3: Một danh sách (sinh viên, nhân viên, công dân...).

				// Biến		  // Giá trị
				tên		: 
				nămSinh		: 
				chiềuCao	: 
				cânNặng		: 
				màuDa		: 
				màuTóc		: 
				chứcVụ		: 
				tínhTình	: 

				// Hành vi
				xoáĐốiTượng()
				thêmĐốiTượng()
				sửaThôngTinĐốiTượng()
				sắpXếpDanhSáchĐốiTượng()

	- Ngoài ra, còn có một loại đối tượng được gọi là "thùng chứa" khi bên trong có thể chứa nhiều đối tượng khác.
		+ Vẫn là một đối tượng, có thể mô tả được đặc điểm và hành vi của đối tượng này.
		+ Chỉ có điều, lúc này, một trong những đặc điểm của đối tượng này lại là một đối tượng phức tạp khác.
		+ Khi đối tượng "thùng chứa" được tạo ra, ngoài vùng nhớ dành cho những đặc điểm thông thường, một vùng nhớ rỗng để chứa những đối tượng phức tạp cũng sẽ mặc định được tạo theo (việc có sử dụng hết vùng nhớ "ăn theo" này thì còn tuỳ vào thiết kế và mục đích sử dụng).
		-> Kẻ đi gieo tương tư giờ thành kẻ đi ôm tương tư.

		Ví dụ 1: Các loại đối tượng chứa bên trong nhiều đối tượng khác.

			- Trong đối tượng "Máy bay":
				+ Có thông tin: tảiTrọng, trọngLượng, độngCơ, loạiMáyBay...
				+ Có đối tượng: Hànhkhách, TiếpViên, CơTrưởng, CơPhó...

			- Trong đối tượng "Rạp phim":
				+ Có thông tin: máyChiếu, mànHình, âmThanh, sốGhế...
				+ Có đối tượng: KhánGiả, GiámSátViên, SoátVéViên...

			- Trong đối tượng "Sách":
				+ Có thông tin: mãSốISBN, tênSách, sốTrang, kíchThước...
				+ Có đối tượng: TácGiả, DịchGiả, NhàXuấtBản...

		Ví dụ 2: Nhóm Kệ / Tủ chứa bên trong một thông tin "đặc biệt".

			KệĐựngĐồ
			{
				tênLoạiKệ	: 
				chiềuCao	: 
				chiềuRộng	: 
				cânNặng		: 
				chấtLiệu	: 
				giáTiền		: 
				...
				danhSáchĐồVật[] : 
						{
							- sốTiềnTrongQuỹĐen: 
							- đồLưuNiệm[] {...}
							- bằngKhen[] {...}
							- sách[] {...} 
							- cáCảnh / sinhVậtCảnh[] {...} 
							- giầyTờQuanTrọng[] {...} 
							- ...
						}
			}

--------------------------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Đối tượng là những thứ cụ thể xung quanh chúng ta,		│
│	hữu hình hoặc vô hình,						│
│	bên trong chứa đựng nhiều thông tin và có thể phân biệt được	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Mỗi đối tượng phải thỏa mãn 3 nguyên lý:					│
│											│
│		1. Phân biệt/Độc nhất (Distinction): là một đợn vị (unit) duy nhất.	│
│			-> Định danh.							│
│											│
│		2. Bền vững (Permanence): quá trình sống.				│
│			-> Trạng thái/Thuộc tính.					│
│											│
│		3. Hoạt động (Activity): vai trò, hành vi.				│
│			-> Hành động/Phương thức.					│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[TÊN GỌI TẮT / ĐỊNH DANH CỦA ĐỐI TƯỢNG - OBJECT VARIABLE / REFERENCE VARIABLE]

Mỗi đối tượng phức tạp đều luôn luôn có ít nhất hai tên gọi:

------------------------------------------------------------

	1. Tên riêng của đối tượng (ID): tên mà những đối tượng khác (bên ngoài) sử dụng để gọi.
		-> Bên ngoài gọi (đứng ở vị trí lớp để gọi - trên cao nhìn xuống).
			(Tên được gọi.)

		Mỗi đối tượng sẽ gồm hai phần (hai vùng RAM):

			1. Tên gọi tắt / Biến đối tượng (Object Variable): được xem là biến con trỏ / tham chiếu, nằm trong vùng nhớ Stack vì được khai báo nội bộ bên trong hàm main().

				- Vì sau khi khởi tạo đối tượng mới bằng câu lệnh new(), biến này sẽ trỏ đến toạ độ / vị trí của Byte đầu tiên trong một vùng RAM chứa nhiều thông tin của đối tượng đó (trong Heap), để quản lý một vùng thông tin của đối tượng.

				- Cũng vì là một biến và lưu giá trị là một địa chỉ vùng nhớ, nên giá trị của biến vẫn có thể được thay đổi, biến có thể trỏ đến một vùng nhớ mới (giống hệt như việc gán giá trị mới cho biến thông thường) và biến cũng chỉ lưu địa chỉ của lần sửa đổi gần nhất.

				-> Người nắm toạ độ để chuẩn bị "oanh tạc".

----------------------------------------

			2. Nơi chứa dữ liệu (Object): đây là nơi chứa đối tượng thực sự, được nằm trong Heap vì đấy là một vùng RAM đủ rộng để chứa những thông tin phức tạp.
			
				- Sau khi khởi tạo đối tượng mới bằng câu lệnh new() và đổ dữ liệu được vào thông qua phễu (Contructor), đây mới thật sự được gọi là đối tượng.
				
				- Là nơi để tên đối tượng (con trỏ) trỏ vào thông qua dấu chấm, vì vùng này chứa toàn bộ thông tin của một đối tượng. Nhưng thay vì gán cả một đối tượng thì chỉ gán địa chỉ / toạ độ vùng RAM cho tên đối tượng.

				-> Đối tượng thật sự chứa thông tin.

				Ví dụ: có thể tưởng tượng về toạ độ và biến nắm toạ độ
					- Nơi chứa dữ liệu (Object): là một con diều với dây thả diều.
					- Biến đối tượng (Object Variable): bàn tay của người thả diều.
						-> Bàn tay và dây diều tạo thành một cầu nối,
						   nếu bàn tay cố gắng giữ dây diều thì diều vẫn còn,
						   nhưng buông tay vì "có mới nới cũ" thì diều cũ sẽ mất.
						   (Lan cắt đứt "dây chuông" thì ân đoạn nghĩa tuyệt.)

------------------------------------------------------------

	2. Mình/tui/ta/tao (This): cái tôi trong mỗi người, chủ thể - tên để gọi chính bản thân.

		- Tên gọi tắt để truy cập vào phần "chất" (thuộc tính & phương thức) của một đối tượng của một lớp.
			+ Tên thay thế cho chính đối tượng đang xử lý.
			+ Có hiệu lực trong phạm vi của một phương thức và kéo dài cho đến khi phương thức đó kết thúc hoặc trả về giá trị.

		- Đây là góc nhìn có được khi đứng từ góc độ đối tượng.

			Ví dụ 1: khi chứng kiến một vụ ẩu đả trong một Lớp học

				// Nhân chứng bên ngoài: bạn Cường
				Bạn Cường: "Tôi thấy bạn Dũng đánh bạn Bình trước."
					-> Sử dụng tên riêng của cả hai đối tượng.

				// Người trong cuộc: bạn Dũng
				Bạn Dũng: "Bạn Bình đánh tôi trước."
					-> Sử dụng tên riêng của đối phương và tự xưng là TÔI.

				// Người trong cuộc: bạn Bình
				Bạn Bình: "Bạn Dũng đánh tôi trước."
					-> Sử dụng tên riêng của đối phương và tự xưng là TÔI.

			Ví dụ 2: khi được hỏi: "Trên thế gian này, khoảng cách nào là xa nhất?"

				// Người ngoài cuộc
				"Là khoảng cách từ ngọnNúiNày đến ngọnNúiKia."
				"Là khoảng cách từ đạiDươngNày đến đạiDươngKia."
				"Là khoảng cách từ châuLụcNày đến châuLụcKia."
					-> Sử dụng tên riêng của cả hai đối tượng.

				// Người trong cuộc
				"Là khoảng cách từ con tim TÔI đến conTimCuaCrush."
					-> Sử dụng tên riêng của đối phương và tự xưng là TÔI.
		* Những trường hợp sử dụng:

			1.Tuy có thể giấu được cả thiên hạ, nhưng không thể nào giấu được chính mình.
				- Sử dụng thêm từ khoá "this" kết hợp với dấu chấm sẽ cho phép hiển thị ra toàn bộ thông tin, dù cho một trong số những thông tin này đang được che giấu với thế giới bên ngoài.
				- Vì vậy, có thể sử dụng giống hệt như khi sử dụng tênĐốiTượng để gọi thuộc tính và phương thức, chỉ có điều câu lệnh sẽ ngắn gọn hơn.

				-> Đề cập đến đối tượng trong lớp.

				Ví dụ: Sử dụng tương đương với tênĐốiTượng.

					tênĐốiTượng.yob;
					tênĐốiTượng.getAge();

					this.yob;
					this.getAge();

			2. Tránh xung đột tên gọi.
				- Khi thiết kế phễu, để người dùng dễ dàng biết cần phải truyền những giá trị gì vào bên trong phễu, nên tên của tham số truyền vào phễu sẽ bị trùng với tên của thuộc tính (biến cục bộ trùng tên với biến toàn cục).
				- Lúc này, sẽ xảy ra hiện tượng ưu tiên người nhà - "Con Ông Cháu Cha", phương thức sẽ ưu tiên hiểu rằng tên biến đang được gọi là tên của tham số đang được truyền từ bên ngoài vào (ưu tiên biến cục bộ trong hàm hơn là biến toàn cục ngoài hàm).
				- Vì vậy, để tránh sự nhầm lẫn trong tên gọi, từ khoá "this" lúc này sẽ giúp xác định được chính xác:
					+ Đâu là giá trị được đưa từ bên ngoài vào.
					+ Đâu mới là thuộc tính bên trong của đối tượng.

				-> Toán tử để trỏ đến một đối tượng trong tương lai.

				Ví dụ: khi tạo một khuôn Dog để đúc ra các chú chó.

					// Các thuộc tính sẽ được đặt ở chế độ riêng tư
					private String name;
					private int yob;
					private double weight;
					
					// Đứng từ khuôn, sử dụng từ khoá "this"
					// để nói về chính những thuộc tính trong khuôn;
					// hàm ý đổ dữ liệu từ bên ngoài
					// vào chính những thuộc tính trong khuôn
					// (Gán giá trị cho biến)
					public Dog(String name, int yob, double weight) {
						this.name = name;
						this.yob = yob;
						this.weight = weight;
					}

			3. Ngoài ra, từ khoá this còn được sử dụng bên trong hàm khởi tạo không tham số (Empty Contructor) để gọi hàm khởi tạo khác trong cùng lớp.
				- Phải là câu lệnh nắm đầu tiên nhất.
				-> Tham chiếu đến constructor khác trong cùng lớp.

				Ví dụ: khi tạo một khuôn PhanSo để tính toán phân số.

					private int tu, mau;
					
					// Hàm khởi tạo có tham số
					public PhanSo(int tu, int mau) {
						this.tu = tu;
						this.mau = mau;
					}

					// Hàm khởi tạo không tham số
					public PhanSo() {

						// Trong trường hợp này,
						// từ khoá this thay thế cho tên hàm
						// và cho phép nhận tham số đầu vào
						this(0, 1);
					}

		-> Bên trong tự vấn (đứng ở vị trí của đối tượng để gọi - POV).
			(Tên tự gọi.)

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Tên của đối tượng thực chất là toạ độ / địa chỉ của đối tượng trong RAM,	│
│	nhưng có được toạ độ trong tay nghĩa là có thể tương tác được với đối tượng	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[THUỘC TÍNH / TRẠNG THÁI CỦA ĐỐI TƯỢNG - PROPERTY / STATE]

* Biến thực thể / Biến thành viên / Vùng tin / Vùng dữ liệu / Trường dữ liệu / Đặc điểm / Trạng thái / Thuộc tính (Field / Instance Variable / Data Member / Property / Attribute / State / Characteristic):
	- Cũng là một loại biến, thậm chí còn là biến toàn cục, nhưng mang trọng trách đại diện cho từng đặc điểm hay trạng thái của một đối tượng.
	- Được khai báo bên ngoài hàm khởi tạo (constructor), các phương thức hoặc khối lệnh khác.
	- Được nằm trong vùng nhớ Heap vì nó gắp liền (được liên kết) với đối tượng và lớp.
	- Khi mỗi đối tượng được tạo ra thì sẽ đều có được một bản sao của biến này, mọi hàm khởi tạo và phương thức trong cùng lớp đều có thể tương tác được (trừ phương thức static).
	- Được gán cho một phạm vi truy cập (Access Modifier) và thường là riêng tư (private) để đảm bảo tính bảo mật về dữ liệu.
	- Vòng đời tồn tại tùy theo vòng đời của đối tượng.
	- Luôn tự động được gán một giá trị mặc định* (phụ thuộc vào kiểu dữ liệu) nếu chưa có câu lệnh gán giá trị.

		* Danh sách những giá trị mặc định* được dùng để khởi tạo cho các kiểu dữ liệu:
			- Số nguyên (int, short, byte, long): 0.
			- Số thực (float, double): 0.0.
			- Luận lý (boolean): false.
			- Kí tự (char): NULL ('\0', '\u0000').
			- Các biến tham chiếu (Object): NULL ('\0', '\u0000').

	-> Biến toàn cục (nằm trong Heap).

Phạm vi truy cập (Access Modifier) cũng thường gắn liền với thuộc tính của đối tượng, quy định rằng thông tin sẽ được giấu kín hoặc công khai để bên ngoài có thể truy cập (bên ngoài được phép và không được phép thấy).

------------------------------------------------------------

* enum (Enumeration): Là từ khoá cho phép tự định nghĩa ra một kiểu dữ liệu đặc biệt dạng liệt kê trong Java.

	- Tập hợp các giá trị sẽ được liệt kê (enumerate) dưới dạng hằng số đã được định nghĩa trước và kèm với các mô tả (nếu có).
	
	- Lúc này, enum được xem như là một lớp (sử dụng từ khoá enum thay cho class), được phép có cả thuộc và phương thức (ví dụ: values()...), và được tách thành một tập tin riêng.
		+ Các "hằng số" chứa bên trong giống như những thuộc tính của lớp, được liệt kê ngăn cách nhau bởi dấu phẩy và có thể truy cập thông qua tên của enum (giống như cách truy cập thuộc tính tĩnh thông qua tên lớp).
		+ Ngoài ra, ta cũng có thể mô tả thêm cho các thuộc tính bằng cách thêm cặp dấu ngoặc tròn "()" phía sau tên thuộc tính.
		+ Các phương thức trong enum sẽ được khai báo dưới dạng trừu tượng.

	- Giúp tránh được việc bị trùng giá trị hoặc giá trị bị sai (vượt biên, ngoài tầm).

	- Có thể được trả về dưới dạng Combo Box (Drop-down list).

Cú pháp khai báo:

	[phạm-vi-truy-cập] enum TênEnum {
		HẰNG_SỐ_1,
		HẰNG_SỐ_2,
		//...; // Dấu ';' có thể không ghi ra
	}

	Ví dụ:
		// Khai báo giống như một lớp
		public enum MauSac {

			// Từng giá trị giống như từng thuộc tính
			DO,
			VANG,
			XANH_LA
		}

		// Sử dụng bằng cách tạo mới đối tượng,
		// gọi giá trị thông qua tên enum và dấu chấm
		Color myColor = MauSac.DO;  // Gán hằng số DO (đỏ) cho biến myColor
		System.out.println(myColor);  // In ra DO (đỏ)

--------------------------------------------------------------------------------

[HÀM - FUNCTION / PHƯƠNG THỨC CỦA ĐỐI TƯỢNG - METHOD]

* Hành vi / Hành động / Hoạt động / Việc làm / Phương thức thực thể / Hàm thành viên (Method / Instance Method / Behavior / Function):
	- Là những quy tắc xử lý thông tin của một đối tượng.
	- Các hành động đều sẽ liên quan đến dữ liệu được cung cấp.
	- Lúc này, tuy biến (thuộc tính) chưa có dữ liệu, nhưng vẫn được phép sử dụng trong phương thức mà không hề hiển thị cảnh báo "biến khai báo mà chưa được khởi tạo"; đó là nhờ giá trị đã được gán thông qua hàm tạo (Constructor).

	-> Hàm gọi đến các biến toàn cục.

Tuy trong lập trình C, hàm được gọi là Function, nhưng trong lập trình hướng đối tượng, hàm được gọi với một tên mới là phương thức (Method).
	- Vì nó liên quan đến khái niệm đối tượng (Object) - cách hành xử.
	- Lúc này, hàm không còn đơn giản là xử lý, mà nó còn mô tả về hoạt động/hành động/hành vi (nhân cách hoá hơn), giúp thay đổi nội dung của nguồn dữ liệu.

Java luôn sử dụng truyền tham trị (pass by value) để truyền tham số vào phương thức.
	- Khi truyền tham số vào một phương thức...
		+ Nếu là kiểu dữ liệu cơ bản (primitive), giá trị của tham số được sao chép và sau đó được truyền cho phương thức.
		+ Nếu là kiểu dữ liệu phức tạp (object), đầu tiên sẽ đi đến địa chỉ tham chiếu của đối tượng, sau đó lấy giá trị bên trong để truyền cho phương thức.
	- Nghĩa là dù có truyền bất kì một giá trị nào (số, chuỗi, mảng...) thì Java cũng sẽ sao chép toàn bộ giá trị bên trong của đối tượng trên Heap, chứ không phải địa chỉ bộ nhớ trên Stack.

	Ví dụ:
		// Ban đầu, khi mới gọi hàm, chưa tiến hành xử lý,
		// con trỏ mảng a sẽ trỏ về cùng vùng nhớ với mảng arr trong main()
		// (chỉ chung giá trị trong vùng nhớ, nhưng khác địa chỉ tham chiếu)
		public static void change(int[] a) {

			// Thay đổi giá trị bên trong vùng Heap sử dụng chung
			// giữa mảng a trong hàm change() và mảng arr trong hàm main()
			a[0] = 99;

			// Một mảng b mới được tạo ra,
			// được cấp một vùng nhớ mới trên Heap
			int[] b = {1, 2, 3};

			// Câu lệnh gán giá trị trực tiếp bằng dấu bằng
			// là câu lệnh thay đổi địa chỉ trỏ

			// b đưa địa chỉ của con trỏ cho a trỏ cùng
			a = b;

			// Sau khi hàm kết thúc,
			// toàn bộ những tham chiếu trong hàm đều sẽ bị mất,
			// giá trị trên Heap sẽ được bộ thu gom rác tự động dọn dẹp
		}

		public static void main(String[] args) {

			// Cấp phát một vùng RAM trên Heap cho mảng arr
			int[] arr = {15, 20, 25};

			// Truyền giá trị của mảng arr
			// cho mảng trong hàm change()
			change(arr);

			// In ra giá trị bên trong Heap của mảng arr
			// (giá trị đã kịp bị mảng a trong hàm change() làm thay đổi)
			System.out.println(arr[0]);	// 99
		}

------------------------------------------------------------

	[PHƯƠNG THỨC KHỞI TẠO / HÀM TẠO - CONSTRUCTOR]

	Vì thuộc tính của đối tượng thực chất cũng chỉ là biến, nên để đưa được dữ liệu vào thuộc tính, ta sẽ có hai cách:
		1. Khởi tạo giá trị ngay lúc khai báo (sau khi đã tính toán ở đâu đó).
		2. Sẽ sử dụng phễu để đưa dữ liệu vào trong tương lai (nơi gọi: hàm main()).

	* Hàm tạo / Phương thức khởi tạo/xây dựng / Phễu (Contructor): Là một hàm rất đặc biệt, có nhiệm vụ giúp đổ thông tin vào các thuộc tính trong khuôn để tạo ra đối tượng mới.

		- Là nơi chịu trách nhiệm cấp phát vùng nhớ cho đối tượng để lưu trữ dữ liệu.
			+  Đồng thời, tên hàm bắt buộc phải trùng với tên lớp (tên lớp trùng với tên tập tin) để mang ý nghĩa tạo ra sản phầm tương ứng với lớp đó.
			+ Thường được công khai (public) cho bất kì ai có nhu cầu sử dụng (đúc đối tượng) và chỉ được sử dụng một lần khi đối tượng chưa được đúc.

		- Bên cạnh đó, ta có thể tận dụng để gán mặc định và kiểm soát các giá trị sẽ được đưa vào thuộc tính thay vì chấp nhận các giá trị có sẵn ngay lúc khai báo.
			+ Cho phép mô tả thông tin ở dạng tham số để thay thế cho việc vừa khai báo và khởi tạo.
			+ Giá trị nhận vào không nhất thiết phải chính là thuộc tính của lớp đấy.

				Ví dụ: Thiết kế lớp MaTrận nhận giá trị không phải là thuộc tính.

				public class MaTran {

					// Thuộc tính của lớp
					private int[][] maTran;

					// Hàm khởi tạo, nhưng tham số đầu vào
					// không phải là thuộc tính của lớp
					public MaTran(int soDongThucTe, int soCotThucTe) {
						maTran = new maTran[soDongThucTe][soCotThucTe];
					}
				}
		
		- Được phép có nhiều hàm khởi tạo (nhưng bắt buộc phải khác nhau về danh sách tham số) trong cùng một lớp và tuỳ theo những tham số được cung cấp mà hàm khởi tạo tương ứng sẽ được gọi.

		- Vẫn được gọi là hàm vì nó có xử lý: nhận dữ liệu từ bên ngoài và gán dữ liệu vào các thuộc tính của đối tượng; đưa vào bên trong hàm cả một đối tượng.

		- Mỗi lần sử dụng phễu (đưa dữ liệu vào) sẽ tương đương với việc tạo mới (đúc ra) một đối tượng mới từ lớp (với một vùng RAM riêng biệt hoàn toàn). Trong khi đó, vì hàm thông thường sử dụng trực tiếp các thuộc tính của đối tượng nên mỗi lần gọi hàm thì đều cho ra cùng một kết quả.

		- Vì chỉ có nhiệm vụ trực tiếp đưa dữ liệu vào đối tượng, nên phễu không cần có kiểu dữ liệu trả về (ví dụ: void, int, double...) - mà trả về chính đối tượng đang tương tác; nếu có kiểu trả về sẽ gây nhầm lẫn với những phương thức của đối tượng.

		- Không được phép khai báo tĩnh (static).
			+ Việc khai báo tĩnh (static) sẽ cho phép sử dụng trực tiếp thông qua tên lớp mà không cần tạo đối tượng bằng từ khoá new().
			+ Nhưng phễu là đồ sử dụng riêng cho từng đối tượng (giúp tạo ra đối tượng, mỗi đối tượng sẽ có một vùng RAM riêng biệt), không phải đồ sử dụng chung (người này tác động, người kia cũng bị ảnh hưởng theo).

		-> Hàm đặc biệt để cấp phát vùng nhớ và tạo dựng ra được một đối tượng trong tương lai (có thể tận dụng thêm để gán dữ liệu).

		* Cú pháp:

			phạm-vi-truy-cập TênLớp(danh-sách-tham-số) {
				// Gán giá trị nhận được từ đối số truyền vào hàm
				// đưa vào trong thuộc tính bằng toán tử gán "="
				// (Từ khoá "this" để tránh việc bối rối
				//  khi đặt trùng tên biến tham số với tên thuộc tính)
				this.thuộcTính = giáTrịTrongĐốiSố;
			}

			Ví dụ: Hàm khởi tạo cho lớp SinhViên.

				public Student(String id, String name, int yob, double gpa) {
					this.id = id;
					this.name = name;
					this.yob = yob;
					this.gpa = gpa;
				}

----------------------------------------

	* Phương thức khởi tạo mặc định (Default Constructor / Empty Contructor): là phương thức trùng tên với tên lớp, có thể chủ động tạo hoặc để trình biên dịch tự động tạo ra nếu trước đó chưa có bất kì hàm tạo nào.
		* Default Constructor: Không cần thiết kế mà vẫn ngầm có.
		* Empty Contructor: Tự thiết kế, nhưng không có gì bên trong.

		- Vì nguyên tắc một lớp bắt buộc phải có phễu để đúc đối tượng.
			+ Hàm khởi tạo mặc định sẽ tự động tạo ra, nếu trước đó chưa có hàm khởi tạo nào được thiết kế bên trong lớp.
			+ Sau khi đã thiết kế hàm khởi tạo có tham số, vẫn được phép có thêm hàm khởi tạo không tham số nhờ có kỹ thuật nạp chồng hàm, nhưng phải tự thiết kế chứ không còn có sẵn nữa.

			(Kể cả lớp trừu tượng và Interface cũng sẽ có phương thức khởi tạo không tham số nếu sử dụng lớp nặc danh để tạo đối tượng mới.)

		- Đây là một hàm void() - không vào, không ra. Mặc dù nguyên tắc của phễu là để đổ dữ liệu vào, nhưng nếu không có biến / thuộc tính nào cần đổ dữ liệu, thì vẫn phải có phễu cho "đẹp đội hình".

		- Giống như việc một khuôn sau khi đúc thành công, trước khi đổ vật liệu vào để tạo ra nhiều sản phẩm mới thì bên trong chắc chắn sẽ phải chứa không khí. Lúc này, ta có thể xem không khí như một đối tượng, vì nó cũng lắp đầy khuôn rỗng bằng "chất liệu vô thưởng vô phạt" của riêng mình.
			(Tưởng khuôn rỗng, nhưng hoá ra lại có không khí bên trong.)
	
		- Thường là một hàm tạo rỗng - không tham số (Nullary Constructor / 0-argument Constructor), không có tham số truyền vào, được sử dụng để cấp phát vùng nhớ và tận dụng nó để gán sẵn dữ liệu, tránh gặp giá trị rác.
			+ Khi tạo mới đối tượng, một vùng nhớ sẽ được cấp phát, nhưng chưa có chứa bất kì giá trị cụ thể nào hoặc đang chứa giá trị rác.
			+ Vì vậy, để gán giá trị song song với việc khởi tạo, tránh phải phải thiết kế nhiều phương thức chỉ để gán giá trị (mỗi thuộc tính sẽ phải có một phương thức), ta sử dụng hàm khởi tạo không tham số.
			+ Lúc này, khi gọi hàm khởi tạo không tham số, những thuộc tính của đối tượng sẽ được gán giá trị mặc định.

		- Ngoài ra, hàm khởi tạo không tham số còn giúp ích trong việc kế thừa.
			+ Khi lớp Con được tạo ra từ lớp Cha, hàm khởi tạo mặc định sẽ được gọi tự động để khởi tạo các thuộc tính của lớp con.
			+ Giúp lớp Con luôn có Sẵn một vùng RAM từ lớp Cha.

		-> Phương thức trùng tên với tên lớp, sử dụng để khởi tạo các giá trị mặc định.

		Ví dụ: Để gán các giá trị cho đối tượng (hình tròn).

			// Cách 1: gán thủ công thông qua phương thức
			//	   khi không có phương thức khởi tạo
			Circle c = new Circle();
			c.setHoanhDoX(0);	// Gọi phương thức để gán giá trị cho hoành độ
			c.setTungDoY(0);	// Gọi phương thức để gán giá trị cho tung độ
			c.setBanKinhR(0);	// Gọi phương thức để gán giá trị cho bán kính


			// Cách 2: tự định nghĩa phương thức khởi tạo không tham số
			//	   để gán toàn bộ giá trị = 0

			// Trong Lớp Circle()
			public class Circle {

				// Hàm khởi tạo không tham số
				public Circle() {
					hoanhDoX = tungDoY = banKinhR = 0;
				}

				// Hàm khởi tạo có tham số
				public Circle(double x, double y, double r) {
					this.hoanhDoX = x;
					this.tungDoY = y;
					this.banKinhR = r;
				}
			}

			// Trong main()
			Circle c = new Circle();

------------------------------------------------------------

	[PHƯƠNG THỨC TRUY CẬP & BIẾN ĐỔI - GETTER() & SETTER()]

	Khi một đối tượng được tạo ra, mặc định sẽ có các thông tin nhờ có phễu, nhưng vì sự quý giá của thông tin mà chúng thường sẽ được giấu đi nhờ vào phạm vi truy cập.
		- Đối với những thông tin nào không quá bí mật, đối tượng có thể cho phép truy cập thông qua phương thức: getter().
		- Đối với những thông tin không hài lòng, đối tượng có thể cho phép chỉnh sửa (nhưng trong tầm kiểm soát) thông qua phương thức: setter().

	* Phương thức getter() & setter(): Những phương thức giúp bên ngoài có thể tương tác với vùng dữ liệu (thuộc tính) ở bên trong lớp, nhưng vẫn ở trong tầm kiểm soát.

		Ví dụ: sau khi đã có được một đối tượng

			- Vì có tên đẹp và ý nghĩa nên sẽ sẵn sàng cho cả thế giới biết, miễn là chịu hỏi.
				-> Công khai thông tin, nhưng phải hỏi thì mới nói.

			- Cảm thấy chưa hài lòng về thuộc tính nên đã chỉnh sửa thêm.
				-> Đi phẫu thuật thẩm mỹ, nhuôm tóc và xăm thêm cho ngầu.

		* Cú pháp getter():
			<phạm-vi-truy-cập> <kiểu-dữ-liệu-trả-về> <tênThuộcTínhKèmTừKhoá>()

				Ví dụ: cho phép truy cập vào thuộc tính tên.

					// Khi hàm được gọi, thông qua câu lệnh return,
					// giá trị trả về của hàm
					// sẽ chính là giá trị nằm trong thuộc tính
					// của đối tượng
					public String getName() {
						return name;
					}

		* Cú pháp setter():
			<phạm-vi-truy-cập> <kiểu-dữ-liệu-trả-về> <tênThuộcTínhKèmTừKhoá>(<danh-sách-tham-số-để-thay-đổi-có-cùng-kiểu-dữ-liệu-với-thuộc-tính>)

				Ví dụ: cho phép thay đổi thông tin của thuộc tính tên.

					// Khi hàm được gọi, thông qua toán tử gán '=',
					// đối số đưa vào hàm
					// sẽ được gán cho chính thuộc tính của đối tượng
					// (Đổ dữ liệu mới vào khuôn - Gán giá trị mới)
					public void setName(String newName) {

						// Có thể thực hiện các kiểm tra dữ liệu
						// trước khi tiến hành gán giá trị
						this.name = newName;
					}

		* Lưu ý: Cũng giống như những phương thức khác, tên của các phương thức getter() và setter() có thể đặt tuỳ ý, nhưng thường sẽ tuân theo quy tắc để tránh rắc rối:
			- Đối với phương thức để thay đổi thông tin thường sẽ bắt đầu bằng "set".
			- Đối với phương thức chỉ để lấy thông tin...
				+ Thường sẽ bắt đầu bằng "is" đối với các kiểu dữ liệu luận lý (boolean).
				+ Thường sẽ bắt đầu bằng "get" đối với các kiểu dữ liệu còn lại.

----------------------------------------

	* Mã soạn sẵn / Mẫu điền (Boilerplate code): Những đoạn code được lặp lại ở nhiều nơi mà lại ít hoặc không có sự thay đổi nào.

		- Các phương thức khởi tạo, toString(), getter() và setter()... thường được xem là các mã soạn sẵn.

		- Mặc dù sẽ thay đổi từ lớp này sang lớp khác, nhưng cấu trúc thì vẫn theo một khuôn mẫu, và có thể được tạo tự động thay vì phải gõ thủ công.
			+ Ngoài ra, ta có thể sử dụng thư viện (nhóm lớp) "Lombok" và khai báo (import) vào trong chương trình.
			+ Thư viện này sẽ giúp ẩn đi những đoạn mã soạn sẵn khi lập trình bằng cách khai báo theo một dạng cú pháp đặc biệt bắt đầu từ kí hiệu @.
			+ Nhưng sau cùng, máy ảo Java sẽ tự động phát sinh mã soạn sẵn trở lại khi biên dịch chương trình.

--------------------------------------------------------------------------------

[KHAI THÁC THÔNG TIN CỦA ĐỐI TƯỢNG]

Khi đã có thông tin và được chứa trong thuộc tính (phễu đã đổ thông tin vào), sẽ có nhu cầu lấy thông tin ấy để đem đi sử dụng ở nhiều nơi.

Cách phối hợp giữa hàm và biến ở bên Java sẽ có khác biệt so với bên C.

* Cách gọi/sử dụng/truy xuất đến các thuộc tính của đối tượng: vì đa số các thông tin của đối tượng đều nằm ở "chế độ riêng tư" để đảm bảo an toàn, nên chỉ có thể truy xuất đến các thông tin của đối tượng bằng các phương thức getter() & setter() (truy xuất có kiểm soát). Nếu chạm được trực tiếp vào thuộc tính đồng nghĩa với việc sử dụng getter() và setter(). 

	- Nếu có một thuộc tính nào đó của đối tượng được công khai (public) một cách trực tiếp, ta có thể truy cập theo cú pháp:
		<tênĐốiTượng>.<tênThuộcTính>;

	- Tuy nhiên, mọi dòng được viết ra trong code đều phải là một câu lệnh (có xử lý), nên nếu sử dụng cú pháp trực tiếp như trên thì sẽ bị báo lỗi. Vì vậy, phải tìm cách biến nó thành một câu lệnh, chẳng hạn như thông qua việc gán lại giá trị cho một biến trung gian, in ra bằng câu lệnh System.out.println(), thay đổi giá trị mới...

		Ví dụ:
			// BÁO LỖI vì đây không được xem là câu lệnh
			an.name;

			// Sử dụng biến trung gian để nhập giá trị trả về của thuộc tính
			 String s = an.name;

			// Sử dụng câu lệnh System.out.println() để in giá trị ra
			System.out.println("An's name (directly): " + an.name);

			// Gán giá trị mới cho biến
			an.name = "EM HONG THÍCH HỌC BÀI";

==========================================================================================

[LỚP TRONG LẬP TRÌNH - CLASS]

Khi nhiều người cùng chung chí hướng thành lập nên một tổ chức, trong tổ chức ấy sẽ có nhiều trạng thái, đặc điểm và hoạt động.

* Nhóm/Loại (Class): những đối tượng cụ thể nào đó sau khi đã được rút bớt thông tin, lựa ra những điểm tương đồng về đặc điểm và hành vi, sau đó sẽ được gom vào cùng một nhóm dựa theo một tiêu chí nào đó (để khác biệt với những nhóm khác - sự phân nhóm đối tượng).

	- Là khuôn mẫu/biểu mẫu (thông tin đặc trưng, đại diện) để sử dụng chung cho một nhóm các đối tượng, tổng quát hoá các đặc điểm (chỉ giữ lại tên gọi và để trống giá trị) để khi cần có một đối tượng mới thì chỉ việc "điền vào chỗ trống" - trám vào.

	- Cho phép liệt kê ra những gì chung nhất của các đối tượng rồi gom lại thành một nhóm, để sau đó lại đúc ra nhiều đối tượng khác nhau nhưng đều thuộc về cùng một nhóm.

	- Giống như một dây chuyển sản xuất hàng loạt để nhanh chóng ra được những sản phẩm cùng loại.

	-> Tên gọi chung, đại diện một nhóm các đối tượng có nhiều điểm tương đồng.
		(Khuôn mẫu để đúc/nhân bản ra thêm nhiều đối tượng có cùng đặc điểm và hành vi.)

		=> Công thức tổng quát để giải quyết cho một lớp các bài toán.

	- Vì dữ liệu "thiên bẩm" đã không có quy tắc, nên để tiện cho việc lưu trữ và xử lý, cần phải chắt lọc ra những dữ liệu tương đồng để gom thành một nhóm.

	- Một lớp có thể tạm hiểu là một thư viện, được sử dụng để phục vụ công việc hoặc thậm chí là kế thừa để tạo thành một lớp tốt hơn và đúng nhu cầu hơn. Vì vậy, cần quan tâm đến lớp đấy phải có những thông tin gì, cung cấp những phương thức gì.

	- Cũng vì mục đích để nơi khác sử dụng mà một lớp thường có phạm vi truy cập là public hoặc không khai báo (sẽ sử dụng mặc định là default - chỉ cho phép truy cập trong cùng gói).

	- Toàn bộ mã nguồn phải được viết trong lớp, vì nếu viết bên ngoài thì sẽ tương đương với việc "khuôn bị thủng".

Trong Java, một tập tin *.java có thể có nhiều lớp bên trong (ngang hàng nhau) thay vì mỗi lớp có một tập tin độc lập.
	- Được sử dụng khi giữa các lớp có mối liên quan chặt chẽ, phụ thuộc lẫn nhau và chia sẻ cùng một mục đích hoặc chức năng.
	- Nhưng chỉ có duy nhất lớp cùng tên với tên tập tin mới được phép có phạm vi truy cập là public.
		+ Những lớp còn lại tuy không được khai báo phạm vi truy cập, nhưng vẫn sẽ được ngầm hiểu là default (chỉ được truy cập từ các lớp trong cùng gói).
		+ Vì vậy, nếu muốn truy cập vào các lớp đó từ bên ngoài gói, bắt buộc phải đặt các lớp đó vào các tệp tin riêng biệt có tên khác với tên lớp.
	- Tuy để nhiều lớp trong cùng một tập tin, nhưng khi biên dịch sẽ cho ra nhiều tập tin *.class độc lập.

--------------------------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Lớp là tên goi chung cho một nhóm các đối tượng có cùng đặc điểm,	│
│	là khuôn mẫu "rỗng ruột" để tạo ra nhiều đối tượng có cùng đặc điểm	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Lớp là sự kết hợp giữa vùng dữ liệu (thuộc tính) & hàm (phương thức)	│
│	để tạo ra một gói/thùng (package) hoàn chỉnh,				│
│	giúp bao bọc (encap) và có được một sản phẩm hoàn chỉnh nhờ lắp ghép	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

	[LỚP TRONG - INNER CLASS]

Java cho phép định nghĩa / thiết kế một lớp nằm bên trong một lớp khác.
	- Lớp bên trong sẽ được gọi là Inner Class và lớp bên ngoài sẽ được gọi là Outer Class.
	- Lớp bên trong sẽ trở thành thành viên (member) của lớp bên ngoài, có thể truy xuất đến những thuộc tính và phương thức của lớp bên ngoài (chứa nó) mà không cần quan tâm đến phạm vi truy cập.
	- Thông thường, lớp bên trong sẽ có phạm vi truy cập là private với mục đích hỗ trợ cho lớp bên ngoài, không phải để cho những lớp khác sử dụng.
		+ Nhưng nếu lớp bên trong sẽ có phạm vi truy cập là public, để truy cập được lớp này, ta sẽ sử dụng tên của lớp bên ngoài và dấu chấm (giống như cách để lấy thuộc tính và phương thức).

	Ví dụ: Lớp lồng trong lớp.

		public class OuterClass {
			private int properties1;
			private double properties2;

			public void method() {...}

			// Lớp bên trong
			// được phép truy cập vào thuộc tính và phương thức
			// của lớp bên ngoài
			class InnerClass {...}
		}

--------------------------------------------------------------------------------

	[VÙNG NEW: VÙNG RAM TRÊN HEAP]

	new ≈ malloc() & calloc()

* new: toán tử new() sẽ nhân bản khuôn và chừa chỗ để đưa vật liệu vào (thông qua phễu).

	- Ban đầu, khuôn sẽ được nằm riêng tại một vùng được gọi là Method Area, đến khi gặp toán tử new() thì khuôn sẽ được nhân bản sang một vùng khác được gọi là Heap Segment (chỉ nhân bản khuôn, khuôn gốc vẫn không bị ảnh hưởng và vẫn giữa nguyên vị trí trong Method Area).

	- Cứ mỗi lần sử dụng toán tử new() thì sẽ có riêng một bản sao (rỗng ruột) của khuôn trong vùng nhớ Heap và trả về địa chỉ đầu tiên (toạ độ) của vùng RAM.
	
	- Vì vậy, không giống như biến thông thường (khi tại một thời điểm chỉ lưu được một giá trị), toán tử new() cho phép tại một thời điểm có thể lưu được nhiều giá trị.
		+ Đó là nhờ vào việc tạo ra những bản sao của khuôn, sau đó mới đổ dữ liệu vào bản sao này của khuôn, chứ không chỉnh sửa trực tiếp trên khuôn gốc.
		+ Dữ liệu đổ vào sẽ có thể đa dạng về kiểu dữ liệu, giúp biến tại một thời điểm có thể lưu được rất nhiều giá trị.

	- Sau khi đã có vùng nhớ trên Heap, một biến đối tượng (biến con trỏ) riêng biệt - tên định danh (được khai báo và khởi tạo trong hàm main())...
		+ Sẽ nằm trong Stack để quản lý vùng Heap của riêng bản sao này bằng cách tham chiếu đến / lưu địa chỉ vùng nhớ.
		+ Cho phép lấy dữ liệu trong vùng nhớ này thông qua dấu chấm (giống như một người sếp - cần dùng ai thì "chấm" người đó), miễn là được phạm vi truy cập có cho phép.
		+ Vì chỉ đơn giản là nắm giữ toạ độ của đối tượng, nên biến có quyền thay đổi / trỏ sang một toạ độ mới.

	- Sau khi đã có đầy đủ thông tin thì sẽ được gọi là đối tượng.
		+ Một đối tượng hoàn chỉnh có thể sử dụng chấm để lấy ra được những thông tin về đặc điểm hoặc để yêu cầu thực thi những hành vi đã được thiết kế sẵn.
		+ Dấu chấm "." trên biến đối tượng (biến con trỏ) được hiểu là đi theo toạ độ vùng RAM để lấy thông tin.

		-> Có toạ độ vùng RAM là tương đương với có đối tượng để chấm.

	- Nếu chỉ sử dụng toán tử new() mà không đưa dữ liệu vào cho khuôn thì sẽ chưa thể tạo thành đối tượng, đối tượng chỉ thật sự được tạo ra sau khi đã có đầy đủ thông tin. Tuy mọi đối tượng trong cùng một lớp đều có chung một khuôn gốc, nhưng khi đúc thì dữ liệu lại được đổ vào một khuôn riêng - bản sao hoàn hảo của khuôn thuỷ tổ, nên việc thay đổi trên đối tượng này sẽ không làm ảnh hưởng đến những đối tượng khác (trừ vùng static).

	- Nhưng đối với những thuộc tính và phương thức static (thuộc tính và phương thức tĩnh), toán tử new() chỉ được tạo ra duy nhất một vùng RAM - được tạo ra khi một lớp bắt đầu được nạp. Từ đó trở đi, những đối tượng được tạo ra sẽ sử dụng chung vùng RAM với đối tượng đầu tiên được tạo ra.

	-> Có new là có một vùng nhớ mới trong Heap (không đụng hàng), sau đó gọi phễu để tạo ra một đối tượng mới và trả về toạ độ vùng RAM.
		(tênBiếnĐốiTượng <--- Gán --- Toạ độ / Địa chỉ vùng RAM ≈ Đối Tượng)

=> Tóm tắt toán tử new(): một bước yêu, vạn dặm đau - một lần new, một vùng RAM (độc lập).

	01. Tạo mới một cái khuôn rỗng (nhân bản một vùng nhớ trong RAM) để chuẩn bị đưa nguyên vật liệu từ phễu vào và tiến hành đúc đối tượng mới.
		-> Nhân bản khuôn rỗng ra một vùng RAM riêng.

	02. Sử dụng phễu để đổ đầy đủ thông tin vào khuôn rỗng, sau khi đã có đầy đủ thông tin thì sẽ được gọi là đối tượng.
		-> Rót dữ liệu vào khuôn rỗng và tạo đối tượng.

	03. Chốt toạ độ địa chỉ của vùng new ("toạ độ khai sinh"), đưa toạ độ này cho biến đối tượng (object variable / reference variable - "toạ độ nghệ danh") để nhờ giữ giùm.
		-> Ghi nhớ lại toạ độ của đối tượng.

		Ví dụ: khai báo một sinh viên.

			Student sinhVien1 = new Student("185123456", "AN NGUYỄN", 2000, 6.9);
				|_______|   |______________________________________________|
				    |						|
				Biến con trỏ	   Nhờ biến con tỏ	Tương đương với toạ độ 
				để lưu toạ độ <------------------------ (địa chỉ vùng RAM)
						   giữ giùm toạ độ

			// Khi biến đối tượng (biến con trỏ) mà chấm
			// sẽ đồng nghĩa với toạ độ + chấm,
			// vì biến lúc này đang lưu toạ độ do new gửi sang
			//	-> new mới là nơi thật sự lưu giữ toạ độ

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Có new() là sẽ có một vùng nhớ mới (riêng biệt)	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Có toạ độ vùng RAM (đối tượng) là có thể chấm	│
│	để gọi thuộc tính và phương thức của đối tượng	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

* Lưu ý: đừng nhầm lẫn giữa các khái niệm về new, dù cả 2 đều có cùng ý nghĩa là xin cấp phát một vùng RAM trong Heap để chứa dữ liệu. Có new là có một vùng nhớ mới.

	new(): gọi phễu của khuôn để đúc đối tượng. Mỗi đối tượng được đúc ra sẽ có cho riêng mình một vùng nhớ.

		Ví dụ:
			// Gọi phễu để đúc một đối tượng sinhViên
			Student an = new Student("185123456", "AN NGUYỄN", 2000, 6.9);

	new[]: xin cấp phát một số lượng phần tử cho biến đơn giản bằng kỹ thuật mảng động (dynamic array), áp dụng cho cả mảng đơn giản và phức tạp.
		- Đi kèm theo sau từ khoá new là...
			+ Mảng đơn giản: Một kiểu dữ liệu, nên kí tự đầu tiên của tên kiểu dữ liệu sẽ được viết thường.
			+ Mảng phức tạp: Một lớp, nên kí tự đầu tiên của tên lớp sẽ được viết in hoa chữ cái đầu.
		- Sử dụng cặp dấu ngoặc vuông [] thay vì ngoặc tròn (), vì đây là tập hợp / danh sách gồm nhiều biến khác nhau, chứ không phải phễu để đổ dữ liệu.
		- Cũng giống như việc tạo một đối tượng mới bằng new(), nhưng vùng RAM được cấp phát cho mảng sẽ nhiều hơn một chút so với những gì đã được khai báo.

		Ví dụ:
			// Mảng đơn giản:
			// Xin cấp phát cùng lúc 365 phần tử là biến số thực
			double arr[] = new double[365];
			arr[0] = 5;
			arr[1] = 10;

			// Mảng phức tạp:
			// Xin cấp phát cùng lúc 50 phần tử là đối tượng sinh viên
			Student s[] = new Student[50];
			s[0] = new Student("185123456", "AN NGUYỄN", 2000, 5.6);
			s[1] = new Student("185654321", "BÌNH LÊ", 2000, 6.5);

	(Từng phần tử trong new[] sẽ trỏ đến toạ độ vùng nhớ của new().)

------------------------------------------------------------

[SỰ NẶC DANH / KHUYẾT DANH / VÔ DANH - ANONYMOUS]

	* Lưu ý: Nặc danh nghĩa là có tên nhưng được giấu đi, chứ không phải là không có tên.

Giống như việc một bạn thú cưng được sinh ra đời.

	- Nếu được chủ nhận nuôi thì trên cổ sẽ có một chiếc dòng gắn tên của chúng.
		+ Người chủ có thể sử dụng tên trên chiếc vòng để gọi và yêu cầu thú cưng của mình làm bất cứ trò gì.
		+ Việc sinh tồn không còn là trách nhiệm của chúng.
		+ Không phải đối mặt với đội bắt chó, mèo thả rông.

	- Nếu không có ai nhận nuôi thì sẽ được gọi là vô chủ và không được đặt tên.
		+ Cũng vẫn là thú cưng, nhưng có điều không ai có thể yêu cầu chúng làm trò gì.
		+ Không ai có thể biết được tình trạng sinh tồn sau này của chúng.
		+ Có nguy cơ rất cao phải đối mặt với đội bắt chó, mèo thả rông.

--------------------

* Đối tượng nặc danh (Anonymous Object): Là những đối tượng được tạo ra mà không cần tên (nghệ danh) để tham chiếu đến.
	- Có thể thấy, new() sẽ trả về toạ độ và nó chỉ đơn giản là nhờ biến đối tượng (biến con trỏ) giữ giùm toạ độ này.
	- Vì vậy, nếu biến đối tượng (toạ độ nghệ danh) còn chấm được để gọi thuộc tính và phương thức của một đối tượng, thì chắc chắn new() (toạ độ khai sinh) cũng sẽ làm được điều tương tự.
	-> Gọi thuộc tính và phương thức trực tiếp thông qua "toạ độ khai sinh" - new(), mà không cần đến biến đối tượng (biến con trỏ).

	* Cú pháp thường thấy: sử dụng tên nghệ danh.
		<biếnĐốiTượng>.<thuộcTính>
		<biếnĐốiTượng>.<phươngThức>

	* Cú pháp đặc biệt: không cần tên nghệ danh.
		<toạ-độ-vùng-RAM>.<thuộcTính>
		<toạ-độ-vùng-RAM>.<phươngThức>

	* Tác dụng phụ:
		+ Sau màn xuất hiện hoành tráng, nơi cánh gà - sau ánh hào quang, biến nặc danh này sẽ ngay lập tức bị bộ thu gom rác (Garbage Collector) dọn đi mất, vì không có biến con trỏ (trong Stack) để trỏ đến.
		+ Vì vậy, biến nặc danh sẽ không thể thay đổi thông tin của đối tượng, nếu muốn thay đổi thì chỉ còn cách nhờ đến biến đối tượng.
		-> Muốn sử dụng lại vùng new() thì vẫn cần đến một tên gọi (nghệ danh) cho đối tượng.

	Ví dụ:
		// Truyền thống - sử dụng biến đối tượng
		Student sv1 = new Student("185123456", "AN NGUYỄN", 2000, 6.9);
		sv1.showProfile();
			// Đã có biến đối tượng giữ giùm toạ độ
			// nên có an tâm và thoải mái sử dụng

		// Dân chơi - sử dụng trực tiếp toán tử new(), không thèm đặt tên
		new Student("185123456", "AN NGUYỄN", 2000, 6.9).showProfile();
			// Nhưng đây là một vùng RAM độc lập,
			// vì mỗi lần gọi là một lần new để tạo mới đối tượng,
			// nên nó không có liên hệ gì với vùng RAM sv1 ở bên trên

			// Vì vậy, nếu muốn sử dụng lại vùng new() này
			// thì bắt buộc phải gán cho một biến đối tượng

----------------------------------------

* Lớp nặc danh (Anonymous Class / Anonymous Inner Class): Là những đối tượng được tạo ra mà không cần nói rõ được tạo từ một lớp cụ thể (có đầy đủ code) nào.
	-> Đối tượng được tạo ra từ một khuôn nặc danh.

	[Tìm hiểu cụ thể thêm ở phần kế thừa]

--------------------------------------------------------------------------------

Các kiểu dữ liệu trong Java:

----------------------------------------

	1. Kiểu dữ liệu nguyên thủy (Primitive Data Type / Non-Object).

		+ Có 8 kiểu dữ liệu nguyên thủy.

			1. byte (1 byte)

			2. short (2 byte)
			3. int (4 byte)
			4. long (8 byte)

			5. float (4 byte)
			6. double (8 byte)

			7. char (2 byte)

			8. boolean (true/false, không chỉ định rõ kích thước - hoặc 1 bit)

		+ Mỗi biến nguyên thủy (Primitive) sẽ chỉ chiếm một vùng RAM và lưu trực tiếp giá trị trong vùng RAM ấy.

----------------------------------------

	2. Kiểu dữ liệu đối tượng (Reference Data Type / Object).

		+ Có ∞ kiểu dữ liệu đối tượng.
			- String
			- Arrays
			- Classes
			- Interface
			- ...

		+ Một đối tượng (Object) sẽ tốn đến hai vùng RAM:
			1. Vùng RAM chứa biến con trỏ (trong Stack).
			2. Vùng RAM chứa đối tượng (trong Heap).

------------------------------------------------------------

Tên lớp trong lập trình hướng đối tượng sẽ đóng vai trò giống như các kiểu dữ liệu nguyên thủy (Primitive Data Type) khi được sử dụng để cho biết đối tượng được tạo ra từ lớp đó sẽ thuộc loại gì. Nhưng lúc này, tên lớp lại được gọi là kiểu dữ liệu đối tượng (Object Data Type / Non-Primitive / Reference Data Type) vì đối tượng được tạo ra sẽ chứa rất nhiều thông tin bên trong.

	Ví dụ:
		// Giá trị đơn giản (Primitive value)
		int a = 10;
		 ^  ^   ^
		 |  |   |
		 |  |   ---------------- Primitive Value
		 |  |
		 |  -------------------- Primitive Variable
		 |
		 ----------------------- Primitive Data Type

		// Giá trị phức tạp (Object value)
		Dog cauVang = new Dog("Cậu Vàng", 1943, 12.0);
		 ^     ^	   ^
		 |     |	   |
		 |     |	   --------------------- Object Values
		 |     |
		 |     --------------------------------- Object Variable
		 |
		 --------------------------------------- Object Data Type

--------------------------------------------------------------------------------

* Lưu ý: khi chưa cần thấy bất kì một đối tượng cụ thể nào được đúc ra từ lớp, mà chỉ đang nằm ở mức ý niệm, nhưng nếu được bước ra từ một khuôn thì đối tượng nào cũng sẽ giống nhau, nên vẫn sẽ có thuộc tính và phương thức. Nhưng trong thực tế, để gọi được thuộc tính và phương thức thì bắt buộc phải đúc ra trước một đối tượng từ khuôn, không thể nào gọi thuộc tính và phương thức của một đối tượng mà khi nó chỉ mới đang ở mức ý niệm.
	-> Đã là một đối tượng được đúc từ khuôn thì bắt buộc phải có những thuộc tính và phương thức tương ứng, dù chưa cần phải đúc thành đối tượng cụ thể. Còn muốn thực sự sử dụng được thuộc tính và phương thức thì bắt buộc vẫn phải đúc đối tượng.

	Ví dụ 1: đã là công dân Việt Nam, dù chưa biết là công dân cụ thể nào, nhưng bắt buộc phải có
		- Thuộc tính: sốĐịnhDanh, thẻCănCướcCôngDân...
		- Phương thức: điHọc(), điLàm()...

	Ví dụ 2:
		- Khi nói về một đối tượng sinh viên, dù chưa cần biết đó là sinh viên nào, nhưng chắc chắn sinh viên đấy phải có:
			* Thuộc tính: mãSốSinhViên, điểmRènLuyện, điểmTrungBình MônHọc / HọcKỳ / KhoáHọc...
			* Phương thức: họcBài(), làmBàiTập(), làmBàiThi(), thamGiaCácHoạtĐộngSinhViên()...

		- Nhưng để biết chi tiết các giá trị của những thuộc tính và phương thức bên trên, thì ta vẫn bắt buộc phải tạo ra đối tượng.

			Student sv1 = new Student("ĐHCQ185123456", 100, 6.0);

==========================================================================================

[TỔNG KẾT VỀ LỚP VÀ ĐỐI TƯỢNG]

* Phân biệt lớp-đối tượng (Type–token distinction): Trong triết học, đây là sự khác nhau giữa việc đặt tên cho một lớp (sẽ có nhiều đối tượng) và việc đặt tên cho một đối tượng cụ thể (hiện thân / thể hiện của một lớp).
	- Lớp thường được xem là trừu tượng* và duy nhất.
	- Đối tượng là số lần mà lớp xuất hiện dưới dạng chi tiết và cụ thể.

	(*Khái niệm về trừu tượng sẽ được đề cập chi tiết trong tính trừu tượng.)

	Ví dụ: Lớp và đối tượng trong triết học.

		“A rose is a rose is a rose”
			- Gertrude Stein
			(Vẻ đẹp mang tính chủ quan và mỗi người sẽ có một cách nhìn nhận khác nhau, nhưng nếu đã đẹp thì sẽ luôn có muôn vàn cách khác nhau để thể hiện mình trong cuộc sống, có thể là vẻ đẹp từ bên ngoài hoặc bên trong, và một khi đã đẹp thì sẽ vĩnh viễn không thay đổi.)

		Có 3 lớp:
			1. Lớp chữ "a": Có 3 đối tượng.
			2. Lớp chữ "rose": Có 3 đối tượng.
			3. Lớp chữ "is": Có 2 đối tượng.

------------------------------------------------------------

Chúng ta thường có xu hướng xếp những đối tượng đa dạng vào những lớp trừu tượng.
	- Từ đó đưa ra một hình ảnh đơn giản về đối tượng dựa theo lớp mà đối tượng đó thuộc về, dù ta chưa tiếp xúc quá nhiều với đối tượng.
	- Để có được một sự phản ánh chân thật (dùng một cách thức khác để tái hiện lại đúng đắn những đặc điểm) hơn, giúp ta rút ngắn thời gian nhận thức (tiếp thu và am hiểu) và có những quyết định nhanh chóng.

	-> Có thể bị sai sót khi áp dụng cho các cá nhân cụ thể.

* Thiên kiến (Bias): Trong tâm lý học xã hội, đây là sự thiên vị (không công bằng) và thiếu khách quan (sự xem xét căn cứ vào sự thực bên ngoài) trong ý kiến.
	- Dẫn đến việc đưa ra những quyết định hoặc diễn giải sự việc nghiêng về một bên nào đó.
	- Những niềm tin này đã được củng cố từ trước đó vì bị ảnh hưởng bởi: gia đình, môi trường sống, môi trường giáo dục, nhóm xã hội, kinh nghiệm bản thân, phương tiện truyền thông đại chúng, sách vở...

Phân loại các thiên kiến liên quan đến con người:

	* Khuôn mẫu (Stereotype): Là nhận thức, niềm tin, sự kỳ vọng và định hướng (đánh đồng, rập khuôn) dành cho những người thuộc về một nhóm cụ thể.
		- Có thể là những định kiến về thuộc tính và hành vi, như một quy tắt để áp đặt cho đối tượng phải trông như thế nào và phải hành xử ra sao để đại diện cho nhóm mà họ đang thuộc về.
		- Sẵn sàng mặc định đối tượng phải có những tính chất và hành vi nào đó dựa trên nhóm mà họ đang thuộc về, dù chưa cần phải tiếp xúc, quan sát hay biết rõ về đối tượng.

		-> Thiên kiến về nhận thức (Cognitive Bias).

		Ví dụ: Các khuôn mẫu trong xã hội.
			- Những người nghệ sĩ thường sẽ rất ăn chơi.
			- Những người nước ngoài sẽ không thể nói và hiểu được tiếng Việt.
			- Những người béo phì đều lười vận động.
			- Người Đức luôn đúng giờ và cầu toàn.
			- Ở Bắc Mỹ, các sĩ quan cảnh sát sẽ ăn bánh vòng và uống cà phê.
			- Người Châu Á giỏi làm toán.
			- Những người có hình xăm sẽ hung hăng và có xu hướng bạo lực.
			- Sẽ thiếu trọn vẹn khi đã đến tuổi nhưng vẫn chưa có vợ / chồng.
			- Các khuôn mẫu về giới:
				+ Phụ nữ yếu đuối, dịu dàng.
				+ Đàn ông mạnh mẽ, quyết đoán.
				+ Nữ giới giỏi thêu thùa.
				+ Nam giới giỏi kỹ thuật.
				+ Thiên chức của phụ nữ là làm mẹ, làm vợ.
				+ Đàn ông là trụ cột gia đình.
				+ Phụ nữ giỏi việc nước, đảm việc nhà.
				+ Đàn ông xây nhà, đàn bà xây tổ ấm.

	* Định kiến (Prejudice): Ở mức cao hơn, đây là thái độ (thường không thuận lợi) được hình thành trên cơ sở của những ý kiến có sẵn, quan điểm cố định / vững chắc về đối tượng.
		- Khi chỉ mới nhìn thầy hoặc nghe thấy về đối tượng, ta sẽ có ngay những cảm xúc được định trước.
		- Những ý kiến này có từ trước cả khi nhận thức về đối tượng, xuất phát từ cách nhìn sai lệch theo khuôn mẫu thay vì lý trí (nhận thức bằng suy luận).
		- Có thể là những thông tin đã cũ và tồn tại sẵn trong môi trường sống.
		- Nhưng chỉ dừng lại ở mức suy nghĩ, không thể diễn đạt nó một cách trực tiếp vì bị kìm hãm bởi những rào cản: luật lệ, áp lực xã hội, nỗi sợ hãi bị trả thù….

		-> Thiên kiến về cảm xúc (Emotional Bias).

	* Thành kiến (Preconception): Khi những định kiến xuất hiện trong thời gian dài, do bản thân tự xây dựng thành nếp suy nghĩ cố chấp.

	* Phân biệt đối xử (Discrimination): Khi những định kiến, thành kiến được thể hiện bằng hành động, dẫn đến những sự đối xử không công bằng.

		-> Thiên kiến về hành vi (Bihavioral Bias).

		Ví dụ: Từ khuôn mẫu và định kiến dẫn đến phân biệt đối xử.
			- Khi thấy một người ăn mặc rách rưới và khuôn mặt lấm lét đi ngang qua, phản ứng rất tự nhiên của bàn tay là giữ cái balo chặt hơn.
			- Khi thấy một người da trắng, rất tự nhiên cá nhân sẽ có cảm giác yên tâm hơn khi thấy một người da đen.

----------------------------------------

Tham khảo thêm:
	- https://blog.careerly.vn/blog/pm101-product-management-cho-nguoi-moi/

--------------------------------------------------------------------------------

* Lập trình (Programming): Viết hàm để xử lý dữ liệu.

	* Hướng (Hướng về / Hướng đến): Sự chú ý đặc biệt, nhằm vào một đối tượng / mục đích nào đó.
		- Ám chỉ việc tập trung vào các đối tượng (object) khi thiết kế và cài đặt chương trình.
		- Tập trung xây dựng, tương tác và quản lý các đối tượng trong quá trình lập trình.
* Lập trình hướng đối tượng (Object Oriented Programming): Lập trình xoay quanh (tập trung vào) đối tượng.
	- Tạo ra một vùng RAM để chứa hàm xử lý dữ liệu chuyên biệt cho một đối tượng.
 	- Giống như một đấng tạo hoá, áp dụng mọi kỹ thuật với mục đích cuối cùng là phân nhóm và chế tạo ra được một khuôn mẫu với các đặc tính ban đầu và hành vi đi kèm, để cuối cùng đạt được mục tiêu "tối thượng" là có thể nhanh chóng đúc ra được những đối tượng từ khuôn.
	- Những gì liên quan đến đối tượng sẽ được gom vào trong một lớp.
		+ Hàm phải thuộc về một đối tượng (lớp) nào đó.
		+ Cho phép tận dụng lại hàm cho nhiều nơi khi cần.
		+ Chỉ hiển thị ra bên ngoài cách tương tác, che giấu đi cách xử lý bên trong.
	-> Khuôn mẫu để tạo ra những đối tượng với thuộc tính và phương thức.
		(Giúp lưu trữ thông tin của đối tượng - Tập trung cụ thể vào đối tượng.)

		=> Cách nhanh nhất để tạo ra những đối tượng.

* Tư duy / mô thức hướng đối tượng (Object Oriented Paradigm): Mang ý nghĩa rộng lớn hơn, chỉ về nhận thức với những vấn đề trong cuộc sống theo hướng đối tượng.

	Ví dụ: Công thức để tạo nên các món ăn, thức uống...

* Công nghệ hướng đối tượng (Object Oriented Technology):
	- Là một tập các...
		+ Quy tắc (trừu tượng, đóng gói, kế thừa, đa hình).
		+ Hướng dẫn để các nhà phát triển có thể hiểu cách thức vận hành và xây dựng phần mềm.
		+ Ngôn ngữ.
		+ Cơ sở dữ liệu.
		+ Các công cụ khác để hỗ trợ cho các quy tắc này (ví dụ: UML...).
		+ ...
	- Được ứng dụng trong các hệ thống phần mềm nói chung...
		+ Các hệ thống Client / Server và các hệ thống web.
		+ Các hệ thống nhúng.
		+ Các hệ thống thời gian thực.

* Bản chất của lập trình hướng đối tượng:

	Tìm và lấy thông tin chung/đặc điểm của đối tượng
		=> Đưa ra dàn khung/khuôn (kín và có kèm phễu)
			=> Đổ thông tin vào và đúc ra thêm đối tượng khác: construct()
				- Xem sản phẩm: getInfo();
				- Chỉnh sửa sản phẩm: setInfo();
				- Tương tác với sản phẩm: public void tênHàm();
							  public static void tênHàm();

=> Kỹ thuật chế tác/sản xuất hàng loạt từ một khuôn mẫu.

--------------------------------------------------------------------------------

	[VÙNG RAM ĐƯỢC CẤP CHO MỘT ỨNG DỤNG KHI ĐANG THỰC THI]

				Object - Đối tượng		cauVang
				―――――――――――――――――――――――――	―――――――――――――
				│	Cho		│   ----│ 7.000.000 │
				│―――――――――――――――――――――――│   ¦	―――――――――――――
				│ - ten: cauVang	│   ¦   Object Variable
				│ - namSinh: 2020	│   ¦
				│ - canNang: 12		│   ¦
				│―――――――――――――――――――――――│   ¦
Class - Lớp / Khuôn		│ + hamKhoiTao( , , )	│   ¦
―――――――――――――――――――――――――	│ + suaGauGau()		│   ¦
│	Cho		│	│ + hienIn4ChiTiet()	│   ¦
│―――――――――――――――――――――――│	――――――――――――――――――――――――― <--
│ - ten			│				  7.000.000
│ - namSinh		│
│ - canNang		│	    * HEAP SEGMENT *		* STACK SEGMENT *
│―――――――――――――――――――――――│
│ + hamKhoiTao( , , )	│					ngaoDa
│ + suaGauGau() 	│	―――――――――――――――――――――――――	―――――――――――――
│ + hienIn4ChiTiet()	│	│	Cho		│   ----│ 8.000.000 │
―――――――――――――――――――――――――	│―――――――――――――――――――――――│   ¦	―――――――――――――
				│ - ten: ngaoDa		│   ¦   Object Variable
				│ - namSinh: 2021	│   ¦
    * CODE SEGMENT *		│ - canNang: 8.5	│   ¦
				│―――――――――――――――――――――――│   ¦
				│ + hamKhoiTao( , , )	│   ¦
				│ + suaGauGau()		│   ¦
				│ + hienIn4ChiTiet()	│   ¦
				――――――――――――――――――――――――― <--
				Object - Đối tượng	  8.000.000

--------------------------------------------------------------------------------

	Một đối tượng sẽ có nhiều đặc điểm/thuộc tính (thông tin),
	những thông tin ấy sẽ được đưa thông qua phễu.

	Sau khi đã hoàn thiện về bản thân (có đầy đủ thuộc tính và phương thức)
	thì đối tượng có quyền công bố hoặc che giấu thông tin.

	Để truy cập được (những) thông tin công khai của đối tượng,
	ta sử dụng <tênRiêngCủaĐốiTượng> đối với thuộc tính và phương thức non-static
	và <TênLớp> đối với thuộc tính và phương thức static,
	sau đó kết hợp với tên của thuộc tính và phương thức.

--------------------------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Đối tượng là những thứ xung quanh ta và có chứa thông tin	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Lớp là khuôn (chung chung) để tạo ra một phiên bản đối tượng (cụ thể),	│
│	đối tượng được xem là một hiện thân / thể hiện (instance) của lớp	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Lập trình hướng đối tượng sẽ giúp lưu trữ những thông tin của đối tượng	│
│	vào trong máy tính để tiến hành xử lý bằng cách lập trình		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[CÔNG THỨC "NẤU" ỨNG DỤNG JAVA (CƠ BẢN) - RECIPE FOR COOKING A JAVA APP]

01. Nhận diện và mô tả được các đối tượng (ngoài đời thực) thông qua những đặc điểm / thuộc tính (chủ yếu) và hành vi / phương thức.

02. Nhận diện, tìm điểm tương đồng nổi bật và gom các đối tượng có nhiều điểm chung (về cả đặc điểm và hành vi) lại vào cùng một nhóm, sao cho một nhóm và các đối tượng bên trong này đều khác biệt so với những nhóm khác.
	- Việc phân chia nhóm được gọi là lớp (khuôn) và mỗi lớp sẽ có một tên khác nhau.
	- Việc thiết kế lớp sẽ bao gồm:
		+ Đặc điểm: biến chừa chỗ cho dữ liệu được đổ vào thông qua phễu.
		+ Hành vi: hàm xử lý tổng quát trên biến.
	- Quy định trước phạm vi truy cập cho đặc điểm và hành vi.

03. Sau khi hoàn thành việc thiết kế lớp (ở mức ý tưởng), bắt đầu tiến hành chuyển từ ý tưởng thành hiện thực và đặt những chiếc khuôn "quý giá" vào trong một ngăn tủ / kho chứa.

04. Tạo ra giàn khung (rỗng ruột) kèm phạm vi truy cập cho những đặc điểm của đối tượng, để trong tương lai có thể đổ dữ liệu vào thông qua phễu.
	- Đây dù sao cũng là những thông tin cá nhân của đối tượng, vì vậy, khuyến khích để toàn bộ đặc điểm ở chế độ riêng tư.
	- Toàn bộ thông tin bên trong đây sẽ được để trống, để bất kì ai có nhu cầu sử dụng sẽ tự đổ thông tin của mình vào thông qua phễu.
	- Được đặt ở một nơi riêng vì sự quý giá của mình, độc lập với nơi thực sự thi công - đúc đối tượng (hàm main()).

05. Tạo phương thức khởi tạo (phễu) để hứng những dữ liệu từ bên ngoài đổ vào trong giàn khung (rỗng ruột) của đặc điểm trong tương lai.
	- Mục đích là để tạo ra (đúc ra) một đối tượng mới với một vùng RAM độc lập trên Heap.
	- Có thể có nhiều phễu, tương ứng với nhiều cách đúc tượng khác nhau.
	- Phễu thường có phạm vi truy cập là công khai để mọi nơi đều có thể sử dụng.

06. Trong tương lai, khi dữ liệu được đổ vào khuôn và trong tay đã có được kha khá thông tin về đặc điểm của đối tượng.
	- Nhưng vì các đặc điểm đều đang ở chế độ riêng tư, ta phải sử dụng thêm:
		+ Phương thức getter(): Lấy ra những thông tin về đặc điểm của đối tượng.
		+ Phương thức setter(): Chỉnh sữa những thông tin về đặc điểm của đối tượng.
	- Các phương thức thường có phạm vi truy cập là công khai để mọi nơi đều có thể sử dụng.

07. Để cùng một lúc in ra được toàn bộ thông tin về đặc điểm của đối tượng theo một định dạng tuỳ thích, ta sử dụng phương thức toString().
	- Ta có thể tuỳ chỉnh định dạng hiển thị cho phương thức thông qua câu lệnh printf() và các đặc tả kiểu dữ liệu giống như trong ngôn ngữ C.
	- Dù có tuỳ chỉnh đến đâu thì tên phương thức và kiểu trả về vẫn phải cố định.

	/* Các phương thức khởi tạo, getter() & setter(), toString()...
	   đều có thể được tạo một cách tự động thông qua phím nóng trên NetBeans:
	   	| Alt + Insert > Insert Code
	   Lúc này, ta sử dụng "tên tự gọi" của đối tượng - this
	   để phân biệt tên biến trong tham số đầu vào với tên đặc điểm của đối tượng */

08. Thiết kế sẵn các phương thức - hành vi của đối tượng.
	- Được sử dụng để xử lý những dữ liệu - đặc điểm sẵn có (mặc định) hoặc vừa mới được đổ vào.
	- Phương thức sẽ gắn liền với đối tượng, thuộc tính sẽ gắn liền với phương thức.
	- Tuỳ vào nhu cầu sử dụng mà sẽ có những phạm vi truy cập tương ứng.

09. Sau khi việc chế tác khuôn đã hoàn thành (với đặc điểm được để rỗng và hành vi), đây là lúc đưa khuôn sang một nơi khác "rộng rãi" hơn để bắt đầu tiến hành đúc đối tượng.
	- Nơi thật sự được sử dụng để tiến hành / thi công đúc đối tượng từ khuôn chính là hàm main().
		+ Khai báo biến đối tượng (biến tham chiếu) - tên gọi tắt của đối tượng, kèm theo trước đó là kiểu dữ liệu thuộc lớp vừa tạo.
		+ Gọi toán tử new() để tạo một vùng nhớ mới với mục đích chứa thông tin.
		+ Gọi phễu để đổ dữ liệu vào bên trong đối tượng.
	- Nhưng trước đó, phải có thêm câu lệnh import để thông báo về sự tồn tại / đường dẫn của ngăn tủ chứa khuôn (khuôn được đặt ở một nơi riêng vì sự quý giá của mình).

10. "Ăn cơm chúa, múa tối ngày"; sếp đã "chấm" ai thì người đó phải vâng lời.
	- Sử dụng dấu chấm kèm với tên đối tượng để truy cập vào những dữ liệu bên trong của đối tượng vừa tạo.
	- Ngoài ra, ta còn có thể yêu cầu đối tượng thực hiện các hành vi (phương thức) đã được thiết kế sẵn.

11. Biên dịch chương trình và tận hưởng kết quả.
	- Toàn bộ mã nguồn trong ứng dụng (ví dụ: khuôn & các câu lệnh new(), tên đối tượng & các dấu chấm để gọi phương thức...) đều sẽ được nạp vào vùng Code Segment.
	- Câu lệnh new() sẽ nhân bản khuôn sang một vùng Heap Segment, từ đó hình thành nên một đối tượng với đầy đủ đặc điểm và hành vi.

==========================================================================================

[PHẠM VI TRUY CẬP "CHUNG" VÀ "RIÊNG": STATIC & NON-STATIC MODIFIER]

Đây cũng là một dạng phạm vi (modifier), quy định thuộc tính và phương thức sẽ nằm ở đâu trong RAM (nằm chung hay riêng, theo lớp hay theo đối tượng).

------------------------------------------------------------

Giống như việc một chủ nhà (lớp) sở hữu một căn nhà với nhiều tầng (vùng RAM chứa thuộc tính & phương thức).
	- Chủ nhà sẽ tuỳ ý quyết định tầng nào sử dụng riêng (non-static) và tầng nào sẽ cho thuê (static).
	- Chủ nhà tất nhiên sẽ thấy được toàn bộ đồ đạc trong nhà mình (non-static) và còn thấy được thêm đồ của khách thuê (static).
	- Ngược lại, tuy người đi thuê sẽ thấy được đồ đạc của riêng mình (static), nhưng lại không thấy được đồ đạc trong nhà của chủ nhà (non-static).
	- Người đi thuê mở quán để buôn bán tại đây, mọi người đều có thể đến mua (công khai để mọi người sử dụng chung), nhưng tuyệt đối không được lưu lại bất kì "chứng tích" gì lên nhà của chủ nhà (không lưu lại giá trị sau khi xử lý vô trở lại lớp).

	-> Hai thế giới riêng trong cùng một căn nhà.
		(Hai vùng RAM tách biệt trong cùng một lớp.)

------------------------------------------------------------

Khi đứng dưới góc độ chủ nhà (static) sẽ giúp ta có cái nhìn "bao quát", còn góc độ khách thuê nhà (non-static) sẽ giúp ta có cái nhìn "thiển cận".

	Ví dụ 1: Để so sánh giữa các món đồ của hai người.

		- static với góc nhìn "bao quát" sẽ phải chỉ rõ chủ nhân của đồ vật trước khi quyết định so sánh.

		- non-static với góc nhìn "thiển cận" sẽ sử dụng từ khoá this để ám chỉ đồ vật của mình và sau đó so sánh nó với người khác.

	Ví dụ 2: Áp dụng trong lập trình thực tế, tính khoảng cách giữa hai của của đường tròn.

		// * Thiết kế hàm tính khoảng cách (Distance)

		// Hàm static vì đứng ở góc độ lớp
		// nên sẽ không biết hai điểm cần tính khoảng cách là hai điểm nào,
		// vì vậy, cần phải truyền vào hai đối tượng để có thể xác định khoảng cách
		public static double Distance(Point p1, Point p2) {

			// Công thức tính khoảng cách Euclid
			return Math.sqrt((p2.tungDoY - p1.tungDoY) * (p2.tungDoY - p1.tungDoY) + (p2.hoanhDoX - p1.hoanhDoX) * (p2.hoanhDoX - p1.hoanhDoX));
		}

		// Hàm non-static đứng ở góc độ đối tượng,
		// chỉ cần sử dụng từ khoá this để nói về chính mình
		// và sau đó so sánh bản thân với một toạ độ khác
		public static double Distance(Point p) {

			// Công thức tính khoảng cách Euclid
			return Math.sqrt((this.tungDoY - p.tungDoY) * (this.tungDoY - p.tungDoY) + (this.hoanhDoX - p.hoanhDoX) * (this.hoanhDoX - p.hoanhDoX));
		}

		// * Khi sử dụng

		// Đối với phương thức static, gọi hàm thông qua tên lớp
		System.out.println(Point.Distance(p1, p2));

		// Đối với phương thức non-static, gọi hàm thông qua tên đối tượng
		System.out.println(p1.Distance(p2));

--------------------------------------------------------------------------------

	[THUỘC TÍNH & PHƯƠNG THỨC THUỘC LỚP
	 CLASS VARIABLE & CLASS METHOD / STATIC VARIABLE & STATIC METHOD]

* static: thuộc đằng cấp "chiếu trên" khi đi theo lớp, của lớp, là duy nhất và chỉ chơi với lớp (Class Level).

	- Đã có sẵn ngay khi vừa nạp chương trình lên / nạp lớp vào bộ nhớ (import), dù có thể chưa có đối tượng.
	
	- Là vùng RAM được tạo ra một lần duy nhất (trong Heap - Class Area), nằm cố định ở một nơi để tất cả các đối tượng có thể sử dụng chung.
	
	- Sau này, dù có khởi tạo thêm bao nhiêu đối tượng thì cũng chỉ có duy nhất một vùng RAM chứa thuộc tính và phương thức static.

	-> Đại diện cho những giá trị sử dụng chung của tất cả các đối tượng được tạo ra.
		(Toạ sơn quan hổ đấu - Ngồi trên núi nhìn hổ đánh nhau.)
		(Nằm yên (tĩnh) ở một nơi (vùng RAM) dù có tạo ra bao nhiêu đối tượng.)
		=> Thuộc về lớp (Class Level)- Gắn liền với lớp.

	* Vùng static (static zone): là vùng nhớ riêng biệt khác trên RAM được máy ảo Java và hệ điều hành tạo ra.
		- Vẫn thuộc vùng nhớ Heap giống như các thông tin của đối tượng.
		- Đây là nơi lưu trữ toàn bộ thuộc tính và phương thức static với mục đích sử dụng chung cho toàn bộ các đối tượng của một lớp.
		- Các thuộc tính và phương thức được gắn mác static sẽ chỉ thấy và chơi được với nhau, nhưng không thấy được bên ngoài - Ếch ngồi đáy giếng; còn bên ngoài (non-static) vẫn có thể thấy và tương tác được với vùng này.

	* Thành viên tĩnh (static member): bao gồm thuộc tính tính (static variable) và phương thức tĩnh (static method).

	- Cũng giống như phạm vi truy cập (Access Modifier) khi có liên quan đến đối tượng, từ khoá static chỉ được phép sử dụng cho thuộc tính (biến toàn cục) và phương thức của đối tượng.
		+ Tuy nhiên, static là một khái niệm khác hoàn toàn, không bị ảnh hưởng bởi phạm vi truy cập, chỉ ảnh hưởng đến việc dữ liệu được phân bố như thế nào trong RAM.
		+ Tuyệt đối không được sử dụng cho biến cục bộ (Local variable) - những biến được khai báo bên trong hàm, vì quy mô xử lý của loại biến cục bộ này chỉ thuộc về hàm chứ không hề đại diện cho một đối tượng nào.

		Ví dụ: vị trí đúng để sử dụng từ khoá static khi xây dựng một lớp Sinh viên.

			public class Student {

				// Thuộc tính static | SỬ DỤNG ĐÚNG NƠI
				private static String id;
				private static String name;

				// Phương thức static | SỬ DỤNG ĐÚNG NƠI
				public static void sayHi() {
					System.out.println("Hi, my name is " + name);

					// Biến cục bộ static | SỬ DỤNG SAI NƠI
					static int a = 185123456;

					// Biến cục bộ public / private... | SỬ DỤNG SAI NƠI
					public int a = 185123456;
				}

			}

	- Vì là đồ sử dụng chung và thuộc mức lớp, nên phải sử dụng TênLớp để truy cập.
		+ Dù biết trước đó từng thuộc về riêng (đối tượng), nhưng nay đã là của chung (lớp).
		+ Mà đối tượng sẽ thuộc lớp nào đó, nên thay vì sử dụng tên riêng (tênĐốiTượng) để tương tác thì sẽ sử dụng tên chung (TênLớp) để tương tác.
		+ Cũng không còn được phép sử dụng từ khoá "this" để nói về đối tượng nữa.

		-> Đồ sử dụng chung thì đừng cố biến nó thành của riêng.

		// Cú pháp chuẩn:

			// Cách 1: trực tiếp khai báo thêm tên lớp ở ngay tại nơi cần sử dụng
				<TênLớp>.<tênThuộcTính>
				<TênLớp>.<tênPhươngThức>
			//         (nhớ import package...<tênLớp>)

			// Cách 2: không thèm gọi tên lớp, trực tiếp tên thuộc tính hoặc phương thức
			//         (nhớ import static package..<TênLớp>.<tênPhươngThức>
			//                                        hoặc .* để lấy tất cả các hàm static)

		+ Tuy vẫn có thể sử dụng thông qua tên đối tượng, nhưng không khuyến khích. Dù cho thuộc tính và phương thức có công khai (public) thì cũng không khuyến khích truy cập thông qua tênĐốiTượng (IDE sẽ tự động ẩn thuộc tính và phương thức nếu chúng là static và hiển thị cảnh báo nếu người dùng dù biết nhưng vẫn cố tình sử dụng).
			-> Có thể lén lấy đồ sử dung chung đi lòe người không biết, nhưng không nên.

			// Cú pháp không sai, nhưng không chuẩn:
				<tênĐốiTượng>.<tênThuộcTính>
				<tênĐốiTượng>.<tênPhươngThức>

	- Nếu trong lớp có cả những thuộc tính static và non-static.
		+ Khi tạo đối tượng mới, các thuộc tính (non-static) sẽ hiển nhiên được nhân bản và chiếm một vùng nhớ trong riêng biệt RAM, mỗi đối tượng sẽ có một vùng RAM độc lập để làm việc.
		+ Còn đối với những thuộc tính static, tuy cũng sẽ có một nơi riêng biệt, nhưng chỉ được tạo ra một lần duy nhất trong một vùng đặc biệt (static zone), dù cho có bao nhiêu đối tượng khác nhau được tạo ra đi chăng nữa, cuối cùng , toàn bộ đối tượng sẽ cùng sử dụng chung vùng RAM đặc biệt này.
		-> Ai cũng nghĩ là của riêng mình, nhưng thực chất lại là của chung và không thuộc về riêng ai.

		+ Khi lớp được nạp sẽ đồng nghĩa với việc một vùng static cũng đã được tạo theo, những đối tượng đến sau sẽ chỉ việc tận dụng vùng nhớ này cho những thuộc tính và phương thức static của riêng mình. Vì vậy, có một và chỉ một vùng RAM duy nhất dành cho static trong lần đầu tiên nạp lớp, những đối tượng đến sau chỉ việc sử dụng ké mà không cần phải tạo ra thêm, giúp tiết kiệm bộ nhớ.
			-> Một người tạo, vạn người vui.

	- Các biến thực thể bây giờ sẽ giống như những biến đơn giản, khi ở một điểm chỉ lưu trữ được duy nhất một giá trị và bị ảnh hưởng bởi lần thay đổi gần nhất (vẫn có khả năng biến đổi giống như biến thông thường).
		-> Lúc này, tại một thời điểm, biến chỉ lưu được một giá trị duy nhất.

	- Thậm chí, chưa cần sử dụng, chỉ cần gọi lớp thì đã có sẵn vùng RAM đặc biệt (static zone) rồi.
		-> Luôn có một vùng RAM duy nhất để sử dụng chung cho mọi đối tượng.

	- Vì đây là biến toàn cục nên sẽ được lưu trữ ở Data Segment (???), luôn chiếm một vùng nhớ và chỉ được giải phóng khi chương trình kết thúc.

	- Phương thức static chỉ có thể tương tác với thuộc tính static, vì chúng ở cùng một khu vực (static zone).
		+ Phương thức static không thể sử dụng các thuộc tính non-static, vì ngoài kia có bao la đối tượng (với nhiều vùng thuộc tính non-static khác nhau), nên lúc này phương thức static sẽ không biết phải sử dụng thuộc tính của đối tượng nào.
		+ Đến cuối cùng, phương thức static sẽ chỉ chơi trong "ao làng" - vùng static (static zone), vì đây là nơi quen thuộc và tạo cho nó cảm giác yên tâm (biết rằng nơi này chắc chắn sẽ chỉ có duy nhất một thông tin để lấy và xử lý).
		+ Những hàm được thiết kế để độc lập thực thi trực tiếp trong main() mà không cần phải sử dụng đến tên đối tượng, đều phải đi kèm với từ khoá static (tất nhiên, đây là cách sử dụng lại tạp, nếu theo tư duy thuần hướng đối tượng, hàm main() phải thông qua tên đối tượng để gọi thuộc tính và phương thức).

		-> static chỉ chơi với static.

	- Những gì của riêng đối tượng thì tuyệt đối không được sử dụng static, vì như vậy sẽ làm sai lệch đến dữ liệu. Chỉ những thông tin gì cần sử dụng chung thì mới thiết kế là static.

		Ví dụ 1: việc sử dụng chung thông tin giống như việc sử dụng chung một suối nước trong khu vực đó.

			- Suối nước xuất hiện trước cả khi con người đến sinh sống (nghĩa là không cần con người thì suối đã tồn tại).
				+ Có nhiệm vụ cung cấp nước cho toàn bộ sinh vật trong khu vực.
				+ Trạng thái của nước khi được cung cấp là giống nhau (sinh vật này dùng, sinh vật kia thấy vơi đi), không phân biệt hay ưu tiên cho đối tượng nào.

			- Khi con người bắt đầu đến sinh sống, tuy trong nhà đã có nước máy, nhưng vẫn được quyền sử dụng thêm nước ở suối.
				+ Được phép lấy nước từ suối để đem về nhà sử dụng riêng.
				+ Cũng cho phép những nguồn nước thiên nhiên (công cộng) khác đổ vào dòng chảy của suối (static chỉ chơi với static).
				
			- Nghiêm cấm con người lấy nước trong nhà để đổ ra suối (nghiêm cấm mọi hành vi làm thay đổi nguồn nước).
				+ Vì nếu có bất kì ai "đầu độc" nguồn nước (xả nước thải) thì tất cả những người có liên quan đều sẽ bị ảnh hưởng.
				+ Nếu vẫn bất chấp thay đổi thì trạng thái của lần thay đổi cuối cùng sẽ là trạng thái mà tất cả mọi người đều có thể thấy.

			- Vì đây là suối nước sử dụng chung, nên không ai được nhận vơ là của mình.
				+ Nếu muốn nhắc đến thì không nên sử dụng tên của mình để gọi, mà nên sử dụng tên gắn liền với khu vực ấy (tên mà khi kể ra thì tất cả mọi người đều biết).
				+ Nếu muốn cho oách thì vẫn có thể nhận vơ là của mình, nhưng sẽ không được ai công nhận.

		Ví dụ 2: khi thiết kế thông tin cho một trường học.

			- Nếu thuộc tính mãSốSinhViên được thiết kế là static
				-> Mã số sinh viên của toàn bộ sinh viên sẽ giống nhau, vậy thì việc thiết kế mãSốSinhViên để phân biệt những sinh viên với nhau sẽ trở nên vô nghĩa.

			- Nếu thuộc tính tênTrường được thiết kế là static
				-> Toàn bộ sinh viên nhập học sẽ có cùng một tên trường. Lúc này lại trở nên tiện lợi, nếu vì một lý do nào đó mà nhà trường có đổi tên, thì toàn bộ thông tin về tênTrường của sinh viên cũng sẽ được cập nhật theo.
	
	- Ngoài thuộc tính tĩnh và phương thức tĩnh, còn có lớp tĩnh (Static Class).
		+ Tuy những lớp thông thường (Outer Class) sẽ không được khai báo là lớp tĩnh, nhưng những lớp được lồng bên trong (Inner Class) sẽ được phép khai báo tĩnh.
		+ Lớp này sẽ không được phép tạo mới đối tượng mà chỉ có thể sử dụng tên lớp để gọi các thuộc tính và phương thức bên trong lớp.

	- Ứng dụng static vào những tiện ích sử dụng chung (Utility / Helper / Library) ở nhiều nơi, chỉ cần một vùng RAM duy nhất.

		+ Vì là đồ sử dụng chung nên chỉ cần có duy nhất một nơi để tập kết, nếu có nhiều nơi khác nhau nhưng lại chỉ lưu trữ một thứ giống nhau thì sẽ gây lãng phí.

		+ Có thể sử dụng trực tiếp mà không cần tạo mới đối tượng, giúp tiết kiệm bộ nhớ trên RAM. Vì dù có bao nhiêu đối tượng được tạo ra thì cũng chỉ có duy nhất một vùng RAM được tạo ra - nằm ở một nơi độc lập, nên tốt nhất không cần tạo (cố tình tạo thì vẫn được).

		+ Cũng vì không cần tạo đối tượng, nên không thể lưu trữ lại kết quả xử lý. Từ đó, ta có thể tận dụng để sử dụng trong nhiều dự án khác nhau mà không cần phải thiết kế lại từ đầu.

		+ Mục đích là để cung cấp dịch vụ (Service) cho các đối tượng khác nhau, mà không cần giải giữ lại gì cho riêng mình và cũng không cần nhớ nhung gì sau khi đã xử lý (tính xong là quên luôn), vì trong trường hợp này, việc lưu trữ kết quả của một thứ sử dụng chung là vô nghĩa.

		+ Thuộc tính static chứa giá trị mà ai cũng có thể sử dụng, nên có thể kết hợp thêm với phạm vi truy cập public để có thể tương tác trực tiếp với thuộc tính static thông qua tên lớp mà không cần thông qua getter() và setter().

		+ Chỉ những thuộc tính static có giá trị sử dụng ở bên ngoài (ví dụ: THUE_GIA_TRI_GIA_TANG...) mới nên mang phạm vi truy cập là public, những thuộc tính chỉ sử dụng trong nội bộ các hàm (ví dụ: Scanner...) thì vẫn nên để phạm vi truy cập là private.

		+ Vì đã là đồ sử dụng chung và còn có phạm vi truy cập là public, đồng nghĩa với việc ai cũng có quyền truy cập và thay đổi giá trị của thuộc tính. Lúc này, có thể kết hợp thêm từ khoá final để thông báo rằng đây là hằng số và chỉ được khởi tạo giá trị song song với quá trình khai báo, những lần sau chỉ được xem chứ không được phép thay đổi giá trị.

		-> Ứng dụng cho những gì sử dụng chung, không phải của riêng đối tượng.
			(Hình thức của "Cuộc tình một đêm".)

		Ví dụ: kết hợp static + public + final

			public class MyToys {

				// Khai báo biến PI
				//
				//	- public: cho phép truy cập từ bên ngoài (ví dụ: hàm main())
				//		  mà không cần phải sử dụng getter() & setter()
				//
				//	- static: vùng nhớ sử dụng chung cho tất cả các đối tượng,
				//		  là vùng nhớ duy nhất và nằm cố định ở trong đấy,
				//		  giúp mỗi đối tượng không cần phải tạo riêng cho mình
				//		  một vùng nhớ riêng chỉ để lưu giá trị này
				//
				//	- final	: tuy cho phép bên ngoài có thể thấy và truy cập được,
				//		  nhưng lại không cho phép thay đổi giá trị
				//		  vì dù sao thì đây cũng là đồ sử dụng chung

				public static final double PI = 3.1415;
			}

(* Tham khảo thêm: https://javarevisited.blogspot.com/2011/11/static-keyword-method-variable-java.html)

------------------------------------------------------------

	Ví dụ 1: Tổng kết về static của thuộc tính và phương thức trong một lớp.

		// * Từ khoá static: sử dụng chung hay riêng.
		// * Phạm vi truy cập: được phép sử dụng trực tiếp hay không.

		// Bắt đầu đúc khuôn gia đình
		// để tạo ra những thành viên khác nhau thuộc cùng một gia đình
		public class GiaDinh {
			private static String tenNguoiMe;
			private static String tenNguoiCha;
			private String tenNguoiCon;
			public static String diaChiNhaRieng;

			// Phạm vi truy cập private của các thuộc tính:
			// tenNguoiMe, tenNguoiCha, tenNguoiCon
			// cho biết rằng đây đều là những thông tin riêng tư
			// và phải hỏi thì mới cung cấp được,
			// còn riêng thuộc tính diaChiNhaRieng
			// thì có thể thoải mái công khai để mua sắm trực tuyến
			// vì giả sử gia đình này không có ai là người nổi tiếng

			// Các thuộc tính static:
			// tenNguoiMe, tenNguoiCha, diaChiNhaRieng
			// cho biết đây đều là những thông tin sử dụng chung
			// và gắn liền với tất cả các thành viên trong gia đình,
			// nên dù có hỏi bất kì thành viên nào đi chăng nữa
			// thì đều nhận về đúng duy nhất một kết quả
			// (Vì thông tin được lấy từ một "khu vực" duy nhất)
			// Từ đó, nếu bất kì ai thay đổi những thông tin này
			// thì mọi thành viên còn lại đều sẽ biết và bị ảnh hưởng theo
			//	-> Nếu bất kì thành viên nào quyết định chuyển nhà
			//	   thì địa chỉ nhà của tất cả các thành viên còn lại
			//	   đều sẽ bị thay đổi theo,
			//	   vì ban đầu vốn dĩ chỉ có một nơi duy nhất
			//	   để lưu những thông tin này
			//	(Những thông tin chỉ có một nơi duy nhất để lưu)

			// Còn riêng thuộc tính tenNguoiCon là thuộc tính non-static,
			// vì vậy, mỗi người sẽ có một tên riêng tại một "khu vực" riêng
			// để phân biệt với những thành viên khác trong gia đình,
			// nếu có bất kì người con nào
			// quyết định thay đổi họ tên của chính mình
			// thì ít nhất cũng không làm ảnh hưởng
			// đến họ tên của những thành viên khác
			//	-> Nếu có một người con nào đó bắt đầu nổi tiếng
			//	   và quyết định thay đổi họ tên khai sinh
			//	   với mong muốn được thăng tiến hơn trong sự nghiệp
			//	   và cũng để tránh bị trùng với những nghệ sĩ khác,
			//	   thì đây đều là quyết định riêng của từng người
			//	   và chỉ ảnh hưởng đến người có nhu cầu đổi tên
			//	(Những thông tin mỗi đối tượng sẽ có một nơi riêng để lưu)
		}

		// Khởi tạo các đối tượng có chung tenNguoiMe, tenNguoiCha, diaChiNhaRieng
		// và chỉ khác nhau mỗi tenNguoiCon
		GiaDinh nguoiConDauLong = new GiaDinh("An", "Bình", "Dung", "48 Hàng Ngang");
		GiaDinh nguoiConUt = new GiaDinh("An", "Bình", "Cường", "48 Hàng Ngang");

------------------------------------------------------------

	―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
	│	Vùng static chứa những giá trị sử dụng chung cho toàn bộ đối tượng,	│
	│	được đặt cố định ở một nơi để ai cũng có thể thấy và trỏ về.		│
	│	(không thuộc về riêng ai nên ai thích cũng có thể sử dụng được,		│
	│	 nhưng nếu có thay đổi thì cả tập thể đều sẽ bị ảnh hưởng)		│
	―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

	―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
	│	Nằm cố định ở một nơi để những nơi khác có thể	│
	│	dễ dàng truy cập vào và gọi đến			│
	―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

	[THUỘC TÍNH & PHƯƠNG THỨC THUỘC ĐỐI TƯỢNG
	 INSTANCE VARIABLE & INSTANCE METHOD / NON-STATIC VARIABLE & NON-STATIC METHOD]

* non-static: thuộc đằng cấp "chiếu dưới" khi đi theo đối tượng (Object Level / Instance Level), mỗi lần tạo mới/xin cấp phát/khai báo đối tượng mới sẽ tạo ra thêm các vùng non-static khác.

	- Vì đây là vùng RAM "ăn theo" đối tượng, nên phải đợi đối tượng được tạo ra thì vùng RAM này mới có cơ hội xuất hiện.
		+ Linh hoạt theo từng đối tượng, mỗi đối tượng sẽ có riêng cho mình một vùng thông tin để tha hồ mà sử dụng.
		+ Các vùng RAM này có thể chứa cùng một thông tin, nhưng chắc chắn rằng tất cả đều là những vùng RAM độc lập nhau.

	- Đây là cách sử dụng thông thường khi phải thông qua đối tượng (phải tạo đối tượng trước) để có thể truy cập vào thuộc tính và phương thức non-static.

	-> Đại diện cho từng đối tượng riêng lẻ.
		=> Thuộc về đối tượng (Object Level / Instance Level)- Gắn liền đối tượng.

	- Những thông tin nào là của riêng đối tượng (tên, nămSinh...) thì nên để là non-static, vì sẽ rất nguy hiểm khi nhiều đối tượng khác nhau nhưng lại có cùng một thông tin.

	- Ứng dụng non-static vào những thuộc tính chỉ của riêng đối tượng, không muốn toàn bộ đối tượng "mặc đồng phục".
		-> Ứng dụng vào những "chất riêng" của đối tượng.

	- Vì static là vùng mà ai cũng có thể nhìn thấy, nên non-static vừa có thể sử dụng đồ trong vùng của riêng mình, mà cũng vừa có thể sử dụng đồ ở vùng static. Thực chất thì static cũng chỉ là một vùng được tách ra từ đối tượng non-static để sử dụng chung.
		-> Tuy đã có đồ sử dụng riêng, nhưng không ai cấm không được sử dụng đồ chung.

	- Vì non-static là đồ của riêng từng đối tượng, nên muốn sử dụng thì phải xin phép đối tượng. Đối tượng này sử dụng sẽ không làm ảnh hưởng đến những đối tượng còn lại.
		-> Đèn nhà ai, nhà nấy rạng (không hay biết và cũng không thể làm phiền nhau).

		// Cú pháp chuẩn:
			<tênĐốiTượng>.<tênThuộcTính>
			<tênĐốiTượng>.<tênPhươngThức>

--------------------------------------------------------------------------------

	[CÁCH SỬ DỤNG STATIC VÀ NON-STATIC]

Minh hoạ về cách sử dụng của static và non-static.

	Ví dụ: phương thức non-static có thể truy cập trực tiếp vào thuộc tính và phương thức static

		// Thiết kế lớp Sinh viên
		public class Student {

			// Giả sử các thông tin đều là public
			// để có thể dễ sàng sử dụng trong main()
			public static String school;
			public static String major;

			public String id;
			public String name;

			// Phương thức static chỉ được sử dụng thuộc tính static
			public static void show()
			{
				// Chỉ được sử dụng thuộc tính static
				System.out.println("static school: " + school);
			}

			// Phương thức non-static vừa có thể sử dụng thuộc tính non-static,
			// vừa có thể sử dụng thuộc tính static và gọi hàm static
			public void display()
			{
				// Gọi hàm static
				show();

				// Sử dụng thuộc tính static
				System.out.println("static major: " + major);

				// Sử dụng thuộc tính non-static
				System.out.println("id: " + id);
				System.out.println("name: " + name);
			}
		}

		// Gọi hàm main()
		public static void main(String[] args) {

			// Tạo mới đối tượng từ lớp Sinh viên
			Student sv1 = new Student(...);

			// Gọi phương thức non-static
			sv1.display();

			// Gọi phương thức static trực tiếp
			// mà không cần phải tạo đối tượng
			Student.show();

			// Tất cả những đối tượng được tạo ra từ lớp Sinh viên
			// chắc chắn sẽ thấy được thuộc tính non-static
			sv1.id = "185123456";
			sv1.name = "AN NGUYÊN";

			// Tuy không thấy được một cách trực tiếp
			// (IDE sẽ cảnh báo đây là thuộc tính static),
			// nhưng nếu biết "đi cửa sau" thì vẫn có thể sử dụng được,
			// vùng non-static vẫn có thể tương tác được với vùng static
			sv1.school = "OU";
			sv1.major = "Khoa học Máy tính";

			// Sử dụng trực tiếp tên lớp
			// (Sẽ chỉ thấy được những thuộc tính static)
			Student.school = "HCMCOU";
			Student.major = "Mạng Máy tính";

			// Vùng static sẽ không có cửa để chạm vào vùng non-static
			// (IDE sẽ thông báo lỗi rằng vùng static
			//  không thể tham chiếu đến vùng non-static)
			Student.id = "185123456";	// THÔNG BÁO LỖI
			Student.name = "AN NGUYÊN";	// THÔNG BÁO LỖI
		}

--------------------------------------------------------------------------------

[SO SÁNH VÀ TỔNG KẾT VỀ "CHUNG" VÀ "RIÊNG": STATIC & NON-STATIC]

------------------------------------------------------------

	[SO SÁNH CHUNG]

	* Bảng tổng kết:
	
	---------------------------------------------------------------------------------
	| Vị trí	|	static			|	non-static		|
	|---------------|-------------------------------|-------------------------------|
	| Lớp		| Không thể tạo đối tượng mới	| Có thể tạo đối tượng mới	|
	| (Class)	| (Tự cung để tuyệt tự)		|	“new TênLớp(...);”	|
	|---------------|-------------------------------|-------------------------------|
	| Thuộc tính	| Của lớp và sử dụng chung	| Của đối tượng và sử dụng riêng|
	| (Property)	|     “TênLớp.tênThuộcTính”	|   “tênĐốiTượng.tênThuộcTính”	|
	|---------------|-------------------------------|-------------------------------|
	| Phương thức	| Của lớp, chỉ chơi với static	| Của đối tượng, chơi với tất cả|
	| (Method)	|     “TênLớp.tênPhươngThức”	|   “tênĐốiTượng.tênPhươngThức”	|
	---------------------------------------------------------------------------------

------------------------------------------------------------

	[SO SÁNH CHI TIẾT VỀ THUỘC TÍNH & PHƯƠNG THỨC
	 CỦA LỚP VS. ĐỐI TƯỢNG]

		[THUỘC TÍNH / BIẾN - VARIABLE]

	* Sự khác nhau:

	-------------------------------------------------------------------------------------------------
	|	BIẾN THỰC THỂ (INSTANCE VARIABLE)	|	BIẾN LỚP (CLASS VARIABLE)		|
	|-----------------------------------------------|-----------------------------------------------|
	| Khai báo mà không cần ghi thêm từ khóa gì	| Khai báo kèm với từ khóa static		|
	|-----------------------------------------------|-----------------------------------------------|
	| Có liên kết (gắn liền) với đối tượng,		| Có liên kết (gắn liền) với lớp,		|
	| ràng buộc với một đối tượng bất kì		| chia sẻ chung cho tất cả đối tượng của lớp	|
	|-----------------------------------------------|-----------------------------------------------|
	| Chỉ xuất hiện khi một đối tượng được tạo ra	| Xuất hiện ngay khi thực thi chương trình	|
	|-----------------------------------------------|-----------------------------------------------|
	| Mỗi đối tượng được tạo ra từ lớp		| Mỗi đối tượng được tạo ra từ lớp		|
	| đều sẽ có riêng cho mình một biến thực thể	| đều cùng sử dụng chung duy nhất một biến lớp	|
	|-----------------------------------------------|-----------------------------------------------|
	| Biến riêng của mỗi đối tượng			| Biến riêng của mỗi lớp (chung cho đối tượng)	|
	|-----------------------------------------------|-----------------------------------------------|
	| Lưu trữ giá trị dưới dạng thuộc tính		| Lưu trữ một giá trị duy nhất sử dụng chung	|
	| tương ứng cho từng đối tượng của lớp		| dù chưa tạo đối tượng từ lớp			|
	|-----------------------------------------------|-----------------------------------------------|
	| Giá trị của các biến sẽ độc lập với nhau	| Cùng sử dụng giá trị của lần sửa đổi cuối	|
	|-----------------------------------------------|-----------------------------------------------|
	| Truy cập thông qua tên đối tượng, 		| Truy cập thông qua tên lớp, nên không cần	|
	| nên đối tượng phải được tạo ra trước		| tạo đối tượng, vì đã có khi nạp lớp		|
	|-----------------------------------------------|-----------------------------------------------|
	| Chỉ thuộc về một lớp cụ thể			| Được phép sử dụng chung giữa các lớp		|
	| chứ không thể sử dụng chung giữa các lớp	| và các lớp con				|
	|-----------------------------------------------|-----------------------------------------------|
	| Tồn tại cho đến khi đối tượng biến mất	| Tồn tại cho đến khi chương trình kết thúc	|
	-------------------------------------------------------------------------------------------------

------------------------------------------------------------

		[PHƯƠNG THỨC / HÀM - METHOD]

	* Sự khác nhau:

	-------------------------------------------------------------------------------------------------
	|		INSTANCE METHOD			|		CLASS METHOD			|
	|-----------------------------------------------|-----------------------------------------------|
	| Là phương thức thuộc về đối tượng		| Là phương thức thuộc về lớp			|
	|-----------------------------------------------|-----------------------------------------------|
	| Có thể sử dụng cả biến thực thể (non-static)	| Chỉ có thể sử dụng biến lớp (static)		|
	| và biến lớp (static)				| và các tham số được truyền vào hàm		|
	|-----------------------------------------------|-----------------------------------------------|
	| Truy cập thông qua tên đối tượng, 		| Truy cập thông qua tên lớp, nên không cần	|
	| nên đối tượng phải được tạo ra trước		| tạo đối tượng, vì đã có khi nạp lớp		|
	-------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------

Hầu hết các lớp được thiết kế sẵn sẽ là lớp static.
	- Nhưng cũng có một số lớp vừa là static, vừa là non-static (ví dụ: lớp String).
	- Hoặc cũng có lớp chỉ là non-static (ví dụ: lớp Scanner).

	1. Lớp non-static: phải tạo mới đối tượng nếu muốn sử dụng.
		-> Biết đối tượng là ai, nên có thể lưu lại kết quả xử lý.

		Ví dụ: sử dụng lớp String bằng cách tạo mới đối tượng.

			// Khởi tạo đối tượng - new() ngầm
			String name = "ThuanNH";

			// Sử dụng tên đối tượng sau khi đã khởi tạo
			name.toUpperCase();

	2. Lớp static: trực tiếp sử dụng mà không cần tạo mới đối tượng.
		-> Không biết đối tượng là ai, nên sẽ không lưu lại kết quả xử lý.

		Ví dụ: sử dụng lớp String mà không cần tạo mới đối tượng.
		
			String.format("...", ...);

--------------------------------------------------------------------------------

// Khi nào lớp, thuộc tính và phương thức nên là static?

* Thuộc tính: khi toàn bộ đối tượng đều có chung một đặc điểm.

	Ví dụ: số PI là số sử dụng chung, không thể thay đổi. Vì vậy, chỉ cần duy nhất một vùng để lưu số PI là đủ, để nhiều đối tượng cùng trỏ đến và sử dụng, không nhất thiết mỗi đối tượng phải có một thuộc tính PI riêng.

* Hàm main(): để chưa cần tạo đối tượng từ lớp thì đã có trước main() rồi, và từ hàm main() mới bắt đầu gọi những hàm khác.

	- Hệ điều hành được thiết kế sẽ chừa một nơi để khi các ứng dụng được nạp vào RAM thì sẽ có một điểm để bắt đầu thực thi.

	- CPU sẽ tìm hàm main() đầu tiên để bắt đầu xử lý, mà một ứng dụng sẽ được lưu trữ trong RAM, nên hàm main() phải cố định (tĩnh) ở một nơi để CPU có thể gặp.

* Hàm xử lý: mọi hàm muốn thực thi được thì phải được đưa vào main(), nên để một hàm bên ngoài chạy được trong main() thì bắt buộc hàm ấy cũng phải là hàm static, vì chúng cùng nằm chung trong một khu vực (static zone).

	- Khi hàm có trả về kết quả nhưng không cần lưu lại những thông tin riêng sau mỗi lần chạy.

	- Ngoài ra, việc sử dụng từ khóa static sẽ giúp ta không cần tạo mới đối tượng mà vẫn có thể sử dụng hàm thông qua tên lớp. Vì dù có tạo bao nhiêu đối tượng thì cuối cùng cũng chỉ có duy nhất một vùng, nên tốt nhất khỏi cần tạo.

		Ví dụ: sử dụng trực tiếp mà không cần phải tạo mới đối tượng.
			String.format();
			Math.sqrt();

--------------------------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│ Object Variable (Biến đối tượng): biến con trỏ, nắm địa chỉ của đối tượng trên Heap	│
│ Class Variable (Biến tĩnh): biến dùng chung, khai báo ngoài hàm kèm từ khoá static	│
│ Instance Variable (Biến toàn cục): thuộc tính của đối tượng, khai báo ngoài hàm	│
│ Local Variable (Biến cục bộ): lưu giá trị của hàm, được khai báo trong nội bộ của hàm	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

* Các cách phân loại biến:

	- Nằm bên trong hay bên ngoài hàm:
		+ Local variable: bên trong hàm.
		+ Instance variable: bên ngoài hàm.

	- Biến mang ít hay nhiều giá trị:
		+ Primitive / Single value: chỉ mang một giá trị duy nhất.
		+ Object / Complex value: mang nhiều giá trị bên trong.

	- Thuộc sở hữu riêng hay sử dụng chung:
		+ non-static: thuộc đối tượng (Object level) - riêng.
		+ static: thuộc lớp (Class level) - chung.

	- Nằm trong vùng (Segment) nào của RAM:
		+ Heap: vùng new() chứa thông tin thật sự của đối tượng.
		+ Stack: biến con trỏ, nắm giữ địa chỉ của vùng new().

------------------------------------------------------------

	* Xâu chuỗi kiến thức:

		1. Những biến được khai báo bên trong hàm (bất kể biến bình thường hay biến con trỏ) đều sẽ nằm trong Stack.
			- Nếu là giá trị đơn giản -> Đi theo biến và cũng nằm trong Stack.
			- Nếu là giá trị phức tạp -> Giá trị phức tạp sẽ nằm trong Heap, còn biến đối tượng sẽ nằm trong Stack để tham chiếu đến vùng Heap.
				+ Nếu không có từ khoá static: mỗi lần tạo mới đối tượng sẽ có một vùng Heap riêng.
				+ Nếu có từ khoá static: cho dù có tạo mới đối tượng bao nhiêu lần, thì cũng chỉ có duy nhất một vùng Heap.

		2. Những biến được khai báo trong mảng sẽ nằm trong Heap (bất kể biến đơn giản hay phức tạp).

--------------------------------------------------------------------------------

[KHỐI LỆNH KHỞI TẠO - INITIALIZER BLOCK / INITIALIZATION BLOCK]

Khi tạo một đối tượng, giá trị của thuộc tính sẽ...
	- Được gán sẵn một số giá trị mặc định trong lúc khai báo.
	- Được gán thông qua phễu để nhận giá trị từ bên ngoài.
	- Ngoài ra, còn có thể sử dụng khối lệnh khởi tạo để khởi tạo giá trị mặc định.

* Khối lệnh khởi tạo (Initializer Block / Initialization Block): Là khối lệnh được đặt trong cặp dấu ngoặc nhọn {} và được gọi trước cả những phương thức khởi tạo, nhưng đây lại không phải là hàm "chính thống".

Có hai dạng của khối lệnh khởi tạo.

------------------------------------------------------------

	1. Khối lệnh khởi tạo thông thường (Non-static Block):
		- Dùng để khởi tạo các giá trị sử dụng chung cho các phương thức khởi tạo (trong cùng một lớp), chẳng hạn như tạo sẵn một danh sách dữ liệu sinh viên.
		- Có thể được thực thi nhiều lần và được thực thi ngay trước cả khi phễu được gọi.
		- Cứ mỗi lần tạo mới đối tượng là một lần khối lệnh sẽ được gọi, không bị giới hạn số lần được gọi.

		-> Liên tục được thực thi mỗi khi tạo mới đối tượng.

		* Cú pháp:
			{
				// Các câu lệnh khởi tạo giá trị mặc định
			}

			Ví dụ 1: Khối lệnh khởi tạo trong lớp SinhViên.

				class SinhVien {

					// Thuộc tính tĩnh
					// để sử dụng chung cho tất cả các đối tượng
					private static int dem = 1;

					private int mssv;
					private String hoTen;

					// Khối lệnh khởi tạo
					// để tự động phát sinh mã số sinh viên
					{
						// Mỗi lần thêm sinh viên mới,
						// số thứ tự sẽ luôn được tăng dần
						// và được tự động gán làm mssv
						mssv = dem;
						dem++;

						// Tiện lợi hơn so với việc
						// phải viết lại đoạn lệnh nhiều lần
						// cho nhiều phễu khác nhau
					}

					// Hàm khởi tạo
					public SinhVien(String hoTen) {
						this.hoTen = hoTen;
					}
				}

			Ví dụ 2: Khởi tạo danh sách sinh viên bằng ArrayList.

				public class StudentManager {
	
					private List<Student> stuList = new ArrayList();
					
					// Khối lệnh lửng lơ
					{
						stuList.add(new Student("SE999999",
							"CHÍN NGUYỄN", 1999, 9.9, "SE"));
						stuList.add(new Student("SE888888",
							"TÁM LÊ", 1998, 8.8, "SE"));
						stuList.add(new Student("SE444444",
							"BỐN PHẠM", 2004, 4.4, "SE"));
						stuList.add(new Student("IA555555",
							"NĂM LÝ", 2005, 5.5, "IA"));
						stuList.add(new Student("IA333333",
							"BA MAI", 2003, 3.3, "IA"));
						stuList.add(new Student("GD777777",
							"BẢY VÕ", 1997, 7.7, "GD"));
						stuList.add(new Student("GD666666",
							"SÁU TRẦN", 2006, 6.6, "GD"));
						stuList.add(new Student("SS222222",
							"HAI VŨ", 2002, 2.2, "IB"));
					}
				}

------------------------------------------------------------

	2. Khối lệnh khởi tạo tĩnh (Static Block):
		- Được sử dụng để khởi tạo giá trị cho các thuộc tính tĩnh (cụ thể là khi thuộc tính có tính logic phức tạp), để sau đó những thuộc tính tĩnh này mới bắt đầu được sử dụng chung cho tất cả các đối tượng.
		- Chỉ chạy một lần duy nhất khi nạp lớp lần đầu (chưa cần có đối tượng), về sau sẽ không được gọi tiếp dù có bao nhiêu đối tượng được tạo ra đi nữa.
		- Thường được sử dụng trên các ứng dụng web và ứng dụng di động khi chỉ cần có duy nhất một đối tượng để thực thi trong suốt chương trình.

		-> Thực thi một lần duy nhất khi nạp lớp.

		* Cú pháp:
			static {
				// Các câu lệnh khởi tạo giá trị mặc định cho thuộc tính tĩnh
			}

			Ví dụ: Khối lệnh khởi tạo trong lớp SinhViên

				class SinhVien {
					private static int dem;
					private int mssv;
					private String hoTen;

					// Khối lệnh khởi tạo
					// giúp tự động phát sinh một con số ngẫu nhiên
					// để sau này sử dụng làm mã số sinh viên
					static {
						Random soNgauNhien = new Random().
						dem = (int)(soNgauNhien.nextDouble() * 100);
					}

					// Hàm khởi tạo
					public SinhVien(String hoTen) {
						this.hoTen = hoTen;
					}
				}

==========================================================================================

[CÂU CHUYỆN ĐỐI TƯỢNG - OBJECT STORIES]

--------------------------------------------------------------------------------

[1. DÙ LÀ SINH ĐÔI, VẪN LÀ HAI ĐỐI TƯỢNG ĐỘC LẬP]

Khi không sử dụng bất kì một thuộc tính định danh nào để phân biệt giữa các đối tượng hoặc có quá ít thông tin để phân biệt (và dẫn đến việc toàn bộ những thông tin đều bị trùng), ta cũng không thể kết luận được hai đối tượng đấy là một.

	Ví dụ: Kiểm tra xem khi new() trùng thông tin thì đây cùng là 1 hay vẫn là 2 vùng RAM khác nhau.

		public static void checkObjectV1() {

			// Khởi tạo giá trị (địa chỉ vùng nhớ) ban đầu
			// cho hai biến đối tượng "s1" và "s2"

			// Thông tin có thể bị trùng nhau,
			// nhưng vẫn là hai đối tượng độc lập
			// (với hai vùng RAM độc lập)
			Student s1 = new Student("SE686868", "AN NGUYỄN", 1998, 6.8);
			Student s2 = new Student("SE686868", "AN NGUYỄN", 1998, 6.8);

			// Hiển thị ra thông tin của cả hai đối tượng,
			// vì dữ liệu ban đầu được đổ vào phễu là như nhau,
			// nên thông tin hiển thị sẽ hoàn toàn giống nhau
			s1.showProfile();
			s2.showProfile();

			// Sửa thông tin của một đối tượng bất kì
			s1.setName("AI RỒI CŨNG KHÁC");

			// Hiển thị lại thông tin của cả hai đối tượng,
			// lúc này, thông tin không còn giống nhau nữa
			s1.showProfile();
			s2.showProfile();

			// Không thiết kế sẵn nhưng vẫn gọi toString()
			// để máy ảo tự động sinh ra mã băm,
			// sau đó so sánh giá trị của mã băm
			// để đảm bảo đây là hai vùng RAM độc lập
			System.out.println("Check duplication if any?");
			System.out.println(s1);
			System.out.println(s2);
		}

--------------------------------------------------------------------------------

[2. BUÔNG BỎ VỊ TRÍ - ĐÁNH MẤT TOẠ ĐỘ]

Biến đối tượng (biến con trỏ) chính là tên gọi tắt của một đối tượng thực sự được khởi tạo thông qua new().
	- Chỉ nắm giữ toạ độ, không lưu trữ cả một đối tượng.
	- Vẫn được xem như một biến.
		+ Có quyền trỏ đến một toạ độ khác.
		+ Tại một thời điểm chỉ lưu được duy nhất một giá trị.

	Ví dụ: Kiểm tra xem liệu có thể xảy ra hiện tượng mất dấu toạ độ vùng new hay không.

		public static void checkObjectV2() {

			Student s1 = new Student("SE686868", "AN NGUYỄN", 1998, 6.8);
			
			// Mất toạ độ vùng RAM "AN NGUYỄN"
			// do "có mới nới cũ"
			s1 = new Student("SE662204", "BÌNH LÊ", 2004, 0.4);
			
			// Lúc này, thông tin của đối tượng "BÌNH LÊ"
			// sẽ được hiển thị
			s1.showProfile();
			
			// Câu lệnh dọn rác phía hậu trường,
			// cụ thể là dọn rác vùng RAM "AN NGUYỄN"
			System.gc();
		}

--------------------------------------------------------------------------------

[3. NHƯỜNG EM CHO NGƯỜI TỐT HƠN - CHẲNG THỂ VƠI ĐI]

Giống như một biến đơn giản, để một biến đối tượng (biến con trỏ) có được giá trị - toạ độ vùng RAM, ta có hai cách:
	1. Sử dụng toán tử new() để xin cấp phát một vùng nhớ mới trong Heap.
	2. Sử dụng ké một vùng nhớ do người đi trước đã tạo sẵn.
	-> Bản chất cuối cùng vẫn chỉ là gán địa chỉ của đối tượng.

Có thể tưởng tượng việc cố gắng giữ lại toạ độ vùng RAM như:
	- Giống như trò chơi lô tô (bingo), khi ta sẽ sử dụng một thứ gì đó để đánh dấu lại những con số đã đi qua.
	- Giống như sách vở, quần áo, đồ chơi... trong nhà, khi anh/chị lớn không sử dụng nữa thì sẽ được truyền lại cho các em.

	Ví dụ: Quyết tâm không thể để toạ độ quý giá bị mất bằng cách sao lưu lại toạ độ của đối tượng.

		public static void checkObjectV3() {
			
			Student s1 = new Student("SE686868", "AN NGUYỄN", 1998, 6.8);

			// Để tránh tình trạng "mẹ ăn chơi thì con vô tù"
			// (ham chơi gán địa chỉ mới, làm địa chỉ cũ bị thu gom),
			// ta sử dụng kỹ thuật đặt biến tạm
			// giống như bài toán hoán đổi giá trị

			// Sao lưu lại toạ độ cũ trước khi thay đổi toạ độ mới,
			// giúp cho vùng "s1" không bị bộ thu gom rác hốt đi mất

			// Biến "x" ra tay nghĩa hiệp, lưu lại toạ độ cũ
			// để không bị mất sau khi "s1" gán toạ độ mới
			
			// Lúc này, tuy "x" cũng là biến đối tượng,
			// nhưng thay vì tự new() để có giá trị (địa chỉ)
			// thì "x" lại đi sử dụng ké đồ mà biến "s1" đã để lại
			Student x = s1;
			
			// Sau đó, "s1" bỏ AN theo BÌNH,
			// còn "x" thì vẫn là AN của ngày hôm qua
			s1 = new Student("SE662204", "BÌNH LÊ", 2004, 0.4);
			
			// Hiển thị ra thông tin của cả hai đối tượng
			// sau khi đã có nhiều biến cố xảy ra
			s1.showProfile();
			x.showProfile();
		}

--------------------------------------------------------------------------------

[4. NGƯỜI THỨ BA - TRÀ XANH]

Khi có quá nhiều biến đối tượng (biến con trỏ) cùng muốn trỏ đến một toạ độ.
	-> Nhiều chàng trỏ một nàng.

* Trường hợp 1: Nhiều tên gọi khác nhau, nhưng lại nói đến cùng một đối tượng.
	-> Nhiều biến con trỏ tham chiếu đến cùng một đối tượng.

	Ví dụ 1: tên của cùng một người.
		- Tên ở nhà: Tèo, Tí, Bơ, Xu, Cà, Na...
		- Tên bạn bè gọi: Đuỹ, Cờ-hó...
		- Tên thật: An, Bình, Cường, Dũng...
			-> Nhiều biến khác nhau, nhưng trỏ về cùng một đối tượng.

	Ví dụ 2: khi nói về thầy cô.
		- Học sinh hư: lão, gã, mụ, ả...
		- Học sinh ngoan: thầy, cô...
			-> Nhiều biến khác nhau, nhưng trỏ về cùng một đối tượng.

* Trường hợp 2: Cùng một tên gọi, nhưng lại nói đến nhiều đối tượng khác nhau.
	-> Thay đổi giá trị (toạ độ vùng RAM) của biến con trỏ.

	Ví dụ 1: khi nói về sếp.
		- Giới trẻ: Sơn Tùng M-TP.
		- Người đi làm: người đứng đầu, trả lương, đánh giá hiệu suất công việc - người lãnh đạo của các cơ quan, tổ chức.
			-> Một tên gọi, nhiều đối tượng khác nhau.

	Ví dụ 2: khi nói về tên nhân vật tên Tí.
		- Gia đình: đứa con của mình.
		- Hoạ sĩ Lê Linh: nhân vật Trạng Tí trong bộ truyện tranh Thần đồng đất Việt.
		- Nhà sản xuất Ngô Thanh Vân: cậu bé Huỳnh Hữu Khang đóng vai nhân vật Trạng Tí trong bộ phim điện ảnh Trạng Tí phiêu lưu ký.
			-> Một tên gọi, nhiều đối tượng khác nhau.

	Ví dụ: Câu chuyện hai chàng và một nàng (hai con trỏ cùng nhớ về cùng một địa chỉ).

		public static void checkObjectV4() {

			Student s1 = new Student("SE686868", "AN NGUYỄN", 1998, 6.8);

			Student s2 = s1;
				// Câu chuyện hai chàng cùng nhớ về một nàng
				// (hai con trỏ cùng nhớ về một địa chỉ)

				// Ứng dụng trong việc sắp xếp mảng,
				// những biến tạm giống như "x" được sử dụng
				// mà không cần tạo thêm vùng RAM
					-> Có thể gọi một đối tượng bằng một tên bất kì.
					   (Hay nói cách khác,
					    nhiều tên khác nhau
					    nhưng tham chiếu đến cùng một đối tượng)

			// Lúc này, tuy có hai tên gọi khác nhau
			// nhưng kết quả là như nhau
			// Nếu một trong hai "tác động vật lý"
			// thì người còn lại cũng nhận thức được
			s1.setName("Ú OÀ");

			// Kiểm tra sự thay đổi của cả hai
			// sau khi có "tác động vật lý"
			System.out.println("After 'a little violent'");
			s2.showProfile();
			s1.showProfile();
		}

--------------------------------------------------------------------------------

[5. NẶC DANH - QUAN HỆ BẮT CẦU]

Về bản chất, chỉ cần có địa chỉ toạ độ (đối tượng) là có thể chấm được. Vì vậy, ta có hai cách để lấy thông tin của một đối tượng:
	1. Sử dụng biến đối tượng (biến con trỏ): Vì đây là nơi lưu tạm địa chỉ của đối tượng.
	2. Sử dụng trực tiếp đối tượng sau khi vừa new(): Vì sau đó địa chỉ này cũng sẽ được gán cho biến con trỏ để giữ giùm, mà chỉ cần có toạ độ là có thể chấm được.

	Ví dụ: Câu chuyện về những người anh hùng nặc danh, chưa kịp biết quý danh thì đã đi mất (Anonymous Object).

		public static void checkObjectV5() {

			Student s1 = new Student("SE686868", "AN NGUYỄN", 1998, 6.8);

			// Sử dụng biến đối tượng,
			// đi vào vùng toạ độ để lấy dữ liệu
			s1.showProfile();
			
			// Hiển thị lại kết quả sau khi đã thay đổi
			// mà không cần sử dụng đến biến đối tượng
			new Student("SE686868", "AN NGUYỄN", 1998, 6.8).showProfile();
		}

--------------------------------------------------------------------------------

[6. TRẢ GIÁ TRƯỚC, MUA HÀNG SAU - NHẮN TIN TRƯỚC, CHO BIẾT GIÁ SAU]

Khi việc mua sắm trực tiếp tại các sạp của các tiểu thương trong chợ vẫn còn phổ biến, việc trả giá trước khi thật sự quyết định mua một món hàng là việc dễ dàng bắt gặp.

Đến khi việc mua sắm trực tuyến dần lên ngôi, hình thức "trả giá trước, mua hàng sau" vẫn không bị mất đi, mà chuyển sang hình thức "nhắn tin cho chủ tiệm trước, rồi mới cho biết giá".

Trong lập trình cũng vậy, ngoài việc khởi tạo sẵn giá trị cho biến ngay sau khi khai báo.
	- Ta vẫn hoàn toàn có thể khai báo biến trước rồi mới từ từ gán giá trị cho biến sau.
	- Miễn giá trị được gán vào vẫn đảm bảo trùng với kiểu dữ liệu mà biến có thể nhận.

	Ví dụ: Khai báo biến trước, rồi sau đó mới gán giá trị (bí mật sẽ được bất mí sau).

		public static void checkObjectV6() {
			
			// Khai báo biến con trỏ x, nhưng chưa trỏ đến ai
			Student s1;

			// Mãi về sau mới quyết định
			// trỏ đến toạ độ của một vùng RAM
			s1 = new Student("SE686868", "AN NGUYỄN", 1998, 6.8);

			// Thứ tự gán giá trị không quan trọng,
			// kết quả được in ra vẫn sẽ như nhau
			s1.showProfile();
		}

--------------------------------------------------------------------------------

[7. HÀM TRẢ VỀ TOẠ ĐỘ - TRẢ VỀ CON TRỎ / THAM CHIẾU ĐẾN VÙNG RAM CHỨA ĐỐI TƯỢNG]

* Tiếp tục câu chuyện hai chàng cùng nhớ về một nàng: Phiên bản cao cấp hơn.
	- Truyền thống - Bình dân: Hai biến đối tượng cùng trỏ về một toạ độ vùng RAM.
	- Hiện đại - Cao cấp: Một biến đối tượng, một tên hàm (trả về toạ độ) cùng trỏ về một toạ độ vùng RAM.

Bên cạnh việc trả về một kiểu dữ liệu quen thuộc (int, double, void....), phương thức có thể có kiểu dữ liệu trả về là một đối tượng.
	- Hay chính xác hơn là hàm sẽ trả về trả về toạ độ / địa chỉ vùng RAM của một đối tượng (đã được khởi tạo ở đâu đó).
	- Vì kết quả trả về là một toạ độ, nghĩa là sau này, ta có thể sử dụng tên hàm để chấm.
	- Giúp lưu trữ lại được toạ độ trên Heap của đối tượng bên trong hàm và đưa ra bên ngoài để sử dụng tiếp, vì thông thường, những gì nằm trong hàm sẽ thuộc vùng Stack (cụ thể là con trỏ để trỏ đến vùng Heap) và sẽ bị hệ điều hành thu hồi sau khi hàm kết thúc.
	-> Hàm trả về một đối tượng (toạ độ) chứ không còn là một giá trị đơn giản.

	Ví dụ: Đưa toạ độ từ bên trong hàm ra bên ngoài - Hàm trả về một đối tượng thay vì giá trị đơn giản.

		// Sẽ tương đương với:

		// Kiểu dữ liệu trả về | Dữ liệu trả về
		//	      Student	 x;
		//	      Student	 s1;
		//	          int	 x;
		//	          int	 f(x);

				      Trả về giá trị
				      |――――――――――――|
		public static Student checkObject7() {	// Nhận toạ độ của new (ví dụ: 6.000.000)

			// Tên hàm cũng được xem là một biến
			// vì nó trả về giá trị nhờ có câu lệnh return
			// Chỉ có điều, giá trị mà hàm trả về
			// là toạ độ của một biến đối tượng (new()) nào đó trong Heap

			// Biến x là biến cục bộ nằm trong Stack,
			// nên sẽ bị biến mất sau khi kết thúc hàm
			Student x;

			// Nhưng vùng RAM vừa mới khởi tạo lại nằm trong Heap,
			// nên sẽ không bị biến mất sau khi kết thúc hàm
			x = new Student("SE686868", "AN NGUYỄN", 1998, 6.8);

			// Biến x đang lưu toạ độ của new() (ví dụ: 6.000.000),
			// sau đó truyền toạ độ (vùng Heap) này ngược lại cho tên hàm
			return x; // Trả về toạ độ của new (ví dụ: 6.000.000)

			// Câu lệnh return siêu rút gọn
			// return new Student("SE686868", "AN NGUYỄN", 1998, 6.8);
		}

		// Hàm lúc này sẽ hứng giá trị trả về là một toạ độ của new(),
		// và vì trong hàm có câu lệnh new(),
		// nên mỗi lần hàm được gọi sẽ là một vùng RAM mới được tạo ra

		public static void main(String[] args) {

			// Khai báo biến ahihi để lưu toạ độ new()
			// được trả về từ hàm checkObject7()
			// (Kịp sử dụng một biến con trỏ khác
			//  để lưu lại toạ độ của đối tượng)
			Student ahihi = checkObject7();

			// Vì vùng new() nằm trên Heap vẫn còn,
			// nên vẫn có thể sử dụng để tương tác tiếp
			ahihi.showProfile();

			// Theo suy luận: Tạo ra biến đối tượng mới để chứa toạ độ từ hàm.
			// Student ahihi = new Student("SE686868", "AN NGUYỄN", 1998, 6.8);

			// Sẽ có tổng cộng 5 vùng RAM độc lập nhau,
			// kiểm tra bằng cách không thiết kế hàm toString()
			// để JVM in ra mã băm cho từng đối tượng
			// bằng câu lệnh System.out.println()
			ahihi.showProfile();			// 1
			System.out.println(ahihi);

			Student ahuhu = checkObject7();
			ahuhu.showProfile();			// 2
			System.out.println(ahuhu);

			checkObject7().showProfile();		// 3
			System.out.println(checkObject7());

			checkObject7().showProfile();		// 4
			System.out.println(checkObject7());

			checkObject7().showProfile();		// 5
			System.out.println(checkObject7());

			// Lúc này, mọi thay đổi thông qua biến con trỏ ahihi
			// sẽ chỉ ảnh hưởng đến đối tượng mà biến đang trỏ đến
			// (những vùng khác là độc lập nên không bị ảnh hưởng),
			// nhưng những thay đổi được thực hiện trực tiếp
			// thông qua tên hàm checkObject7() sẽ không được ghi nhận,
			// vì có liên quan đến đối tượng nặc danh

			// Được ghi nhận - Được phép sử dụng lại,
			//		   có thể sử dụng hàm showProfile()
			//		   để hiển thị ra những thay đổi
			ahihi.setName("Ahihi");
        		ahihi.showProfile();

			// Không được ghi nhận - Không được phép sử dụng lại,
			//			 vì không có biến con trỏ để lưu toạ độ,
			//			 nên không thể gọi hàm
			//			 để hiển thị ra những thay đổi
			checkObject7().setName("Ahuhu");
		}

* Lưu ý: Tránh nhầm lẫn với lớp nặc danh (Anonymous Class).

==========================================================================================

[CÁC LOẠI "NƯỚC CHẤM" TRONG LẬP TRÌNH HƯỚNG ĐỐI TƯỢNG]

* Dấu chấm: đi vào sâu bên trong đối tượng (đi vào toạ độ vùng RAM) để biết có những thuộc tính và phương thức gì (được phép thấy và sử dụng).
	-> "Anh ơi, mời anh vào team (❤️) của em xem có gì nào, có gì nào?"
		(Chi tiết bên trong của một đối tượng phức tạp.)

	* Có hai loại dấu chấm/kiểu chấm trong lập trình hướng đối tượng:

		1. Chén nước chấm chung: Dấu chấm trực tiếp mà không cần phải khởi tạo (new) đối tượng.
			- Là vùng static, mọi nơi đều sử dụng chung.
			- Đồ thuộc sở hữu của cả lớp.
			- Sử dụng thông qua tên lớp.
				-> Đồ sử dụng chung, nằm tĩnh ở một nơi và chỉ có một vùng RAM duy nhất được tạo ra.

			Ví dụ:
				String.format();
				Math.sqrt();
				Math.PI;
				System.in;

				Student.sayHello();

----------------------------------------

		2. Chén nước chấm riêng: Chỉ có thể chấm sau khi đã khởi tạo (new) đối tượng.
			- Là vùng non-static, ai có thì tự họ sử dụng.
			- Đồ thuộc sở hữu của riêng từng đối tượng.
			- Sử dụng thông qua tên riêng của từng đối tượng (biến đối tượng).
				-> Đồ sử dụng riêng, nằm lung tung và mỗi đối tượng sẽ có một vùng RAM riêng.

			Ví dụ:
				cauVang.bark();
				ngaoDa.bark();

				an.showProfile();
				binh.showProfile();

				sv1.display();

------------------------------------------------------------

Một trong những câu lệnh khai báo dài nhất trong Java:

	public static final double PI = 3.1415;

	* Trong đó:
		public: quy định những ai được phép xem và tương tác.
		static: tuy đã được phép sử dụng, nhưng sử dụng trực tiếp thông qua tên lớp hay thông qua việc tạo mới đối tượng.
		final: ngăn chặn sự thay đổi giá trị trong quá trình tương tác.

------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Có hai loại nước chấm:							│
│		1. Chén nước chấm chung: static và không cần tạo đối tượng	│
│		2. Chén nước chấm riêng: non-static và phải tạo đối tượng	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[BỘ THU GOM RÁC CỦA JAVA - GARBAGE COLLECTION / GARBAGE COLLECTOR]

* Bộ thu gom rác của Java (Garbage Collection / Garbage Collector): là một chương trình nhỏ (máy ảo Java) và chạy ngầm, chỉ hoạt động trên vùng nhớ Heap (Heap segment).

	- Vì biến đối tượng (object variable) được sử dụng để lưu toạ độ (địa chỉ vùng RAM), mà đã là biến thì chắc chắn sẽ có thể thay đổi được giá trị (không trỏ đến toạ độ vùng nhớ cũ nữa, mà sẽ trỏ đến một toạ độ mới). Nên khi có một đối tượng nào đó không còn được tham chiếu đến nữa, thì bộ thu gom rác này sẽ có nhiệm vụ hủy các đối tượng đó, để giải phóng bộ nhớ và tận dụng vùng nhớ trống đó cho những đối tượng khác.

	- Có công dụng giống như câu lệnh free() trong ngôn ngữ C lúc sử dụng vùng nhớ cấp phát động - malloc(), calloc() và realloc(). Bộ thu gom rác trong Java cũng có nhiệm vụ thu hồi và giải phóng vùng nhớ "mồ côi" trên RAM khi không có ai thèm trỏ đến.

	- Nhưng bộ thu rom rác của Java chỉ thu gom vùng nhớ được cấp phát trong Heap, còn con trỏ thật sự (mà trước đó đã từng trỏ đến vùng nhớ trong Heap) nằm trong Stack sẽ không bị ảnh hưởng gì đến việc thu gom này.

	- Có thể việc thu gom rác sẽ không lập tức diễn ra ngay mà sẽ theo định kỳ, nên nếu muốn chủ động trong việc thu hồi vùng nhớ của đối tượng đã không còn được trỏ đến, ta sử dụng câu lệnh "System.gc();" để lập tức dọn dẹp vùng nhớ.
		-> Câu lệnh "trợ tử" khi đối tượng vẫn còn đang "thoi thóp".

	-> Một chương trình nhỏ chuyên đi giám sát và thu hồi những vùng RAM không còn được trỏ đến (bị "mồ côi", dù trước đó vẫn được trỏ đến) - huỷ đối tượng trong Heap.
		(Biệt đội chuyên săn bắt chó thả rông.)

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Bộ thu dọn vùng nhớ tự động khi đối tượng bị mất con trỏ	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[LỚP / ĐỐI TƯỢNG BẤT BIẾN - KHẢ BIẾN]

Vì là kiểu dữ liệu tham chiếu nên mỗi lần sử dụng sẽ tạo ra một đối tượng từ khuôn, có đầy đủ các thuộc tính và phương thức, ta chỉ việc gọi lên và sử dụng mà không cần phải thiết kế từ đầu.

Nhưng xét về việc có cho phép thay đổi các giá trị bên trong thuộc tính của một lớp hay không, các lớp sẽ được chia làm hai loại:

	1. Khả biến / Được phép thay đổi (Mutable / Changeable / Writable): Đây là lớp mà một khi đối tượng đã được tạo ra vẫn sẽ cho phép thay đổi trực tiếp giá trị của thuộc tính.
		-> Thuộc tính của đối tượng được phép thay đổi giá trị.

	2. Bất biến / Không được phép thay đổi (Immutable / Unchangeable / Read Only): Đây là lớp mà một khi đối tượng đã được tạo ra thì không thể thay đổi giá trị của thuộc tính.
		- Mọi phương thức của lớp khi được gọi cũng sẽ chỉ trả về kết quả chứ không trực tiếp thay đổi giá trị của nơi gọi đến.
		- Những thuộc tính của lớp sẽ giống như hằng số khi giá trị (trên vùng nhớ Heap) chỉ được khởi tạo lúc ban đầu, sau đó không cho phép thay đổi giá trị của thuộc tính trong suốt quá trình sử dụng (thông tin chỉ được đúc một lần duy nhất thông qua phễu).
		- Việc thay đổi giá trị sẽ không chỉnh sửa trực tiếp trên vùng Heap chứa giá trị đó mà thực chất là tạo một vùng nhớ mới trên Heap và cho con trỏ tham chiếu đến vùng nhớ mới này.
		- Các yêu cầu khi thiết kế lớp bất biến:
			+ Tất cả các thuộc tính phải là private (từ khoá final không bắt buộc phải có, nhưng khuyến khích nên có vì nó bảo vệ tính bất biến và cải thiện hiệu suất của chương trình).
			+ Vẫn có các hàm khởi tạo để tạo đối tượng, hàm getter() để cho phép xem giá trị, nhưng lại không được thiết kế các hàm setter() hoặc những hàm trả về tham chiếu, cho phép thay đổi giá trị đã khởi tạo ban đầu.

		-> Thuộc tính của đối tượng không được phép thay đổi giá trị.
			(Khi muốn thay đổi thì bỏ vùng RAM cũ và tạo mới.)

(Tham khảo thêm: https://en.wikipedia.org/wiki/Immutable_object)

==========================================================================================

[CHUỖI - STRING]

Có bốn loại chuỗi trong Java.
	1. String: Cấp phát tĩnh giống mảng, mỗi lần new() đều sẽ tốn một vùng nhớ 
	2. StringBuffer.
	3. StringBuilder.
	4. StringTokenizer.

* Chuỗi (String) trong Java là một kiểu dữ liệu phức tạp vì gồm một dãy các kí tự Unicode (2 Byte).
	- Là một lớp bất biến (immutable), được sử dụng để thao tác với chuỗi, nhưng tốc độ sẽ chậm hơn so với lớp StringBuffer.

	- Tuy không được xem là lớp bao bọc (Wrapper Class), nhưng vẫn chứa bên trong rất nhiều kí tự (mảng kí tự) và chuyển đổi chúng thành chuỗi.
		+ Chỉ có một thuộc tính duy nhất là mảng kí tự.
		+ Vẫn có phễu để nhận dữ liệu và có thêm rất nhiều hàm khác để xử lý chuỗi.
		+ Bên cạnh hai hàm so sánh quen thuộc là equals() và compareTo(), chuỗi còn phân biệt hoa thường, nên sẽ có thêm hai hàm equalsIgnoreCase() và compareToIgnoreCase() để bỏ qua sự khác nhau giữa các kí tự hoa và thường.

	- Khi một chương trình Java hoạt động, máy ảo Java sẽ yêu cầu hệ điều hành cấp một vùng RAM cho ứng dụng.
		+ Sau khi máy ảo nhận được bộ nhớ trên RAM, nó sẽ chia bộ nhớ ra làm hai thành phần là Stack và Heap.
		+ Nếu trong chương trình có khai báo một chuỗi bằng lớp String, biến đối tượng (biến tham chiếu) sẽ được lưu trong Stack và trỏ đến một đối tượng thật sự nằm trong Heap.
		+ Nhưng vì String là bất biến, nên khi gán giá trị mới cho chuỗi, một vùng nhớ mới trên Heap sẽ được tạo ra, biến đối tượng sẽ hủy tham chiếu đến vùng nhớ cũ (giá trị bên trong vẫn sẽ được giữ nguyên) và sau đó trỏ đến vùng nhớ mới.
		+ Nghĩa là mỗi lần gọi hàm (ví dụ: cắt chuỗi, nối chuỗi...), ta sẽ nhận về một chuỗi mới thay vì thay đổi giá trị của chuỗi gốc và sẽ lại có thêm một vùng RAM khác được tạo ra.
		+ Vì vậy, đối tượng được tạo ra ban đầu thực chất sẽ không bị thay đổi giá trị và sau đó sẽ được bộ thu gom rác của Java dọn dẹp.

		Ví dụ:
			String str = "Hello";
			str = str + " World"; // tạo ra một chuỗi mới "Hello World",
					      // không thay đổi giá trị của str

----------------------------------------

Các cách để khai báo và gán giá trị cho những đối tượng thuộc lớp String (áp dụng được cho những đối tượng thuộc những lớp đóng gói - Wrapper Class):

	1. Tường minh: Sử dụng từ khoá new() để tạo một vùng RAM mới.
		- Đây là kiểu viết cũ.
		- Ở các phiên bản JDK mới sẽ hiển thị cảnh báo nếu viết theo kiểu này.
		- Mỗi lần gán giá trị bằng từ khoá new() thì sẽ có một vùng RAM mới, độc lập được tạo ra.

		Ví dụ: Mỗi lần new() là sẽ có một vùng RAM mới, độc lập với nhau.
			String loiChao1 = new String("Xin chào!");
			String loiChao2 = new String("Xin chào!");

	2. Ngầm định: Gán một giá trị trực tiếp / trực hằng (literal) vào biến.
		- Bản chất vẫn là ngầm định tạo ra một vùng RAM mới.
		- Nhưng nếu được gán cùng một giá trị (có phân biệt hoa-thường đối với kí tự / chuỗi), những biến này sẽ có cùng một địa chỉ tham chiếu (sử dụng chung một vùng nhớ - String pool).
		- Giúp tiết kiệm vùng nhớ khi những giá trị giống nhau có thể tận dụng được vùng nhớ của nhau và tăng tốc trong quá trình cấp phát giá trị.

		Ví dụ: Nếu cùng chứa một giá trị, sẽ cùng tham chiếu đến một vùng RAM.
			String loiChao1 = "Xin chào!";
			String loiChao2 = "Xin chào!";

----------------------------------------

Tuỳ thuộc vào ngữ cảnh mà khi in ra bằng System.out.println(), Java sẽ tự động dự đoán và sử dụng dấu '+' để ghép các kí tự lại với nhau.

	- Nếu giá trị truyền vào là một biến để tính toán các biểu thức / giá trị, Java sẽ tự động chuyển giá trị thành chuỗi và sau đó mới tiến hành nối chuỗi.

	- Tuy có dấu '+' để nối chuỗi, nhưng Java lại không có dấu '-' để loại bỏ bớt chuỗi. Vì vậy, nếu tính toán có sử dụng dấu '-' thì khi truyền vào chuỗi phải sử dụng dấu ngoặc tròn '()' để thay đổi thứ tự ưu tiên của phép tính.

	Ví dụ: để tính toán và in ra năm sinh (kiểu int).

		// Sử dụng cặp ngoặc tròn để thay đổi độ ưu tiên
		System.out.println("your age: " + (2022 - yob) + " years old");

Lớp String vừa là static, vừa là non-static; có thể sử dụng thông qua tên lớp hoặc tên đối tượng.

	Ví dụ:
		// Sử dụng thông qua tên lớp - static
		String.format();

		// Sử dụng thông qua tên đối tượng - non-static
		String name = "Thuan";
		name.format();

------------------------------------------------------------

Phân biệt các thuật ngữ Null, Empty và Blank trong chuỗi:

	1. Null: Sẽ chưa được cấp phát vùng nhớ, vì chuỗi đang không tham chiếu đến bất kì vùng nhớ nào.
		| String str = null;

	2. Empty: Vẫn là một đối tượng chuỗi và chiếm một vùng nhớ, nhưng không chứa bất kì giá trị nào và có độ dài bằng 0.
		| String str = "";

	3. Blank: Thuật ngữ không được sử dụng trực tiếp trong Java, có thể hiểu đây là một chuỗi chỉ chứa khoảng trắng.
		| String str = "     ";

------------------------------------------------------------

* Biểu thức chính quy / Biểu thức quy tắc (Regular expression / Regexp / Regex / Regxp): kí hiệu, kí tự được quy định để tách chuỗi.
	- Kỹ thuật ép người dùng nhập chuỗi theo đúng định dạng được yêu cầu.
	- Có thể được ứng dụng trong việc kiểm tra một ô nhập (email, tên, năm sinh, ngày/tháng/năm...) có hợp lệ hay không.

Trong Java, biểu thức chính quy sẽ nằm trong gói java.util.regex, bên trong chứa ba lớp phổ biến:
	- Pattern.
	- Matcher.
	- PatternSyntaxException.

Danh sách những kí tự phổ biến:
	- '\\s': Một khoảng trắng.
	- '\\w': Một chữ số.
	- '\\d': Một con số.
	
	- '?': Không hoặc một (0 ≤ '?' ≤ 1). 
	- '*': Không hoặc nhiều (≥ 0).
	- '+': Một hoặc nhiều (≥ 1).

	- '^': Bắt đầu với kí tự gì.
	- '$': Kết thúc với kí tự gì.
	- '|': Hoặc (một trong hai).

	- "[]":
		+ Gom nhóm các kí tự cụ thể lại với nhau.
		+ Có thể chọn một khoảng kí tự và phân cách nhau bằng dấu gạch ngnag.
		+ "[^]": Loại trừ những kí tự được liệt kê bên trong.

		Ví dụ:
			// Chỉ định những kí tự cụ thể
			[abcd]...

			// Nằm trong khoảng
			[a-z], [A-Z], [a-zA-Z], [0-9]...

	- "()":
		+ Gom nhóm các biểu thức chính quy lại với nhau.
		+ Thường để kết hợp thêm với những toán tử (biểu thức chính quy) khác.

		Ví dụ:
		
			// Tìm sự xuất hiện của chuỗi "ab" trong một hoặc nhiều lần
			(ab)+

	- "{số-lượng}": Số lượng kí tự được khai báo ở phía trước.

	Ví dụ: Chuẩn hoá chuỗi - Cơ bản.

		// Thay thế toàn bộ khoảng trắng dư thừa
		// bằng một khoảng trắng duy nhất
		String loiBaiHat = "Em    ơi,   Hà   Nội     phố";
		loiBaiHat = loiBaiHat.replaceAll("\\s+", " ");
		System.out.println(loiBaiHat);

		// Thay thế toàn bộ dấu phẩy, phía sau là 0..n khoảng trắng
		// chỉ bằng một dấu phẩy và một khoảng trắng
		String loiKeuGoi = "Bất kỳ đàn ông,đàn bà,   bất kỳ người già,người trẻ...";
		loiKeuGoi = loiKeuGoi.replaceAll("\\,\\s*", ", ");
		System.out.println(loiKeuGoi);

--------------------------------------------------------------------------------

[CÁC LỚP XỬ LÝ CHUỖI NÂNG CAO]

Với nhược điểm là lớp bất biến (Immutable), lớp String chỉ thích hợp với những hoạt động chỉ đọc và không thay đổi.
	- Được cấp phát tĩnh giống như mảng, độ dài của vùng nhớ sẽ không được thay đổi.
	- Không có các câu lệnh để thêm (đầu, đuôi...) và xoá phần tử.

Trong khi đó, ba kiểu còn lại của lớp String nói chung (StringBuffer, StringBuilder, StringTokenizer) đều là dạng chuỗi khả biến (Mutable) và được cấp phát động.
	- Cấp phát có dự trù để tiết kiệm công sức trong việc cơi nới.
	- Uyển chuyển hơn trong cách tổ chức bộ nhớ và mạnh mẻ hơn trong các xử lý liên quan đến thêm-xoá-sửa-tìm kiếm chuỗi.
	- Giúp tối ưu hiệu suất mà không phải tốn quá nhiều thao tác (thao tác: tạo đối tượng mới, hủy tham chiếu cũ, tham chiếu đến đối tượng mới, thu gom vùng nhớ của đối tượng cũ).
	- Những thay đổi sẽ được thực hiện trên chuỗi gốc mà không cần phải tạo chuỗi mới.
	- Chỉ nên sử dụng khi cần các xử lý trên chuỗi, nếu chỉ để lưu trữ và hiển thị ra bên ngoài thì sử dụng lớp String là đủ.
	- Tuy nhiên, cả hai lớp StringBuffer và StringBuilder (không tính StringTokenizer vì lớp này không được sử dụng để chứa chuỗi) đều không cho phép trực tiếp gán giá trị (Ví dụ: StringBuilder sb = "ABC").
		+ Muốn gán giá trị, bắt buộc phảo thông qua từ khoá new().
		+ Điều này cũng đồng nghĩa với việc sẽ luôn có một vùng RAM mới trong mỗi lần khởi tạo chứ không thể nào sử dụng chung giá trị trong bể bơi (String Pool).
		+ Hơn nữa, ta cũng không thể sử dụng phép cộng '+' để gán chuỗi giống như trong String.

------------------------------------------------------------

	* Luồng (Thread): Một đơn vị (unit) code (hàm) được thực thi.
	* Chương trình đa luồng (Multi-threading Program): Một chương trình đang có nhiều luồng thực thi đồng thời.
		- Nếu tại một thời điểm, có hai luồng cùng truy cập vào một nguồn dữ liệu và cùng thay đổi dữ liệu bên trong, điều này sẽ khiến dữ liệu bị xung đột và thiếu tính nhất quán.
		- Trong Java, JVM sẽ xử lý đồng bộ (Synchronized) bằng cách: tại một thời điểm, đảm bảo rằng chỉ có một luồng được phép truy cập và thay đổi dữ liệu.
		- Một lớp được gán danh hiệu an toàn với luồng (Thread-safe) khi bên trong chứa những phương thức đồng bộ hóa (Synchronized).

		* Lưu ý: Hai thuật ngữ đồng thời (Concurrency) và song song (Parallelism) có một số điểm khác biệt:
			- Đồng thời (Concurrency): Giải quyết nhiều công việc một lúc, nhưng đan xen ở các thời điểm khác nhau (không cùng một thời điểm).
				Ví dụ: Đang chạy bộ thì dừng lại để uống nước, sau đó tiếp tục chạy.
			- Song song (Parallelism): Giải quyết nhiều công việc một lúc tại cùng một thời điểm.
				Ví dụ: Vừa chạy bộ, vừa uống nước.

* StringBuffer: Là một lớp đồng bộ (Synchronized), nên sẽ an toàn (Thread-safe) khi sử dụng trong môi trường đa luồng (Multi-threading) mà không gây ra vấn đề về đồng bộ hóa, nhưng sẽ làm ảnh hưởng đến tốc độ vì phải chờ để xét độ ưu tiên xử lý.

	Ví dụ:
		StringBuffer sb = new StringBuffer("Hello");
		sb.append(" World"); // Trực tiếp thay đổi giá trị của sb thành "Hello World"

------------------------------------------------------------

* StringBuilder: Ra đời sau StringBuffer, là một lớp không đồng bộ (Non-synchronized), nhờ vậy mà tốc độ xử lý sẽ nhanh hơn so với StringBuffer.

	Ví dụ:
		StringBuilder sb = new StringBuilder("Hello");
		sb.append(" World"); // Trực tiếp thay đổi giá trị của sb thành "Hello World"

------------------------------------------------------------

* StringTokenizer: Không thuộc lớp java.lang giống như ba loại còn lại mà thuộc lớp java.util.StringTokenizer.
	- Có công dụng phân "chặt" chuỗi thành những phần tử con riêng lẻ - "khúc" (token) dựa trên một kí tự hoặc chuỗi kí tự phân tách (dấu giới hạn, dấu tách, dấu định nghĩa - delimiter) được chỉ định, mặc định sẽ phân tách bằng dấu khoảng trắng nếu không chỉ định gì thêm.
	- Khi đã có được từng "khúc", ta có thể được truy cập tuần tự bằng cách sử dụng các phương thức như hasMoreTokens() và nextToken().

	Ví dụ:
		// Khai báo chuỗi
		String str = "Hello,World";

		// Chỉ định kí tự phân tách,
		// trong trường hợp này là dấu phẩy ','
		StringTokenizer tokenizer = new StringTokenizer(str, ",");

		// Sử dụng một vòng lặp để duyệt
		// và in ra từng token đã được phân tách
		while (tokenizer.hasMoreTokens()) {
			String token = tokenizer.nextToken(); // Lấy token tiếp theo
			System.out.println(token); // In ra "Hello" và "World"
		}

--------------------------------------------------------------------------------

[PHƯƠNG THỨC TOSTRING()]

Phương thức toString(): Là phương thức luôn tiềm ẩn bên trong mỗi đối tượng, cho phép hiển thị ra toàn bộ thông tin của đối tượng ở mức cơ bản, đồng thời vẫn cho phép thiết kế lại để chỉ in ra những thông tin cần thiết.
	- Giống như việc mỗi công dân đều sẽ có một thẻ "CMND/CCCD" để lưu toàn bộ những thông tin cá nhân ở mức cơ bản.
	- Mỗi một vùng new (kể cả mảng) cũng đều sẽ có sẵn phương thức toString() với phạm vi truy cập là public.
	-> Mặc định, mọi đối tượng đều sẽ tự có một phương thức toString() bên mình.

* toString(): là phương thức của lớp String, được sử dụng để in ra tất cả những thuộc tính mà ta đã gán (đổ vào) cho một đối tượng, có liên quan đến tính kế thừa (Inheritance).

	- Có nhiệm vụ chuyển tất cả thành chuỗi trước khi in ra.

	- Vì đã có đầy đủ thông tin về thuộc tính, phương thức toString() hoàn toàn có thể được ta tự thiết kế hoặc tạo ra một cách tự động.
		+ Sử dụng phương thức tĩnh format() thuộc lớp String và các đặc tả kiểu dữ liệu giống như trong ngôn ngữ C, để có thể chủ động định dạng kết quả trả về (cũng là một chuỗi).
		+ Sau khi đã gán ghép và định dạng chuỗi bằng phương thức format(), ta phải có thêm một bước in ra kết quả thông qua câu lệnh println().

	- Thay vì phải in ra từng thành phần cụ thể, ta sẽ sử dụng phương thức toString() để in ra một chuỗi và bên trong tuỳ ý gán ghép chuỗi.
		+ Bắt buộc phải đi kèm với từ khoá @Override ở bên trên tên hàm.
		+ Phải sử dụng thêm câu lệnh println() nếu muốn in kết quả ra.
	
	- Mỗi khi đứng từ bên ngoài (ví dụ: kết hợp với println()) thì chỉ cần mô tả tên của đối tượng (toạ độ vùng RAM) mà không cần gọi phương thức toString(), nơi gọi hàm cũng sẽ tự động hiểu.

	-> Phương thức giúp biến đổi mọi thông tin thành chuỗi và sau đó hiển thị ra.
		(Cho phép hiển thị ra tất cả các thông tin của đối tượng.)

Khi in ra toạ độ của một biến đối tượng / con trỏ (bằng tênBiếnĐốiTượng / tênBiếnConTrỏ) thông qua câu lệnh System.out.println(), Java sẽ tự động gọi phương thức toString() và đi đến nơi được mô tả trong địa chỉ, sau đó lấy và in ra hết toàn bộ thông tin của đối tượng đó mà không cần phải sử dụng thêm một câu lệnh nào khác.

	- Vì vậy, lúc này, để in ra toàn bộ thông tin của đối tượng bằng phương thức toString() kết hợp với câu lệnh println(), ta có hai cách:
		+ Tường minh: Có sử dụng thêm tênBiếnĐốiTượng.toString().
		+ Ngầm định: Chỉ cần có tênBiếnĐốiTượng (vì đây là nơi nắm giữ địa chỉ).
			(Ngoài ra, nếu không phải để in kèm với câu lệnh println(), cách gọi ngầm định này sẽ trả về địa chỉ của một đối tượng, nhưng lại không phải gọi ngầm toString().)

	- Đây là đặc quyền của riêng phương thức toString(), những phương thức khác nếu muốn được gọi thì phải tự sử dụng thêm dấu chấm để gọi phương thức.

	- Nhưng để được hưởng đặc quyền in ra thông tin này...
		+ Bắt buộc phải có sẵn phương thức toString() trong khuôn, dù là tự thiết kế bằng thủ công hay phát sinh tự động.
		+ Nếu cố tình in ra thông tin khi không có sẵn phương thức toString() trong khuôn, dù gọi theo kiểu tường minh hoặc ngầm định, kết quả trả về sẽ đều là một con số hệ 16 - mã băm.

	* Khi cố tình sử dụng giá trị hoặc in ra địa chỉ của một đối tượng đang trỏ đến NULL, dù đã hoặc chưa thiết kế phương thức toString()...
		- Nếu gọi ngầm định, kết quả in ra sẽ là "null".
		- Nếu gọi tường minh, kết quả in ra sẽ là lỗi ngoại lệ con trỏ NULL.

	-> Thầm gọi tên em - Phương thức toString() sẽ được tự động gọi khi in tên đối tượng.

	Ví dụ:
		// Trong ngôn ngữ C, phải sử dụng thêm cú pháp "*tênBiếnConTrỏ"
		// để có thể lấy được giá trị bên trong
		int a = 100;
		int* b = &a;		// Biến con trỏ nhận vào địa chỉ
		printf("%d\n", *b);	// Đi đến địa chỉ và lấy giá trị ra


		// Trong khi đó, trong Java,
		// để in ra thông tin của một đối tượng
		Dog cauVang = new Dog("Cậu Vàng", 1943, 12.0);

		// [Truyền thống & chuẩn bài]
		// Chủ động sử dụng phương thức toString()
		System.out.println("Cậu Vàng details: " + '\n' + cauVang.toString());

		// [Hiện đại & ma giáo]
		// Sử dụng trực tiếp tên đối tượng - biến con trỏ,
		// trỏ đến vùng nhớ Heap - nơi chứa toàn bộ thông tin về đối tượng,
		// phương thức toString() sẽ được ngầm định gọi
		// và sau đó in ra thông tin mà không cần thêm câu lệnh trung gian
		System.out.println("Cậu Vàng details: " + cauVang);

------------------------------------------------------------

	* Mã băm (Hash number): kỹ thuật để xác thực dữ liệu và đảm bảo dữ liệu vẫn còn nguyên vẹn, không bị sai lệch trên đường truyền; thuật toán mã hóa để giúp tìm điểm đặc trưng của một dữ liệu, gom dữ liệu thành một con số.

Nếu trong lớp chưa thiết kế sẵn phương thức toString(), thì khi cố gắng in ra chi tiết của biến đối tượng (biến đang trỏ đến một đối tượng thật sự), ta vẫn có thể ngầm định hoặc tường minh sử dụng phương thức toString() như bình thường thông qua câu lệnh println().

	- Thực chất, khi thiết kế phương thức toString() tại bất kì lớp nào, chúng ta sẽ bắt gặp từ khoá @Override.
		+ Đó là do tất cả các lớp đều mặc định kế thừa từ lớp Cha Object.
		+ Cho nên, mặc dù lớp Con không chịu thiết kế riêng cho mình một phương thức toString(), nhưng vẫn có thể gọi và sử dụng.

	- Đó là nhờ máy ảo Java đã tự động băm (hash) dữ liệu và sau đó in ra một con số thuộc hệ thập lục phân (hệ 16 - hexadecimal) - được gọi là mã băm (hash number) của vùng RAM mà đối tượng đang nằm.
	
	- Toàn bộ dữ liệu đã được đổ vào trong đối tượng sẽ được băm/chuyển đổi theo một thuật toán để ra được một con số đặc trưng.

	-> Tự động băm và nén dữ liệu thành một con số thuộc hệ thập lục phân (hệ 16 - hexadecimal).

	Ví dụ: mã băm được in ra sau khi sử dụng câu lệnh System.out.println(tênBiếnĐốiTượng); mà vẫn chưa thiết kế phương thức toString() ở lớp.
		data.Student@36f6e879
		data.Student@5a61f5df

Mảng trong Java cũng là một đối tượng, tên mảng cũng là biến con trỏ. Vì vậy, khi sử dụng câu lệnh System.out.println() kết hợp với tên mảng, một mã băm thuộc hệ 16 cũng sẽ được in ra.

------------------------------------------------------------

=> Lập trình viên có thể chủ động để hàm toString() in ra chuỗi, hoặc bị động để hàm toString() in ra mã băm ở dạng thập lục phân (hệ 16 - hexadecimal).

==========================================================================================

[LỚP BAO KIỂU NGUYÊN THỦY / LỚP TRAI BAO - PRIMITIVE WRAPPER CLASS]

Vì trong lập trình hướng đối tượng, mọi thứ đều phải là đối tượng (mỗi đối tượng đều chiếm hai vùng RAM).

	- Nhưng trong Java, những kiểu dữ liệu thường sử dụng (byte, short, int, long, float, double, char, boolean) lại là những kiểu đơn giản (Primitive) và lưu trực tiếp giá trị trong vùng nhớ được cấp, không phải là đối tượng (không thể chấm để lấy thông tin).

	- Đồng thời cũng là những kiểu dữ liệu "nguyên thuỷ" giúp lưu trữ thông tin, nhờ đấy làm cơ sở để phát triển nên nhiều thứ khác.

	- Nhưng khi lập trình hướng đối tượng ra đời với ý tưởng gom mọi thông tin vào chung một nhóm để tạo thành đối tượng, khiến các giá trị đơn giản này trở nên lạc loài khi không thể tham gia để cùng xử lý với các đối tượng.
	
	- Vì vậy, để có thể thao tác được trên các giá trị đơn giản, gói java.lang (nơi chuyên chứa những gì đặc trưng nhất của ngôn ngữ Java) đã cung cấp các lớp bao bọc (Wrapper Class) giúp bọc những kiểu dữ liệu đơn giản lại và biến chúng thành kiểu dữ liệu đối tượng (phức tạp).
		(Trong khi đó, java.util chỉ là nơi chứa những công cụ đi kèm để phục vụ thêm cho việc xử lý thông tin.)
		-> Các gói thư viện có sẵn (native) trong ngôn ngữ lập trình.

Để chuyển các kiểu dữ liệu cơ bản thành kiểu lớp bao bọc.
	- Vẫn viết hoa chữ cái đầu tiên giống như những lớp khác.
	- Viết tên gọi đầy đủ của kiểu dữ liệu (để phân nhóm) thay vì viết tên gọi tắt.

	* Kiểu đơn giản		* Kiểu Wrapper
	boolean		->	Boolean
	char		->	Character
	byte		->	Byte
	short		->	Short
	int		->	Integer
	long		->	Long
	float		->	Float
	double		->	Double

--------------------------------------------------------------------------------

* Lớp trai bao / đóng gói / biến hình / bao bọc (Wrapper Class): là một lớp static, được sử dụng để chuyển những kiểu dữ liệu đơn giản thành kiểu dữ liệu đối tượng.

	- Nếu đối tượng là những gì có thể phân biệt, đếm và mô tả được thì các giá trị đơn giản cũng có thể mô tả dưới dạng một đối tượng được.

		Ví dụ: Cho danh sách các số nguyên kiểu integer

			1, 2, 3, 5, 7, -5, -10

			* Đặc điểm / Thuộc tính:
				- Giá trị / Đại lượng: 1, 2, 3, 5, 7, -5, -10
				- Trọn vẹn: Số nguyên, không bị lẻ về giá trị.

			* Hành vi / Hành động:
				- So sánh giữa các đại lượng với nhau (1 < 2)
				- Tham gia vào một đại lượng khác để ra được số mới (6 -> 9 => 69)
				- Giá trị tính theo vị trí (1900 -> 9 thuộc hàng trăm)

			-> Mô tả, gom nhóm và đặt tên chung được.
				=> Nhóm Integer: Nhóm đại diện cho những con số nguyên bị lẻ miếng nào.

			// Chuyển thể ý tưởng thành code giả
			public class Integer {

				// Đặc điểm của lớp là một giá trị nguyên, không bị lẻ
				private int value;

				// Nhận giá trị từ bên ngoài đưa vào
				public Integer(int value) {
					this.value = value;
				}

				// getter() và setter()

				// Hàm đặc biệt - Nằm riêng tại vùng static,
				// không cần phải nhớ lại các giá trị đã chuyển đổi
				// và cho phép sử dụng trực tiếp mà không cần tạo đối tượng
				public static int parseInt(Sting num) {
					// Nhận vào một chuỗi
					// sau đó chuyển đổi sang số nguyên (đơn giản)
				}
			}

	- Vì Collection Framework chỉ trỏ đến một vùng RAM ở xa chứa danh sách các con trỏ khác, nhằm đảm bảo tính đa hình, linh hoạt và nhất quán trong xử lý dữ liệu.
		+ Để lưu được một danh sách các giá trị đơn giản trong Collection Framework thay vì mảng đơn giản thì bắt buộc phải chuyển toàn bộ các giá trị thành đối tượng.
		+ Khi đã trở thành đối tượng thì có thể thoải mái sử dụng dấu chấm, nhưng đổi lại sẽ tốn dung lượng RAM hơn.
		+ Giúp Collection Framework giữ được đặc tính thuần đối tượng, sử dụng dụng mọi thứ thông qua dấu chấm, không giống như mảng khi phải chia ra một bên là mảng đơn giản và một bên là mảng đối tượng.

		Ví dụ: ArrayList chỉ chấp nhận các giá trị phức tạp.

			// Hợp lệ - Sử dụng danh sách các giá trị phức tạp
			List<Student> arr = new ArrayList();
			List<Integer> arr = new ArrayList();
		
			// Không hợp lệ - Sử dụng danh sách các giá trị đơn giản
			List<int> arr = new ArrayList();

	- Các giá trị đơn giản sẽ được gói / bao bọc (wrap) vào trong một vùng RAM lớn hơn để biến những giá trị này trở thành những giá trị phức tạp, nên vùng RAM thực hiện công việc chuyển đổi này được gọi là "Lớp bao bọc - Wrapper Class".
		+ Đầu tiên, một vùng new() sẽ được tạo ra, sau đó sẽ gói giá trị đơn giản vào bên trong.
		+ Lúc này, các lớp bao bọc chỉ có một thuộc tính duy nhất (phần lõi) để chứa giá trị đơn giản vừa gói vào.

	- Tuy có điểm lợi là sẽ giúp thống nhất trong việc xử lý dữ liệu, nhưng chỉ nên sử dụng khi có yêu cầu phải là đối tượng, nếu không thì vẫn nên sử dụng biến đơn giản, vì các đối tượng này sẽ rất tốn RAM khi khi phải sử dụng đến hai vùng RAM.
		1. Vùng RAM lớn được new() để chứa giá trị đơn giản và các câu lệnh của lớp.
		2. Con trỏ để trỏ đến vùng RAM lớn này.

	-> Biến giá trị đơn giản thành phức tạp để thống nhất trong xử lý dữ liệu.
		(Phần lõi được gói lại thành một đối tượng.)

--------------------------------------------------------------------------------

Vì đã là một lớp, nên ta hoàn toàn có thể gọi tên lớp và tạo mới đối tượng như bao lớp khác.

	- Bản chất vẫn là truyền giá trị đơn giản vào phần tham số của phễu (hoặc một chuỗi giống như hàm parse()), sau đó giá trị sẽ được gói lại vào thuộc tính của lớp và trả ra một địa chỉ thông qua con trỏ.

		Ví dụ: Sử dụng lớp Integer để tạo mới đối tượng
		
			Integer yob = new Integer("2003"); // Giống hàm parse()
			Integer yob = new Integer(2003);

	- Lúc này, khi in ra trực tiếp giá trị bằng câu lệnh System.out.println()...
		+ Mặc dù sử dụng tên con trỏ, nhưng vì đối tượng này chỉ có duy nhất một thuộc tính, nên giá trị chứa bên trong thuộc tính sẽ được Java tự động ngầm in ra.
		+ Ta có thể chủ động chỉ định in giá trị bằng toString(), vì bên trong các lớp bao bọc đã có vượt mặt hàm toString().
		+ Thêm nữa, ta cũng có thể chủ động chỉ định in giá trị đang được lưu trữ bên trong thuộc tính bằng intValue(), nhưng không cần thiết.

		Ví dụ: In giá trị đang được gói bên trong đối tượng ra.

			System.out.println("num1: " + num1);
			System.out.println("num2: " + num2.toString());
			System.out.println("num3: " + num3.intValue());

------------------------------------------------------------

* Đóng hộp / Nâng cấp (Auto-Boxing / Boxing): Vẫn sẽ đưa giá trị đơn giản từ phễu vào trong lớp để biến thành đối tượng và nhận về một toạ độ, mặc dù câu lệnh new() không được ghi tường minh ra, nhưng trước tiên một vùng RAM vẫn sẽ được ngầm tạo ra để sau đó chứa giá trị.
	-> Ngầm tạo vùng RAM và đóng gói giá trị đơn giản thành phức tạp.
		(Biến đổi giá trị đơn giản thành phức tạp và đưa cho biến đối tượng giữ.)

	Ví dụ: Cách viết ngầm định cho việc khởi tạo một vùng RAM để gói một giá trị đơn giản.
	
		// Ở các phiên bản JDK mới,
		// đây là cách viết được khuyến khích
		Integer yob = 2003;

		// Vẫn chỉ là đưa giá trị đơn giản vào cho lớp bao bọc,
		// một vùng RAM mới sẽ được tạo ra - new() ngầm,
		// vì đang gán trực tiếp giá trị cho một vùng RAM
		Integer yearOfBirth = yob;

----------------------------------------

* Mở hộp / Hạ cấp (Un-Boxing): Đưa con trỏ chứa toạ độ vào cho một biến đơn giản giữ, Java sẽ tự động lần theo địa chỉ của vùng RAM lớn để lấy ra được giá trị đơn giản nằm bên trong lõi và sau đó gán vào biến đơn giản.
	-> Ngầm mở gói phức tạp để lấy ra được giá trị đơn giản.
		(Biến đổi giá trị phức tạp thành đơn giản và đưa cho biến đơn giản giữ.)

	Ví dụ: Đưa địa chỉ vùng RAM vào giá trị đơn giản.

		Integer yob = 2003;
		int a = yob;

------------------------------------------------------------

	Khi ao, hồ, sông, suối cùng là những hệ sinh thái nước ngọt.
		- Thường do thiên nhiên tạo ra nên không thuộc sở hữu riêng của bất kì ai.
		- Là môi trường sinh sống cho nhiều loài sinh vật, cung cấp nước cho sinh hoạt, tưới tiêu nông nghiệp và phục vụ cho giao thông.
		- Không giới hạn số lượng người sử dụng.

		-> Nơi sử dụng chung và không giới hạn số lượng người sử dụng.
	
	Bể bơi hay hồ bơi là một loại công trình xây dựng.
		- Nằm trong một khu vực nào đó được kiểm soát.
		- Thường phục vụ cho việc bơi lội hoặc các hoạt động vui chơi, nghỉ dưỡng và du lịch.
		- Tuy cho phép rất nhiều người cùng tham dự, nhưng vẫn có giới hạn ở một số lượng nhất định.

		-> Nơi sử dụng chung, nhưng có giới hạn số lượng người sử dụng.

	Bồn tắm là dụng cụ, đồ vật có hình dáng giống như thùng chứa lớn để giữ nước.
		- Được được đặt trong phòng tắm.
		- Được thiết kế để phục vụ cho việc chứa đựng được một người (hoặc hai - ba người) trong đó
		- Giúp họ thực hiện việc tắm rửa, thư giãn.

		-> Nơi sử dụng riêng hoặc chỉ chia sẻ với tối đa 1-2 người khác.

----------------------------------------

* Hồ bơi / Bể bơi (Pool): Trong lập trình, khi các con trỏ trong các Wrapper Class và String cùng chứa một giá trị giống nhau thì sẽ sử dụng chung một vùng RAM.

	- Giá trị sử dụng chung sẽ là:
		+ Đối với số nguyên, sẽ nằm trong khoảng từ [-128 .. +127] (256 trường hợp, bao gồm cả số 0).
		+ Đối với chuỗi, sẽ phân biệt hoa thường.

	- Chỉ có tác dụng khi khai báo bằng cách ngầm định - Đóng hộp; nếu khai báo tường minh theo phong cách hướng đối tượng với từ khoá new() thì sẽ không bao giờ có chung vùng nhớ được, vì có new() là có vùng nhớ mới.

	- Vẫn là sử dụng ké vùng RAM do biến đi trước đã new() sẵn thay vì phải new() nhiều lần cho mỗi đối tượng khác nhau.
		+ Nhưng đây không phải là vùng nhớ static, vì các đối tượng sẽ sử dụng chung cả một vùng RAM lớn (chứa cả thuộc tính và phương thức).
		+ Trong khi với static, đây chỉ là một vùng nhớ nhỏ sử dụng chung được tách riêng ra từ một lớp lớn.
		
	- Giúp tạo nhanh đối tượng nhằm tiết kiệm vùng RAM, tối ưu hoá tốc độ cho việc cấp phát và lưu trữ những khoảng giá trị nhất định, vì đây là những kiểu dữ liệu thường được sử dụng nhất trong lập trình.

	-> Vùng nhớ cho phép nhiều chàng cùng trỏ một nàng.

	Ví dụ: Sử dụng kỹ thuật đóng hợp với các lớp bao bọc và lớp String
		// Đối với số nguyên - Integer
		Integer n1 = 108;
		Integer n2 = 108;
		Integer n3 = new Integer(108);

		// So sánh giữa n1 và n2
		System.out.println("n1 vs. n2: " + (n1 == n2)); // True

		// So sánh giữa n2 và n3
		System.out.println("n2 vs. n3: " + (n2 == n3)); // False

		// Đối với chuỗi - String
		String s1 = "Hello";
		String s2 = "Hello";
		String s2 = "HELLO";

		// So sánh giữa s1 và s2
		System.out.println("s1 vs. s2: " + (s1 == s2)); // True

		// So sánh giữa s2 và s3
		System.out.println("s2 vs. s3: " + (s2 == s3)); // False

------------------------------------------------------------

Giống như việc điểm trung bình của một học là loại điểm cố định vào cuối học kỳ, không cho phép trực tiếp thay đổi mà yêu cầu phải học lại toàn bộ và thi lại ở những học kỳ sau để lấy điểm mới.

Đối với các lớp bao bọc, việc Immutable được diễn ra khi cố gắng thay đổi giá trị của một con trỏ.
	- Vì bản chất khi đưa một giá trị đơn giản vào thì chắc chắn sẽ có một vùng new() ngầm.
	- Dù là lần đầu tiên khai báo hay chỉ là gán lại giá trị thì đều là hành động đưa giá trị đơn giản vào cho biến đối tượng, nên kỹ thuật đóng hộp được áp dụng và một vùng RAM mới tương đương với giá trị mới sẽ được tạo ra.
	- Sau khi gán sang giá trị (vùng RAM) mới, vùng RAM cũ nếu không có ai trỏ đến thì chắc chắn sẽ bị dọn dẹp tự động.
	-> Không cho phép thay đổi giá trị, gán lại giá trị tức là new() ngầm vùng RAM mới.

	Ví dụ: Giá trị cố định sau khi được tạo ra.

		// Một vùng new() được ngầm tạo ra
		// để chứa giá trị nguyên thuỷ
		// và sau đó sử dụng con trỏ để trỏ đến
		Integer yob = 2003;

		// Một vùng new() mới tiếp tục được ngầm tạo ra
		// thay vì trực tiếp thay đổi giá trị ở bên trong
		// mà con trỏ đang nắm giữ
		yob = 2000;

--------------------------------------------------------------------------------

* Lưu ý 1: Đừng nhầm lẫn giữa lớp bao bọc (Wrapper Class) với tính đóng gói (Encapsulation).
	- Thuật ngữ Wrapper Class shỉ áp dụng cho 8 kiểu dữ liệu đơn giản (byte, short, int, long, float, double, char, boolean) - đóng gói trong phạm vi nhỏ.
	- Còn việc gói mọi thứ phức tạp của các đối tượng (thuộc tính và phương thức) do người dùng tự định nghĩa vào bên trong một lớp sẽ được gọi là tính đóng gói (Encapsulation) - đóng gói trong phạm vi rộng.

* Lưu ý 2: Đừng nhầm lẫn với ép kiểu (Casting), vì ép kiểu yêu cầu ít nhất cùng phải là cùng kiểu hoặc tương đồng (đơn giản - đơn giản, phức tạp - phức tạp).

* Lưu ý 3: Mặc dù việc sử dụng toán tử so sánh bằng (==) đối với hai biến con trỏ đôi khi sẽ cho ra được kết quả mong muốn (ví dụ: bể bơi trong lớp bao bọc...), nhưng kết quả cho ra thông qua toán tử so sánh sẽ không có tính ổn định.
	+ Tốt nhất vẫn là nên sử dụng thông qua hàm so sánh mà các đối tượng cung cấp.
	+ Hoặc phải so sánh dựa trên một giá trị cụ thể nào đó bằng cách chấm để truy cập thuộc tính của đối tượng.

==========================================================================================

[MẢNG - ARRAY]

Vì lập trình là xử lý dữ liệu (được lưu trữ trong biến) và mảng là cách để lưu trữ và xử lý được nhiều dữ liệu cùng một lúc.
	- Chứa các phần tử cùng kiểu dữ liệu.
	- Được khai báo cùng một lúc.
	- Có cùng một tên và phân biệt bằng chỉ số phụ (index).
	- Với dãy các ô nhớ được tổ chức liên tiếp nhau trong RAM.
	- Đặc biệt, tên mảng cũng sử dụng để tham chiếu đến phần tử đầu tiên của mảng.
	- Mảng sẽ được lưu trữ trong Heap nếu được khai báo bên trong hàm, còn con trỏ của mảng sẽ nằm trong Stack.

	-> Mảng là tập hợp của nhiều biến.

------------------------------------------------------------

Có hai loại mảng trong Java: Chỉ phân loại về giá trị được chứa bên trong mảng, còn phần bên ngoài vẫn giống nhau ở điểm đều cùng là con trỏ.

	1. Mảng đơn giản (Primitive Array): Lưu trực tiếp giá trị thuộc các kiểu dữ liệu nguyên thủy như: int, double, char, boolean...

		Ví dụ: Lưu những phần tử đơn giản (Primitive) cùng kiểu dữ liệu.
			int[] numbers = new int[5];
			float[] grades = new float[10];

	2. Mảng phức tạp (Object Array): Lưu tham chiếu (reference) đến đối tượng thuộc một lớp được định nghĩa sẵn (Lớp đóng gói - Wrapper Class) hoặc lớp do người dùng tự định nghĩa.
		- Là một sự kết hợp giữa những giá trị đơn giản và phức tạp khi mảng có thêm những thuộc tính và phương thức public của riêng mình.
		- Có thể chứa những phần tử khác kiểu dữ liệu (khác lớp) bằng cách sử dụng lớp thuỷ tổ Object hoặc sử dụng kế thừa.

		Ví dụ 1: Lưu những phần tử phức tạp (Object) cùng kiểu dữ liệu.
		
			Person[] people = new Person[5];
			String[] names = new String[3];

		Ví dụ 2: Lưu những phần tử phức tạp (Object) khác kiểu dữ liệu.

			// Cách 1: Sử dụng lớp thuỷ tổ Object
			Object[] objects = new Object[4];
			objects[0] = "Hello";
			objects[1] = 123;
			objects[2] = 3.14;
			objects[3] = true; // Kiểu dữ liệu boolean sẽ được tự động chuyển đổi
					   // thành kiểu dữ liệu Boolean

				// Khi sử dụng, cần thực hiện ép kiểu
				// để truy xuất các thành phần của mảng
				// với đúng kiểu dữ liệu mong muốn
			

			// Cách 2: Sử dụng kế thừa
			class Animal {} // Lớp cha chung
			class Dog extends Animal {} // Lớp con kế thừa
			class Cat extends Animal {} // Lớp con kế thừa
			
			Animal[] animals = new Animal[3];
			animals[0] = new Dog();
			animals[1] = new Cat();
			animals[2] = new Dog();

------------------------------------------------------------

Khi thiết kế hàm để nhận tham số đầu vào là một mảng, ta sẽ có những cách:

	1. Thiết kế hàm chỉ nhận vào một mảng.

		Ví dụ:
			// Thiết kế - Nhận vào một mảng
			public double tinhTongSoThuc(double[] mangSoThuc) {...}

			// Sử dụng - Truyền vào một mảng
			double[] mangSoThuc = {6.9, 7.7, 9.6};
			System.out.println("Tong cac phan tu: " + tinhTongSoThuc(mangSoThuc));

	2. Thiết kế hàm nhận vào một mảng hoặc một dãy số.

		Ví dụ 1: Tính tổng dãy số.

			// Thiết kế - Nhận vào một mảng hoặc một dãy số
			public double tinhTongSoThuc(double... mangSoThuc) {...}

			// Sử dụng 1 - Truyền vào một mảng
			double[] mangSoThuc = {6.9, 7.7, 9.6};
			System.out.println("Tong cac phan tu: " + tinhTongSoThuc(mangSoThuc));

			// Sử dụng 2 - Truyền vào một một dãy số
			System.out.println("Tong day so: " + tinhTongSoThuc(6.9, 7.7, 9.6));

		Ví dụ 2: Hiển thị danh sách những quyển sách.

			// Thiết kế hàm hiển thị thông tin sách
			public void hienThiThongTinSach(Sach... danhSachSach) {...}

			// 
			hienThiThongTinSach(
						new Sach(1, "..."),
						new Sach(2, "..."),
						new Sach(3, "...")
					   );

------------------------------------------------------------

Nhưng dù là mảng đơn giản (Primitive) hay phức tạp (Object), cả hai đều mới chỉ là dạng mảng tĩnh.

Đối với mảng tĩnh, tuy có những ưu điểm về hiệu suất vì các phần tử nằm liền nhau và kích thước sẽ không thể thay đổi (không phải tính toán lại kích thước), nhưng vẫn tồn tại một số nhược điểm:
	- Cần phải khai báo trước số lượng phần tử và kích thước này sẽ là cố định.
	- Vì vậy, nếu muốn thêm hoặc xoá phần tử, bắt buộc phải tạo một mảng mới.

Vì vậy, để tận dụng những ưu điểm của mảng động trong Java, ta sẽ sử dụng Collection Framework.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Mảng là kỹ thuật khai báo cùng một lúc nhiều biến có cùng kiểu,	│
│	cùng tên và nằm sát nhau trong RAM				│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[MẢNG TRUYỀN THỐNG - ĐƠN GIẢN - PRIMITIVE ARRAY]

		// int a[] = new int[5];

	  ―――――――			│		│
	a │	│――――――――――――――――	│―――――――――――――――│
	  ―――――――		│	│ + thuộcTính	│ // public, non-static, final
	  Con trỏ ma cô		│	│―――――――――――――――│
				│	│	0	│ a[4]
				│	│―――――――――――――――│
				│	│	0	│ a[3]
				│	│―――――――――――――――│
				│	│	0	│ a[2]
				│	│―――――――――――――――│
				│	│	0	│ a[1]
				│	│―――――――――――――――│
	a[0] = 68		│	│	68	│ a[0]
				│	│―――――――――――――――│
				│	│ + phươngThức()│
				―――――――>│―――――――――――――――│ 6.000.000
					│		│

----------------------------------------

Không cần quan tâm đến việc đây là biến đơn giản hay phức tạp, có hai cách để khai báo biến:

	1. Lẻ: khai báo từng biến với cùng một kiểu dữ liệu, giữa biến sẽ ngăn cách nhau bằng dấu phẩy.

		Ví dụ: khai báo ba biến độc lập nhau.
			float col1, col2, col3;

	2. Sỉ: khai báo cùng một lúc nhiều biến với cùng một kiểu dữ liệu bằng cách sử dụng cặp ngoặc vuông [].

		Ví dụ: khai báo mảng trong ngôn ngữ C.
			float col[3] = {1, 2, 3};

------------------------------------------------------------

	[MỘT SỐ KHÁC BIỆT TRONG MẢNG CỦA JAVA]

Cấu trúc mảng trong Java sẽ có một số khác biệt so với bên C:

----------------------------------------

	1. Cách khai báo:

		* Ngôn ngữ C: Tuỳ vào loại mảng tĩnh hay động mà sẽ có những cách khai báo khác nhau.

		* Ngôn ngữ Java: Tuỳ vào loại mảng mà sẽ có những cách khai báo khác nhau.
			- Có hai loại:
				1. Ngầm định: Không cần sử dụng từ khoá new[].
				2. Tường minh: Sử dụng từ khoá new[].
			- Trong đó, khi khai báo mảng theo kiểu ngầm định, ta sẽ không được phép ghi kích thước mảng (số lượng phần tử).

		Ví dụ 1: để khai báo mảng trong C.

			// * Mảng tĩnh
			float col[3];
			float col[3] = {1, 2};
			float col[] = {1, 2, 3, 4};

			// * Mảng động
			float* col = (int*)malloc(5 * sizeof(int));
			float* col = (int*)calloc(5, sizeof(int));

		Ví dụ 2: để khai báo mảng trong Java.

			// * Ngầm định - Khai báo sai,
			//		 không được phép khai báo số lượng phần tử
			double a[365];
			double a[365] = {0, 5, 10, 15, 20, 25, 30};

			// * Ngầm định - Khai báo đúng
			double a[] = {0, 5, 10, 15, 20, 25, 30};
			double[] a = {0, 5, 10, 15, 20, 25, 30};

			// * Tường minh - Khai báo sai,
			//		  không được phép khai báo số lượng phần tử
			double a[365] = new double[]{0, 5, 10, 15, 20, 25, 30};
			double a[] = new double[365]{0, 5, 10, 15, 20, 25, 30};

			// * Tường minh - Khai báo đúng
			double a[] = new double[]{0, 5, 10, 15, 20, 25, 30};

			double a[];
			a = new double[]{0, 5, 10, 15, 20, 25, 30};

			double a[] = new double[365];

			double a[];
			a = new double[365];
			a[0] = 5;
			a[1] = 10;
			a[2] = 15;

----------------------------------------

	2. Phân bố vùng nhớ trong RAM để chứa dữ liệu:

		* Ngôn ngữ C: Mảng tĩnh sẽ nằm hoàn toàn trong Stack, còn mảng động thì mới nằm trong Heap.

		* Ngôn ngữ Java: Mảng sẽ được lưu trữ trong Heap nếu được khai báo bên trong hàm, còn con trỏ (biến con trỏ) của mảng sẽ nằm trong Stack.

		Ví dụ 1: vùng nhớ của mảng trong C.

			// Khai báo mảng tĩnh - Nằm trong Stack
			float col[3] = {1, 2, 3};

			// Khai báo mảng động - Nằm trong Heap
			floar* arr = malloc(3 * sizeof(float));

		Ví dụ 2: vùng nhớ của mảng trong Java.

			// Khai báo ngầm định - Phần mảng sẽ nằm trong Heap,
			// còn phần con trỏ (tên mảng) sẽ nằm trong Stack
			double a[] = {1, 2, 3};
			    Stack  │  Heap
			-----------+----------

			// Khai báo tường minh - Phần mảng sẽ nằm trong Heap,
			// còn phần con trỏ (tên mảng) sẽ nằm trong Stack
			double a[] = new double[3];
			double a[] = new double[]{1, 2, 3};
			    Stack  │  Heap
			-----------+----------------------

----------------------------------------

	3. Vượt biên của mảng & Ngoại lệ:

		* Ngôn ngữ C: Thông qua chỉ mục (index), ta vẫn được phép...
			- Sử dụng vòng lặp để duyệt số lượng phần tử nhiều hơn số lượng phần tử đã khai báo trong mảng.
			- Gán hoặc in ra giá trị cho phần tử nằm ngoài mảng.
			- In ra giá trị của phần tử chưa được gán giá trị trong mảng.

		* Ngôn ngữ Java: Đối với các phần tử trong mảng, khai báo bao nhiêu thì chỉ được phép sử dụng bấy nhiêu, KHÔNG cho phép...
			- Truy cập (gán giá trị, in ra...) vào phần tử nằm ngoài mảng, nếu cố tình sẽ gây ra lỗi vượt biên.
			- In ra phần tử chưa có giá trị (dù vẫn nằm trong mảng), nếu cố tình sẽ gây ra lỗi con trỏ NULL.

			* Có thể khống chế ngoại lệ bằng cặp lệnh try-catch() nếu muốn, nhưng sẽ rất tốn sức và vô nghĩa khi không thể can thiệp vào vùng RAM mà ta không xin cấp phát.

		Ví dụ 1: truy cập, duyệt và gán giá trị cho phần tử của mảng trong C.

			// Khai báo mảng chỉ có 7 phần tử,
			// gán trước giá trị cho 6 phần tử
			int a[7] = {0, 5, 10, 15, 20, 25};

			// Nếu in ra một phần tử trong biên
			// nhưng chưa được gán giá trị,
			// ta sẽ nhận được giá trị 0 hoặc rác
			// tuỳ thuộc vào cách mà mảng đã được khai báo
			// (Trong trường hợp này sẽ là 0
			//  vì đây là cách khai báo duy nhất
			//  giúp giá trị mặc định là 0)
			printf("%d", a[6]);

			// Nếu cố tình duyệt nhiều hơn số lượng phần tử đã khai báo,
			// những phần tử "vượt biên" sẽ mang giá trị 0 hoặc rác
			// (Giá trị nhận được sẽ tuỳ vào vùng RAM này
			//  được ứng dụng trước đó sử dụng và để lại)
			for (int i = 0; i < 10; i++)

			// Nếu cố tình gán giá trị cho phần tử ngoài mảng,
			// sau khi gán xong, ta vẫn có thể in giá trị đó ra
			a[69] = 69096;
			printf("%d", a[69]); // Vẫn in ra được 69096

		Ví dụ 2: truy cập, duyệt và gán giá trị cho phần tử của mảng trong Java.

			// Khai báo mảng chỉ có 7 phần tử
			int a[] = {0, 5, 10, 15, 20, 25, 30};

			// Ngay từ đầu đã không có phép quy định số lượng phần tử,
			// nên ta không thể truy cập vào phần tử trong biên
			// nhưng chưa được gán giá trị

			// Nếu cố tình duyệt nhiều hơn số lượng phần tử đã khởi tạo,
			// vẫn sẽ in ra đủ 7 phần tử,
			// nhưng khi đến phần thử thứ 8
			// thì xuất hiện thông báo ngoại lệ
			// (java.lang.ArrayIndexOutOfBoundsException)
			//	-> Có bao nhiêu, sử dụng bấy nhiêu
			for (int i = 0; i < 10; i++) // Văng ra ngoại lệ

			// Nếu cố tình gán giá trị cho phần tử ngoài mảng,
			// ta cũng sẽ gặp ngoại lệ vượt biên
			// và tự động ngắt ứng dụng
			a[7] = 6868;

----------------------------------------

	4. Giá trị mặc định cho những phần tử trong mảng:

		* Ngôn ngữ C: Tuỳ vào cách khai báo mảng (tĩnh & động), mà giá trị mặc định có thể được gán là 0 hoặc giá trị rác.

		* Ngôn ngữ Java: Đối với mảng động, những phần tử thuộc kiểu số đã xin cấp phát nhưng chưa gán giá trị sẽ có giá trị mặc định*.

		Ví dụ 1: khai báo và cấp phát giá trị cho mảng trong C.

			// Khai báo tĩnh - Mảng có 7 phần tử,
			// gán trước giá trị cho 2 phần tử
			int a[7] = {39, 79};

			for (int i = 0; i < 7; i++)
				printf("%d ", p1[i]);
				// Các phần tử [2], [3], [4], [5], [6]
				// sẽ được gán giá trị mặc định là 0

			// Khai báo động - Sử dụng malloc(),
			// gán giá trị cho phần tử thứ [0] và [1]
			int* p1 = (int*)malloc(7 * sizeof(int));
			p1[0] = 39;
			p1[1] = 79;

			for (int i = 0; i < 7; i++)
				printf("%d ", p1[i]);
				// Các phần tử [2], [3], [4], [5], [6]
				// sẽ được gán giá trị là 0 hoặc rác

			// Khai báo động - Sử dụng calloc(),
			// gán giá trị cho phần tử thứ [0] và [1]
			int* p2 = (int*)calloc(7, sizeof(int));
			p2[0] = 39;
			p2[1] = 79;

			for (int i = 0; i < 7; i++)
				printf("%d ", p2[i]);
				// Các phần tử [2], [3], [4], [5], [6]
				// sẽ được gán giá trị mặc định là 0

		Ví dụ 2: khai báo và cấp phát giá trị cho mảng trong Java.

			// Khai báo mảng chỉ có 7 phần tử
			double a[] = new double[7];

			// Gán giá trị cho phần tử thứ [0] và [1]
			a[0] = 39;
			a[1] = 79;
			
			for (int i = 0; i < 7; i++)
				printf("%d ", p2[i]);
				// Các phần tử [2], [3], [4], [5], [6]
				// sẽ được gán giá trị mặc định là 0
				// vì đây là mảng số

----------------------------------------

	5. Dung lượng thực tế (số Byte) được cấp phát cho mảng:

		* Ngôn ngữ C: Dù là cấp phát động...
			- Dung lượng (Số Byte) sẽ được cấp phát theo đúng số lượng mà người dùng đã khai báo.
			- Kích thước của con trỏ là cố định theo kiến trúc của hệ điều hành.

		* Ngôn ngữ Java: Là một sự kết hợp giữa biến đơn giản và phức tạp (đối tượng).
			- Vùng RAM được cấp sẽ rộng hơn so với những gì đã được khai báo.
			- Phần dư ra được sử dụng để chứa thuộc tính (length) và phương thức (toString()...) của mảng với phạm vi truy cập là public.
			- Cả một vùng RAM này sẽ được gọi là đối tượng và được quản lý bằng con trỏ - tên mảng.
				+ Dù toàn bộ mảng được xem là đối tượng, nhưng bên trong vẫn được phép chứa những giá trị đơn giản.
				+ Giống như việc những thuộc tính của đối tượng cũng được phép là những giá trị đơn giản.

		Ví dụ [Bên lề]: sự linh hoạt khi sử dụng tên mảng và tên của các phần tử trong mảng Java.

			// Khai báo mảng chỉ có 7 phần tử
			double a[] = new double[7];

			// Sử dụng chỉ số 
			// để trực tiếp gán giá trị cho phần tử thứ [0]
			a[0] = 39;

			// Sử dụng trực tiếp tên mảng
			// để gọi thuộc tính length
			// và lấy ra số lượng phần tử của mảng
			a.length;

			// Sử dụng trực tiếp tên mảng
			// để ngầm gọi phương thức toString()
			// và in ra địa chỉ hệ 16 của mảng
			System.out.println("The array has: " + a);

------------------------------------------------------------

	[KHAI BÁO MẢNG TRONG JAVA]

Vì mảng trong Java luôn là mảng động, nên sau khi được khai báo bên trong hàm, mảng sẽ được cấp phát một vùng nhớ trong Heap, còn tên mảng (biến con trỏ) sẽ nằm trong Stack.

Có hai cách để khai báo mảng trong Java (cặp dấu ngoặc vuông nằm ở đâu không quan trọng):

----------------------------------------

	1. Ngầm định (Implicit) khai báo số lượng phần tử của mảng, ngầm hiểu phía sau là một vùng new[].
		- Chỉ việc gán giá trị, sẽ ngầm hiểu phía trước đó là một vùng new[].
		- Lúc này, số lượng phần tử sẽ tương đương với số phần tử đã được gán giá trị.

		* Cú pháp: Ngầm hiểu có new[].

			// Vừa khai báo, vừa khởi tạo giá trị,
			// nhưng không được phép ghi số lượng phần tử
			kiểu-dữ-liệu tênMảng[] = {khai-báo-các-phần-tử};

			Ví dụ: Mảng đơn giản.
			
				// Mảng sẽ có 7 phần tử
				double a[] = {0, 5, 10, 15, 20, 25, 30};
				double[] a = {0, 5, 10, 15, 20, 25, 30};

----------------------------------------

	2. Tường minh (Explicit) khai báo số lượng phần tử của mảng, ghi rõ tạo mới một vùng new[].
		- Công dụng cũng giống như hàm calloc() trong ngôn ngữ C, khi có thể xin cấp phát động một vùng RAM trong Heap, và toàn bộ giá trị trong vùng RAM này cũng sẽ được gán giá trị mặc định*.
		- Vẫn trả về địa chỉ toạ độ, tên mảng có thể sử dụng để truy xuất các thuộc tính và phương thức mặc định của mảng.

		* Cú pháp: Tường minh new[].

			// * Gán giá trị tuỳ ý,
			//   nhưng không ghi số lượng phần tử
			1. Khai báo gộp - Vừa khai báo, vừa khởi tạo giá trị.
			kiểu-dữ-liệu tênMảng[] = new kiểu-dữ-liệu[]{khai-báo-các-phần-tử};

			2. Khai báo tách dòng - Tạo mảng trước, nắm toạ độ địa chỉ sau.
			kiểu-dữ-liệu tênMảng[];
			tênMảng = new kiểu-dữ-liệu[]{khai-báo-các-phần-tử};

			// * Gán toàn bộ giá trị trong mảng với giá trị mặc định
			//   và được phép ghi số lượng phần tử
			1. Khai báo gộp - Vừa khai báo, vừa khởi tạo giá trị.
			kiểu-dữ-liệu tênMảng[] = new kiểu-dữ-liệu[số-phần-tử];

			2. Khai báo tách dòng - Tạo mảng trước, nắm toạ độ địa chỉ sau.
			kiểu-dữ-liệu tênMảng[];
			tênMảng = new kiểu-dữ-liệu[số-phần-tử];

			Ví dụ 1: Mảng đơn giản.

				// Mảng sẽ có 7 phần tử dù không khai báo số lượng phần tử
				double a[] = new double[]{0, 5, 10, 15, 20, 25, 30};

				double[] a;
				a = new double[]{0, 5, 10, 15, 20, 25, 30};

				// Nhận giá trị mặc định cho toàn bộ phần tử
				double a[] = new double[7];

				double a[];
				a = new double[7];

				//	Thay đổi giá trị của từng phần tử
				a[0] = 5;
				a[1] = 10;
				a[2] = 15;
				//	Những phần tử còn lại
				//	vẫn sẽ nhận giá trị mặc định

			Ví dụ 2: Mảng đối tượng.

				// Mảng sẽ có 5 phần tử - 5 con trỏ - 5 toạ độ đối tượng
				Student arr[] = new Student[]{
						new Student("SE9", "CHÍN", 1999, 9),
						new Student("SE6", "SÁU", 1996, 6),
						new Student("SE7", "BẢY", 1997, 7),
						new Student("SE3", "BA", 1993, 3),
						new Student("SE5", "NĂM", 1995, 5)
							     };

				// Mảng sẽ có 2 phần tử - 2 con trỏ - 2 toạ độ đối tượng
				Student arr[];
				arr = new Student[]{
					new Student("SE6", "SÁU", 1996, 6),
					new Student("SE9", "CHÍN", 1999, 9),
						   };

				// Nhận giá trị mặc định (NULL) cho toàn bộ phần tử
				Student arr[] = new Student[5];

				Student arr[];
				arr = new Student[5];

				//	Thay đổi giá trị của từng phần tử
				arr[1] = new Student("SE6", "SÁU", 1996, 6);
				arr[0] = new Student("SE9", "CHÍN", 1999, 9);
				//	Những phần tử còn lại
				//	vẫn sẽ nhận giá trị mặc định

------------------------------------------------------------

	[DUYỆT MẢNG BẰNG CÂU LỆNH VỚI MỌI (∀) - FOR EACH]

Có hai cách [cơ bản] nhất để duyệt từng phần tử trong mảng:

----------------------------------------

	1. [Truyền thống] Sử dụng chỉ số để đếm từng phần tử và lấy giá trị ra.
		- Yêu cầu phải biết trước số lượng phần tử tối đa trong mảng thì mới có thể duyệt mảng (để tạo nên điều kiện dừng lặp), vì nếu duyệt lố thì sẽ gặp ngoại lệ.
		- Nhưng nếu muốn duyệt số lượng phần tử bằng hoặc ít hơn thì vẫn có thể sử dụng cách này.

		Ví dụ: đếm và duyệt số lượng phần tử ≤ số lượng phần tử tối đa.

			// Khai báo mảng gồm 7 phần tử
			double v[] = {0, 5, 10, 15, 20, 25, 30};

			// Duyệt từng phần tử trong mảng
			for (int i = 0; i < 7; i++)
				System.out.println("v[" + i + "]: " + v[i]);

			// Duyệt số lượng phần tử ít hơn
			// số lượng phần tử tối đa trong mảng
			for (int i = 0; i < (7 - 1); i++)

----------------------------------------

	2. [Hiện đại] Duyệt một loạt từ trái sang phải (từ đầu đến cuối) bằng với mọi (∀).
		- Sẽ duyệt hết sạch mảng (bằng một biến đếm ngầm) và không yêu cầu phải biết trước số lượng phần tử trong mảng (loại bỏ được điều kiện dừng trong vòng lặp truyền thống).
		- Cách để đi / duyệt hết tất cả các phần tử trong tập hợp, để sau đó thực hiện thêm những tính toán khác (ví dụ: lấy những phần tử có giá trị ≥ một giá trị nào đó...).

		* Mệnh đề với mọi (∀) trong toán học:

			Cho tập hợp các số tự nhiên (natural)
			N = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10...}
			Với mọi x (là số tự nhiên) thuộc tập hợp N | ∀ x ∈ N

			* Câu hỏi: biết tập hợp N gồm nhiều giá trị bên trong,
				   vậy nếu ∀ x ∈ N, thì x có thể mang giá trị là mấy?
					-> x có thể là bất kì phần tử nào trong tập hợp N,
					   mà bên trong mỗi phần tử trong tập hợp
					   sẽ chứa một giá trị là số tự nhiên nào đó.
						=> x có thể là bất kì giá trị nào trong tập hợp N.
				   (Nhưng x bắt buộc phải là số tự nhiên
				    để có thể mang giá trị trong tập hợp - môn đương hộ đối).

						∀         x ∈ N
					      ≈	∀ integer x ∈ N
					
					// x đi qua từng phần tử,
					// sau đó mới lấy được giá trị
					x = 0	| Số tự nhiên thứ 1: x = N[0] = 0
					x = 1	| Số tự nhiên thứ 2: x = N[1] = 1
					x = 2	| Số tự nhiên thứ 3: x = N[2] = 2
					...

			* Kết luận: với mọi (∀) là kỹ thuật quét qua toàn bộ mảng / tập hợp các giá trị (quét từ đầu đến cuối), để lấy toàn bộ các phần tử / giá trị trong đấy ra.
				- Sử dụng x là một con số tự nhiên để duyệt qua tất cả các phần tử của tập hợp các số tự nhiên.
				- x có thể là từng giá trị trong N, có thể là bất kì giá trị nào mà không kể thứ tự.
				-> Đi qua hết các phần tử, lấy ra từng phần tử trong tập hợp ra và tương tác với những giá trị trong những phần tử đó.

				// X có thể là từng phần tử thứ N[i],
				// mà trong biến N[i] sẽ có chứa dữ liệu
					x = N[0] | Lấy số tự nhiên thứ 1 trong tập hợp N
					x = N[1] | Lấy số tự nhiên thứ 2 trong tập hợp N
					...
					x = N[i] | Lấy số tự nhiên thứ i trong tập hợp N

--------------------

		* Mệnh đề với mọi (∀) trong lập trình:

			Mảng là tập hợp các phần tử / giá trị có cùng tên.
				- Trong mảng đơn giản, từng phần tử cũng là một biến đơn giản, nên chỉ có thể sử dụng trực tiếp, không thể sử dụng dấu chấm.
				- Ta có thể sử dụng khái niệm với mọi (∀) để duyệt qua toàn bộ mảng và lấy ra từng phần tử có trong mảng.

			* Cú pháp: for (kiểu-dữ-liệu tênBiếnĐạiDiện : tênMảng)

				Ví dụ: Sử dụng forearch để lấy hết từng phần tử trong mảng.

					double v[] = {0, 5, 10, 15, 20, 25, 30};
					for (double x : v)

			* Giải thích:

				// Với mọi biến x là kiểu double thuộc tập hợp v
				// (tập hợp v sẽ lại gồm nhiều phần tử là số thực),
				// x có quyền bằng từng phần tử về giá trị

				// x sẽ tương đương với từng phần tử trong tập hợp v
				// (Từ phần tử đầu tiên, đến phần tử cuối cùng),
				// ta có thể thoải mái duyệt
				// mà không cần quan tâm đến số lượng phần tử
				// (điều kiện dừng lặp)
				for (double x : v) { // ∀ x ∈ v

					// x không phải (không bằng) tập hợp v,
					// mà x là từng phần tử (lẻ) chứa trong mảng (sỉ) v
					// (* Từng phần tử: giá trị của v
					//		    tại vị trí [0], [1], [2]...)
					//	-> Lấy từng hộp sữa lẻ trong một lốc sữa sỉ

					// In ra từng phần tử v[i] -> In ra từng x
					System.out.print(x + " "); // ≈ v[i]
					
					// x = v[0]
					// x = v[1]
					// x = v[2]
					// ...
					// x = v[i]
				}

			-> x đại diện cho từng phần tử trong mảng,
			   mà từng phần tử lại chứa giá trị.

--------------------

* Lưu ý 1: Nếu vẫn muốn sử dụng vòng lặp for truyền thống, nhưng lại không biết kích thước của mảng, ta vẫn có thể sử dụng tên mảng kèm thuộc tính length của mảng.

	Ví dụ: Sử dụng tên mảng kèm thuộc tính length của mảng.

		double arr[] new double[333];
		for (int i = 0; i < arr.length; i++) {...}

* Lưu ý 2: Vòng lặp foreach vẫn có thể được áp dụng cho ArrayList mà không cần phải thay đổi cú pháp và cách thức sử dụng, vì vẫn mang ý nghĩa duyệt theo từng phần tử một trong mảng.

------------------------------------------------------------

	[TÊN MẢNG & CON TRỎ]

Tên mảng bản thân là một biến đối tượng / biến con trỏ (biến ma cô), trỏ đến toạ độ vùng RAM trong Heap khi sử dụng new[] để đúc một loạt các biến trong mảng.

	- Giá trị trả về sẽ là địa chỉ (Byte) ở đáy mảng (nhưng không phải phần tử đầu tiên).
		+ Điều đặc biệt, mảng lại được cấp dư vùng nhớ để chứa thêm thuộc tính và phương thức public.
		+ Đáy của mảng lúc này lại là vùng Byte chứa các phương thức, chứ không phải là phần tử đầu tiên trong mảng.

	- Có nhiệm vụ quản lý một loạt các biến (đơn giản hoặc phức tạp) hiện đang nằm bên trong vùng Heap.

	- Bên cạnh số lượng Byte đã cấp phát để chứa những giá trị đơn giản, vùng nhớ này còn được cấp dư một số Byte để chứa các thuộc tính và phương thức public, nhờ đó mà ta có thể tương tác với mảng thông qua tên mảng.

	- Muốn tương tác với mảng thì phải tương tác thông qua tên mảng.
		+ Vì tên mảng lúc này đã là biến con trỏ / biến đối tượng (lưu địa chỉ), được tạo ra nhờ từ khoá new[].
		+ Trong mảng đơn giản, không thể lấy từng phần tử trong mảng ra để tương tác, vì từng phần tử lúc này chỉ là các biến đơn giản, nghĩa là những biến trực tiếp chứa giá trị với mục đích sử dụng ngay.
		+ Trong khi đó, đối với mảng phức tạp, vì mỗi phần tử sẽ lại là một đối tượng (địa chỉ) nên sẽ có thể chấm tiếp để tương tác với thuộc tính và phương thức của đối tượng đó.

	- Trong một đối tượng, tên đối tượng cũng là biến con trỏ.
		+ Nhờ có biến con trỏ (biến đối tượng) này mà ta có thể tương tác với những thông tin của đối tượng, mỗi thuộc tính của đối tượng có thể sẽ có khác nhau về kiểu dữ liệu.
		+ Nhưng trong mảng thì khác, toàn bộ giá trị của mảng phải đều có cùng một kiểu dữ liệu. Vì vậy, ta không thể nào sử dụng tên mảng để tương tác với từng phần tử trong mảng, mà chỉ có thể tương tác với thuộc tính và phương thức public đã sẵn có của mảng.
		+ Còn về các phần tử của mảng, ta có thể sử dụng trực tiếp (gán giá trị, thay đổi giá trị...) mà không cần thông qua getter() và setter(), điều này sẽ giúp việc lưu trữ nhiều biến có cùng kiểu được hiệu quả hơn.

	-> Tên mảng là biến con trỏ "ma cô", trỏ đến và quản lý một vùng đối tượng (object). Bên cạnh các giá trị của mảng, vùng đối tượng này còn chứa thêm các thuộc tính và phương thức public.

		Ví dụ:
			// Sử dụng đúng, vì biến con trỏ "arr"
			// đang chứa giá trị là địa chỉ của cả một vùng RAM
			arr.length;

			// Sử dụng sai, vì phần tử arr[0]
			// bản thân đã là giá trị và có thể sử dụng được ngay
			arr[0].length;

			// Sử dụng đúng, vì phần tử arr[0]
			// bản thân đã là giá trị và có thể sử dụng được ngay
			// (bình đẳng như mọi biến khác)
			arr[0] = 10;

----------------------------------------

Biến ma cô quản lý "đàn em" thông qua dấu chấm.

	Ví dụ:
		// tênMảng.length: thuộc tính của riêng từng mảng
		//	- Trả về kích thước tối đa mới nhất của mảng
		//	- Hiện đang có tổng cộng bao nhiêu "đàn em" trong băng đảng

		// Khai báo mảng có 365 phần tử
		double arr[] = new double[365];

		// Xem số phần tử của mảng
		System.out.print("Số phần tử trong mảng: " + arr.length);

		// - Là hằng số để không cho phép thay đổi giá trị
		//   (muốn thay đổi thì phải tự tạo một vùng mới,
		//    nhưng thà cấp mới chứ không cơi nới)
		//
		// - Nhưng tên biến thuộc tính "length" lại không được viết hoa,
		//   vì đây chỉ là một biến thông thường
		//   và sẽ linh hoạt thay đổi giá trị
		//   tuỳ theo kích thước hiện đang có của từng mảng
		//
		// - Là thuộc tính non-static,
		//   giúp đảm bảo mỗi mảng sẽ có một nơi riêng biệt
		//   để chứa kích thước
		//	-> Không cho thay đổi trong mảng,
		//	   nhưng giữa các mảng thì được phép có những giá trị khác nhau
		//	   (Anh cục súc với cả thể giới, nhưng lại dịu dàng với một mình em)

--------------------------------------------------------------------------------

[MẢNG ĐỐI TƯỢNG - PHỨC TẠP - OBJECT ARRAY]

		// Object objectName[] = new Object[5];

	  ―――――――		│		│
	a │	│――――――――	│―――――――――――――――│
	  ―――――――	│	│ + thuộcTính	│ // public, non-static, final
	  Con trỏ	│	│―――――――――――――――│
	  ma cô		│	│		│ objectName[4]
			│	│―――――――――――――――│
			│	│		│ objectName[3]
			│	│―――――――――――――――│
			│	│		│ objectName[2]
			│	│―――――――――――――――│
			│	│		│ objectName[1]
			│	│―――――――――――――――│
			│	│		│ objectName[0] ―――――――――
			│	│―――――――――――――――│			│
			│	│ + phươngThức()│			│
			―――――――>│―――――――――――――――│ 6.000.000		│
				│		│			│
									│
									│
									│
								―――――――――――――――――
								│     TênLớp	│
								│―――――――――――――――│
								│ + thuộcTính	│
								│ + ...		│
								│―――――――――――――――│
								│ + phươngThức()│
								│ + ...		│
								―――――――――――――――――

Vẫn giữ nguyên khái niệm mảng là kỹ thuật khai báo nhiều biến cùng một lúc.
	- Nếu mảng đơn giản là tập hợp các giá trị đơn giản, thì mảng đối tượng cũng là tập hợp các con trỏ.
	- Từng con trỏ trong mảng (đại diện cho từng phần tử) sẽ trỏ đến một đối tượng (vùng RAM - new()) cụ thể.
	- Khi xin cấp phát số lượng phần tử bằng new[] thì thực chất đã có sẵn số lượng con trỏ rỗng (Null) bằng với số lượng phần tử đã xin cấp phát; lúc này, chỉ cần đợi có một vùng new() nào đó để trỏ đến.
	- Nếu chấm...
		+ tênMảng: Hiển thị các thuộc tính và phương thức của toàn mảng.
		+ tênBiếnConTrỏ[chỉ-số]: Hiển thị các thuộc tính và phương thức của riêng từng đối tượng.

	Ví dụ 1: So sánh cách khai báo giữa mảng đơn giản và phức tạp.

		// Khai báo một mảng đơn giản để lưu 50 số nguyên
		int a[] = new int[50];
		arr[0] = 5;
		arr[1] = 10;

		// Khai báo một mảng phức tạp để lưu 50 sinh viên
		Student s[] = new Student[50];
		s[0] = new Student("185123456", "AN NGUYỄN", 2000, 5.6);
		s[1] = new Student("185654321", "BÌNH LÊ", 2000, 6.5);
			// Từng phần tử trong mảng là một biến đối tượng (biến con trỏ),
			// vì vậy, cần trỏ đến một vùng new().

	Ví dụ 2: Cách thức hoạt động của mảng đối tượng trong thực tế.

		- Trong một bệnh viện....
			+ Bác sĩ và Y tá sẽ có phòng làm việc riêng.
			+ Các Bệnh nhân nội trú đang được được điều trị và dưỡng bệnh tại một phòng riêng.
			+ Bệnh viện và danh sách bệnh nhân đang điều trị nội trú sẽ là cầu nối giữa các bên.
			+ Y tá sẽ là người nắm được danh sách bệnh nhân (con trỏ tham chiếu), mỗi bệnh nhân sẽ tương ứng với một bệnh nhân ở ngoài đời thực và đang điều trị tại một phòng bệnh nào đó.
			+ Để hỏi tình hình sức khoẻ sơ bộ của Bệnh nhân, Bác sĩ chỉ cần thông qua tên Bệnh nhân trong danh sách của Y tá, không cần phải trực tiếp đến phòng bệnh.

		- Trong một lớp học online...
			+ Giảng viên sẽ dạy học tại một không gian riêng.
			+ Sinh viên sẽ ngồi học tại một không gian riêng.
			+ Nền tảng họp trực tuyến và danh sách sinh viên đang tham gia học sẽ là cầu nối giữa các bên.
			+ Giảng viên sẽ nhìn danh sách sinh viên đang trực tuyến để gọi, lập tức một sinh viên tương ứng trong danh sách sẽ phải trả lời.

------------------------------------------------------------

	[CON TRỎ NULL - NULL POINTER]

Byte ở vị trí đầu tiên trong RAM còn được gọi là Byte thứ 0 (Byte NULL).

	- Tại đây, toạ độ vùng RAM sẽ là 0 và chứa giá trị là 0 (0000 0000).

	- Byte NULL cũng có địa chỉ, nên những biến đối tượng / biến con trỏ hoàn toàn có thể trỏ vào vùng này, vì những biến đối tượng / biến con trỏ cũng chỉ cần một địa chỉ vùng RAM là đủ.

	- Vì vùng RAM này chỉ có duy nhất một Byte và chứa giá trị là 0, nên nếu cố tình trỏ vào mà gọi thông tin để xử lý thông qua dấu chấm thì sẽ nhận về ngoại lệ con trỏ NULL (NullPointerException).

	- Mục đích là để con trỏ "hạ cánh" xuống đáy RAM, giúp cắt một con trỏ khi không còn muốn trỏ vào vùng RAM, nhưng cũng lại không muốn tạo mới một vùng new().
		-> Kỹ thuật cắt đứt dây chuông để ân đoạn nghĩa tuyệt.

	- Khi một vùng nhớ đã không còn được trỏ đến (vì con trỏ đã trỏ đến NULL), thì sẽ bị bộ thu gom rác dọn dẹp.

	-> "Hạ cánh nơi anh", trỏ xuống "đáy xã hội" (vùng NULL) của RAM, tối thui và không thấy gì.

		Ví dụ: gán NULL cho một con trỏ đơn lẻ.

			Student x;
			x = new Student("SE123456", "AN NGUYỄN", 2000, 5.6);
			x.showProfile();

			// Vì x chỉ cần một toạ độ vùng RAM,
			// nên có thể gán x = toạ độ Byte đầu tiên trong toàn RAM
			// (gán địa chỉ của con số 0 ở đáy RAM vào biến con trỏ)
			x = null;
				// Không gán số 0 trực tiếp cho con trỏ
				// vì như vậy sẽ được hiểu là gán giá trị số nguyên,
				// khi mọi con số nguyên sẽ được hiểu là integer

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Vùng new() sẽ tự động đi xuống "đáy xã hội" nếu bị mất con trỏ	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

* Nguyên tắc cơ bản khi chơi với mảng đối tượng:

	- Đối với mảng đối tượng, giá trị mặc định cho từng phần tử cũng sẽ là 0.
		+ Mà biến con trỏ sẽ hiểu 0 được gán mặc định ở đây là địa chỉ của vùng Byte thứ 0 (Byte NULL).
		+ Vì vậy, toàn bộ những biến đã được khai báo mà chưa gán giá trị sẽ được trỏ về vùng NULL.

	- Giá trị mặc định sẽ được tự động gán ngay sau câu lệnh new[], vì vậy, ta vẫn có thể sử dụng tên con trỏ (tên phần tử trong mảng) để gọi các thuộc tính và phương thức, nhưng tất nhiên sẽ bị lỗi ngoại lệ vì con trỏ đang trỏ đến vùng NULL.

	- Nếu có bất kì phần tử nào trong mảng chưa được gán giá trị, thì không được sử dụng for để duyệt hết toàn bộ mảng, vì những phần tử chưa được gán giá trị sẽ được mặc định gán con trỏ NULL (trỏ xuống đáy RAM) và ném ra ngoại lệ.
	
	- Vì vậy, chỉ for đến đúng số lượng phần tử đã gán giá trị.
		+ Sử dụng thêm biến đếm (count) để đếm xem có bao nhiêu phần tử đã được gán giá trị.
		+ Lúc này, foreach sẽ hoàn toàn không thể sử dụng được, vì câu lệnh này sẽ duyệt từ đầu đến cuối mảng (bao gồm cả những phần tử đang là NULL).

------------------------------------------------------------

* Lưu ý 1: Khi so sánh, việc so sánh giữa các giá trị (>, <=, <, <=, ==, !=) chỉ dành cho các biến đơn giản.
	- Lúc này, sử dụng tên mảng hoặc nếu phần tử mảng là con trỏ (lưu địa chỉ) thì việc so sánh giữa các giá trị này sẽ trở nên vô nghĩa, vì chúng đang trỏ đến địa chỉ.
	- Vì vậy, ta bắt buộc phải dựa vào các thuộc tính bên trong mà các đối tượng đều có (lấy thông qua dấu chấm), nhưng còn tuỳ vào ngữ cảnh mà một thuộc tính nhất đính sẽ được chọn ra để làm tiêu chí so sánh.
	- Để đáp ứng được nhu cầu so sánh giữa các đối tượng, hàm so sánh nên được xây dựng và đặt bên trong đối tượng - tính đóng gói.
	- Nhưng con trỏ NULL lại được ngầm hiểu là số 0, nên đây là trường hợp duy nhất được phép sử dụng các toán tử so sánh để so sánh.
	-> So sánh là phải cụ thể, không thể so sánh địa chỉ vùng RAM.
		(So sánh con trỏ là vô nghĩa.)

		Ví dụ: Cho hai mảng sinh viên.

			Student arr1[] = new Student[2];
			Student arr2[] = new Student[3];

			// So sánh SAI
			arr1 > arr2
			arr1[i] > arr2[j]

			// So sánh ĐÚNG - Dựa trên đặc điểm của đối tượng
			arr1[i].getGpa() > arr2[j].getGpa()

			// So sánh ĐÚNG - Trường hợp ngoại lệ của NULL
			if (arr1 == null) {...}
	
	- Khi so sánh dựa trên một đặc điểm nào đó của các đối tượng, sẽ có các loại hàm kiểm tra và so sánh kết quả:

		equal(): Kết quả trả về là True hoặc False; đúng nhận, sai cãi.
			-> Tớ có bằng (equal) cậu không?
				- Có (True)
				- Không (False)

		compareTo(): Kết quả trả về là một số nguyên (int); cho biết lớn hơn, bé hơn hoặc bằng.
			-> Tớ so với (compare to) cậu như thế nào?
				- Hơn (1 hoặc > 0)
				- Huề (0)
				- Thua (-1 hoặc < 0)

		Ví dụ 1: Kiểm tra và so sánh trong thực tế.

			- Quang Trung – Nguyễn Huệ là anh em?
			- Lý Nhân Tông (Càn Đức) là vị vua có thời gian trị vì lâu nhất trong lịch sử phong kiến Việt Nam?
			- Lý Chiêu Hoàng là nữ hoàng của đế quốc Đại Việt?
				-> equal()

			- Nhà Hậu Lê có thời gian tồn tại lâu hơn so với Nhà Hậu Lý?
			- Nhà Lý thịnh vượng hơn Nhà Trần?
				-> compareTo()

			- Cô ấy / Anh ấy có tốt bằng người yêu cũ của cậu không?
				-> equal()
			- Cô ấy / Anh ấy tốt cỡ nào so với người yêu cũ của cậu?
				-> compareTo()

			- Anh thích em, đúng không?
				-> equal()
			- Anh có thích em như em đang thích anh?
				-> compareTo()

		Ví dụ 2: Kiểm tra và so sánh đối tượng.

			// Lớp bao bọc kiểu số nguyên
			Integer yob1 = 2000;
			Integer yob2 = 2003;

			// So sánh bằng hàm equals()
			if (yob1.equals(yob2) == true) {...}

			// So sánh bằng hàm compareTo()
			if (yob1.compareTo(yob2) == 0) {...}

* Lưu ý 2: Đối với chuỗi, vì cũng là con trỏ (vùng new() riêng để lưu toạ độ), nên việc so sánh sẽ trở nên phức tạp hơn khi phải sử dụng thêm các hàm so sánh chuyên dụng để thực sự lấy được giá trị nằm bên trong, 

	Ví dụ: So sánh chuỗi.

		String s1 = "Thuận";
        	String s2 = "thuan";
        
		// Không thể so sánh được
		if (s1 > s2)
			System.out.println("Chuỗi 1 > Chuỗi 2");
		else
			System.out.println("Chuỗi 1 <= Chuỗi 2");

		// Sử dụng các hàm chuyên dụng
		int result = s1.compareTo(s2);
		
		if (result > 0)
			System.out.println("Chuỗi 1 > Chuỗi 2");
		else
			System.out.println("Chuỗi 1 <= Chuỗi 2");


	- Vì chuỗi cũng là đối tượng, mà đã là đối tượng thì vẫn có thể chấm tiếp để gọi thuộc tính và phương thức, cho đến khi nào không trả về đối tượng nữa thì sẽ dừng.
		-> Còn là đối tượng, còn chấm được.

		Ví dụ: Điểm dừng của dấu chấm.

			// Dừng vì hàm charAt() sẽ trả về một số nguyên - biến đơn giản
			s[0].getName().toUpperCase().toLowerCase().charAt(0);

--------------------------------------------------------------------------------

[TỔNG KẾT VỀ DẤU CHẤM TRONG MẢNG]

tênMảng: là biến con trỏ (biến ma cô), được sử dụng để quản lý tất cả các phần tử trong mảng, biết những thông tin chung chung của toàn mảng. Nếu muốn hỏi thông tin chi tiết thì phải hỏi thông tin của từng phần tử trong mảng.

	biếnĐơnGiản: là biến chứa bên trong loại giá trị có thể sử dụng được ngay.

	biếnĐốiTượng: là biến con trỏ, trỏ đến (chứa bên trong là) địa chỉ của vùng new().

	Ví dụ:
		// 1. Khai báo mảng đơn giản (primitive array)
		int[] arr = new int[3];
		arr[0] = 5;
		arr[1] = 10;
		arr[2] = 15;

			// arr. -> Xổ ra thuộcTính và phươngThức() của mảng
			// arr[0]. -> Không xổ ra gì, vì đây là biến đơn giản

		// 2. Khai báo mảng đối tượng (object array)
		Student[] s = new Student[3];
		s[0] = new Student("SE123456", "AN NGUYỄN", 2001, 5.6);
		s[1] = new Student("SE123457", "BÌNH LÊ", 2000, 5.7);
		s[2] = new Student("SE123458", "CƯỜNG VÕ", 1999, 5.8);

			// s. -> Xổ ra thuộcTính và phươngThức() của mảng
			// s[0]. -> Xổ ra thuộcTính và phươngThức() của riêng đối tượng

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Vẫn còn là đối tượng thì vẫn còn chấm được	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[CÁC THAO TÁC VỚI MẢNG TRONG JAVA]

------------------------------------------------------------

[SẮP XẾP MẢNG]

Về nguyên tắc, có thể sắp xếp mảng theo cách thủ công dựa trên một tiêu chí và giá trị sẵn có.
	- Nhưng trong thực tế, dữ liệu không phải lúc nào cũng có sẵn mà có thể được từ từ đưa vào sau.
	- Vì vậy, ta cần phải có một cơ chế sắp xếp tự động và luôn đúng cho mọi trường hợp ở hiện tại và tương lai.

Việc so sánh giữa các đối tượng không phải là trực tiếp so sánh các con trỏ.
	- Thực chất (nên) là so sánh giữa các thuộc tính chung mà các đối tượng đều có.
	- Các đối tượng cũng nên tự có hàm so sánh bên trong mình, để cho phép so sánh với những đối tượng cùng loại.

Thuật toán chung: So sánh và hoán đổi vị trí.
	- Sử dụng một biến tạm cũng là kiểu con trỏ.
	- Gán một trong hai giá trị cần hoán đổi sang biến tạm.
	-> Hoán đổi toạ độ / địa chỉ của biến con trỏ.

	Ví dụ 1: Sắp xếp hai sinh viên theo điểm trung bình.

		// Tạo mảng gồm hai sinh viên
		// (Vì nếu muốn sắp xếp được thì phải ở chung mảng)
		Student s[] = new Student[2];
		s[0] = new Student("SE123456", "AN NGUYỄN", 2001, 9.0);
		s[1] = new Student("SE123457", "BÌNH LÊ", 2000, 5.0);

		// Sử dụng câu lệnh tạo biến đối tượng để tạo ra một con trỏ tạm,
		// sau đó lưu giá trị trước khi hoán đổi của s[0]
		Student t = s[0]; // Hai con trỏ t và s[0]
				  // đang cùng trỏ về vùng "AN NGUYỄN"
		s[0] = s[1];
		s[1] = t;

	Ví dụ 2: Sắp xếp mảng danh sách các sinh viên theo điểm trung bình.
	
		// Sắp xếp mảng tăng dần,
		// chỉ hoán đổi giá trị mà các biến con trỏ đang nắm giữ,
		// vùng new() chứa thông tin vẫn sẽ không bị ảnh hưởng
		for (int i = 0; i < (arr.length - 1); i++)
			for (int j = i + 1; j < arr.length; j++)
				if (arr[i].getGpa() > arr[j].getGpa()) {
					Student t = arr[i];
					arr[i] = arr[j];
					arr[j] = t;
				}

==========================================================================================

[COLLECTION FRAMEWORK]

Để làm việc được với nhiều dữ liệu (đối tượng), cụ thể là lưu trữ, quản lý và xử lý nhiều đối tượng cùng loại (kế thừa hoặc Interface).
	- Sử dụng mảng là một trong những cách tiện lợi nhất dành cho các đối tượng cùng loại.
	- Mảng cũng được xem như là một đối tượng để chứa nhiều con trỏ bên trong.
	- Khi sử dụng mảng truyền thống, dù chưa sử dụng hết số lượng phần tử tối đa, nhưng vẫn phải xin cấp phát sẵn một vùng đủ rộng để chứa dữ liệu, hoặc nếu đã sử dụng hết thì lại không thể cơi nới thêm được.
	- Vì vậy, ta cần một loại mảng đặc biệt cho phép linh hoạt về kích thước, đồng thời hỗ trợ sẵn luôn một số thao tác trên mảng thay vì phải tự mình thiết kế như ở mảng truyền thống.

Mục tiêu chung của mảng là để chứa được nhiều dữ liệu cùng một lúc.
	- Thời gian mà dữ liệu xuất hiện có thể không cùng một lúc.
	- Loại dữ liệu mà mảng chứa đựng có thể là giá trị trực tiếp hoặc tham chiếu đến nơi thật sự chứa giá trị.

Nếu xem mảng giống như một chiếc túi đựng đồ, để có thể chứa được đồ bên trong túi, ta sẽ cần:
	1. Đi mua túi: Sử dụng câu lệnh new[] để tạo sẵn một vùng không gian rỗng.
	2. Mua đồ để thêm vào túi: Sử dụng câu lệnh new() để tạo mới một món đồ.
	3.1. Túi truyền thống: Tự tay trực tiếp nhét đồ vào trong tủ.
	3.2: Túi thần kỳ: Sử dụng hàm chuyên biệt để cất đồ vào trong túi.

--------------------------------------------------------------------------------

[CÁC DẠNG MẢNG]

------------------------------------------------------------

0. Mảng đơn giản (Primitive Array): Chứa bên trong danh sách các giá trị có thể sử dụng trực tiếp.

------------------------------------------------------------

1. Mảng phức tạp (Object Array): Tạm xem như một chiếc túi đựng dữ liệu, nhưng vẫn còn tồn tại hạn chế về kích thước và cách hành xử.

	- Là loại mảng có kích thước (số lượng phần tử) cố định ngay từ khi khai báo.

	- Là cách khai báo sẵn tập hợp (một loạt) các con trỏ chứa toạ độ bằng câu lệnh new[], số lượng con trỏ được chừa sẵn (sẵn sàng đợi "lệnh" để trỏ) sẽ tương ứng với số lượng phần tử đã khai báo.

	- Giống như một chiếc kệ đựng đồ khi được thiết kế sẵn và cho biết trước số ngăn trống, nên số lượng ngăn sẽ được lưu lại dưới dạng thuộc tính length là đủ.

	- Mảng bây giờ là một sự kết hợp khi vừa đóng vai đối tượng để gọi các hàm (sau khi new[] là đã có thể chấm, không cần phải có giá trị cho phần tử), nhưng cũng đồng thời đóng vai con trỏ để tương tác trực tiếp thông qua chỉ số [i].
		+ Sử dụng tên hàm như một đối tượng để gọi các phương thức sẵn có.
		+ Đồng thời phải sử dụng trực tiếp tên gọi tắt của từng phần tử (chỉ số [i]) để thực hiện các thao tác cho từng phần tử và phải thiết kế các hàm để tương tác với nhiều phần tử cùng lúc.

	-> Mảng đối tượng với kích thước cố định, chứa sẵn một loại các con trỏ, đóng hai vi trò là đối tượng và con trỏ.

	Ví dụ: Kích thước (số lượng phần tử) của mảng đối tượng trong thực tế.

		- Số ghế ngồi trong một rạp chiếu phim.
			+ Khi xây dựng chắc chắn sẽ chiếm một không gian nhất định dù chưa đi vào hoạt động.
			+ Có số lượng ghế ngồi cố định, dùng không hết thì bỏ trống, hết ghế rồi thì lại không thể mở rộng thêm.
			+ Bên cạnh tên rạp phim (ví dụ: CGV Vincom Center Landmark 81, CGV Pearl Plaza...) để phân biệt được giữa các rạp với nhau, mỗi ghế ngồi trong một rạp cũng được đánh kí hiệu bằng kí tự và số (ví dụ: A9, B8, C7, D6...) để giúp khán giả dễ dàng tìm chỗ ngồi của mình hơn.
			+ Sau khi chỗ ngồi đã được đặt, kí hiệu của ghế ngồi sẽ đại diện cho một khán giả xem phim, dù khán giá đó đang ở đâu đi nữa.

		- Danh sách sinh viên trong một lớp học.
			+ Chưa đến giờ học, nhưng số ghế ngồi đã được chừa sẵn và vẫn chiếm một không gian diện tích.
			+ Có giới hạn số lượng sinh viên tối đa trong một lớp.
			+ Bên cạnh tên lớp, mỗi sinh viên sẽ được phân biệt với nhau bằng mã số sinh viên.
			+ Mã số sinh viên sẽ đại diện được cho một sinh viên bất kì, dù sinh viên đó đang ở đâu đi nữa.

------------------------------------------------------------

2. Bộ sưu tập (Collection Framework): Cũng là một chiếc túi đựng dữ liệu, nhưng linh hoạt hơn trong kích thước.

	- Là loại mảng không cần khai báo trước số lượng phần tử / con trỏ và ban đầu sẽ không có phần tử / con trỏ nào.

	- Cũng sử dụng câu lệnh new[] để thông báo rằng sẽ chứa một loạt các con trỏ, nhưng điều khác biệt là chỉ khi sử dụng hàm chuyên biệt để thêm phần tử vào trong mảng thì mới phát sinh một con trỏ (chứ không cấp sẵn một số lượng con trỏ như mảng đối tượng).

	- Giống như một chiếc túi, phải mở ra trước (gọi hàm) và xem bên trong có gì thì mới có thể biết được số lượng phần tử thực tế; vì giá trị này liên tục bị thay đổi, nên phải sử dụng hàm size() để tính toán và trả về số lượng.

	- Nhưng cứ khởi tạo đối tượng bằng new() và thêm (bổ sung) con trỏ mới tạo vào trong mảng, hoặc xoá phần tử (con trỏ) đã sẵn có trong mảng, sau đó mảng sẽ tự động co giãn kích thước tuỳ theo số lượng phần tử còn lại.

	- Mảng bây giờ hoàn toàn là đối tượng khi mọi thao tác cho tên mảng và từng phần tử trong mảng đều phải thông qua các hàm đã được tích hợp sẵn.

	-> Mảng đối tượng với kích thước tự động, không chứa sẵn con trỏ nếu chưa gọi hàm, đóng vai trò như một đối tượng.

--------------------------------------------------------------------------------

[CÁC LOẠI BỘ SƯU TẬP / TÚI KHÔNG ĐÁY / TÚI THẦN KỲ]

* Bộ sưu tập các loại "túi thời trang" / Túi không đáy / Túi thần kỳ (Collection Framework):

	- Là tập hợp gồm nhiều loại mảng, mỗi mảng sẽ phục vụ cho một số nhu cầu nhất định.
		+ Nhóm các kỹ thuật giúp lưu trữ nhiều dữ liệu.
		+ Bao gồm cả những lớp trừu tượng và cụ thể.

	- Mỗi loại mảng sẽ được xem như là một chiếc túi và đây là bộ sưu tập gồm nhiều túi tập hợp lại với nhau, tuỳ vào trường hợp cụ thể mà sẽ cần đến loại túi tương ứng.

	- Điều đặc biệt, chiếc túi này đã được nhân cách hoá với những hành xử tương ứng với dữ liệu mà mình đang nắm giữ.
		+ Áp dụng tính chất đóng gói, vì túi lúc này sẽ là nơi chứa nhiều dữ liệu nhất, nên mọi hành xử liên quan đến dữ liệu sẽ phải thông qua sự cho phép của túi, mọi hành xử cũng chỉ diễn ra trong phạm vi cho phép của túi.
		+ Khi này, không còn được phép tương tác trực tiếp thông qua chỉ số [i], mà toàn bộ đều phải thông qua hàm đã được quy định sẵn.

	- Vẫn cần new[] để xin cấp phát một vùng RAM rỗng (không gian trống để chứa dữ liệu), phục vụ cho việc lưu trữ các con trỏ tham chiếu của vùng new() sau này.

	- Với kích thước mảng linh hoạt hơn, ban đầu mảng sẽ chưa có phần tử / con trỏ nào, nhưng sau đó sẽ tự động được mở rộng thêm khi ngày càng có nhiều con trỏ new() được thêm vào.

	-> Loại mảng trắng tay ngay từ đầu, nhưng không ngại kết nạp con trỏ đến vô hạn.
		(Kỹ thuật quản lý nhiều con trỏ.)

------------------------------------------------------------

* Các thuật ngữ trong đời sống:
	- List (Danh sách): Bản ghi các thứ theo một thứ tự nhất định.
	- Set (Tập hợp): Bộ gồm nhiều thành phần có chung đặc trưng nào đó mà số lượng có giới hạn hoặc không.
	- Map (Bộ ánh xạ / phản ánh): Từ thứ này sang thứ khác (bản đồ ánh xạ từ thực địa vào giấy tờ, đi theo chỉ dẫn trên giấy tờ là sẽ đến được nơi cần đến trên thực địa).
	- Hash (Lộn xộn / Linh tinh): Làm cho việc trở bên be bét, làm rối tinh lên.
	- Tree (Cây): Phân nhánh đều tăm tắp, vẫn có một trật tự trong việc phân chia nhánh.

Các loại túi (thương hiệu): Là các lớp Cha dạng Interface và chứa các lớp Con cụ thể cho phép tạo được đối tượng để lưu trữ và xử lý dữ liệu.
	- Gồm hai loại: Collection (List, Set, Queue...) & Map.
	- Ngoài ra, có thể được liệt kê thành ba "phân khúc" phổ biến.

	// Phân khúc quốc dân
	1. List (Danh sách): Cho phép trùng con trỏ / đối tượng.
		- Bắt đầu từ 0, phần tử được lần lượt thêm vào theo trình tự tăng dần.
		- Cho phép một vùng new() có nhiều con trỏ cùng trỏ đến và lưu toạ độ.
		- Thường được áp dụng trong việc tính toán lượt truy cập (một người được phép truy cập nhiều lần).

		1.1. ArrayList:
			- Khi vào theo thứ tự nào thì sẽ ra theo đúng thứ tự ấy.
			- Tổ chức cấu trúc theo dạng mảng, các phần tử nằm liên tiếp nhau.
			- Là một dạng mảng động với kích thước linh hoạt (cho phép ngầm xử lý để có thể liên tục thêm mà không lo bị đầy: tạo mảng mới với kích thước nhiều hơn 50%, sao chép con trỏ mảng cũ sang mảng mới).
			- Tốc độ tìm kiếm sẽ nhanh, nhưng chèn và xoá sẽ chậm.
			- Có nhiều phương thức khởi tạo khác nhau:
				+ ArrayList(): Tạo một mảng rỗng với sức chứa tối đa là 10 phần tử (và sẽ tự động năng khi vượt qua giới hạn kích thước hiện tại).
				+ ArrayList(int soLuongPhanTu): Tạo một mảng rỗng với sức chứa tối đa do người dùng tự quy định.
				+ ArrayList(Collection c): Nhận vào đối tượng là một Collection khác (sẵn có).

		1.2. LinkList:
			- Tổ chức cấu trúc theo dạng danh sách liên kết.
			- Các phần tử nằm rời rạc.
			- Tốc độ tìm kiếm sẽ chậm, nhưng chèn và xoá lại nhanh.

		1.3. Vector: Toàn bộ các xử lý đều ở dạng đồng bộ (Synchronize), giúp an toàn khi xử lý đa luồng (thread-safe) và tự động cơi nới bộ nhớ gấp đôi nếu bị đầy.
		...

		-> Cho phép trùng và có tuân theo thứ tự.

	// Phân khúc độc quyền
	2. Set (Tập hợp): Cấm trùng con trỏ / đối tượng.
		- Trong cơ sở dữ liệu, tập hợp được xem là một bảng có khoá chính (Primary Key) và cấm trùng trên khoá chính, để đảm bảo có thể xác định được một đối tượng duy nhất nào đó trong cơ sở dữ liệu.
		- Là tập con của List (danh sách).
		- Nhưng lúc vào và lúc ra sẽ có thể là những vị trí khác nhau, nên sẽ không có hàm get() và set(), chỉ có thể sử dụng forearch để quét toàn bộ mảng.
		- Cấm việc nhiều hơn một con trỏ cùng trỏ đến một vùng new(), nhưng nếu hai vùng new() trùng thông tin hoàn toàn thì tập hợp cũng không thể nhận biết được, vì mỗi lần có new() là có vùng nhớ mới.
		- Tuy vẫn cho thêm vào và sẽ không báo lỗi khi thêm trùng, nhưng phần tử bị thêm trùng sẽ không được ghi nhận lần hai.
		- Thường được áp dụng trong việc tính toán số người truy cập (chỉ tính một người truy cập, dù người ấy có truy cập nhiều lần).

		2.1. HashSet:
			- Để theo ngẫu nhiên (không theo thứ tự).
			- Tổ chức cấu trúc theo dạng mảng.
		2.2. LinkedHashSet:
			- Tổ chức cấu trúc theo danh sách liên kết.
		2.3. TreeSet: Sắp xếp tự động theo một thứ tự nào đó.
			- Tổ chức cấu trúc theo dạng cây.

		-> Cấm trùng và không quan trọng thứ tự.

	// Phân khúc ngăn nắp & tối giản
	3. Map (Bộ ánh xạ): Thiết kế một bộ ánh xạ để nhanh chóng tìm và lấy ra được con trỏ / đối tượng.
		- Cứ mỗi đối tượng (value) khi được thêm vào sẽ được đặt cho một định danh (key) để tạo nên một bộ "khoá - chìa" (key - value).
			-> Mỗi phần tử là một cặp "khoá - chìa".
		- Trong Map, key phải là duy nhất, còn value có thể tuỳ ý thay đổi.
			+ Có thể xem key giống như chỉ số (index) trong Collection - mỗi phần tử đều sẽ có một con số nguyên để đại diện cho mình, nhưng trong Map thì chỉ số này lại được phép ở dạng chuỗi.
			+ Nhưng khác với Collection, nếu phần key của Map bị trùng thì giá trị mới nhất sẽ được sử dụng (ghi đè lên giá trị cũ), đảm bảo key là độc nhất.
			+ Còn value thì có thể là bất kì kiểu dữ liệu nào, giống như Collection.

		3.1. HashMap:
			- Để theo ngẫu nhiên (không theo thứ tự).
			- Tổ chức cấu trúc theo dạng mảng.
		3.2. LinkedHashMap:
			- Tổ chức cấu trúc theo danh sách liên kết.
		3.3. TreeMap: Sắp xếp tự động theo một thứ tự nào đó.
			- Tổ chức cấu trúc theo dạng cây.

----------------------------------------

Một số hàm thông dụng và công dụng:

	size(): Trả về số lượng phần tử hiện đang có trong mảng.

	add(toạ-độ-đối-tượng): Tự động sinh ra một con trỏ, sử dụng con trỏ này để lưu toạ độ của vùng new(). Nếu không chỉ định vị trí cần thêm thì sẽ mặc định thêm vào cuối danh sách.

	get(vị-trí-cần-lấy): Lấy và trả về toạ độ của con trỏ thứ [i] - địa chỉ của vùng new().

	remove(vị-trí-cần-xoá): Chỉ xoá con trỏ tại vị trí chỉ định, nhưng không quan tâm đến vùng RAM, vùng RAM có thể sẽ bị bộ thu gom rác dọn dẹp hoặc cũng có thể không bị xoá nếu trước đó đã có ai đó trỏ ké.

	set(vị-trí-đích, toạ-độ-con-trỏ-nguồn): Thay đổi toạ độ trỏ của con trỏ.
		- Khi sắp xếp, bản chất vẫn sẽ là đổi vị trí / đảo con trỏ giống như mảng đối tượng.
		- Phần tử đầu tiên sẽ là phần tử bé nhất hoặc lớn nhất tuỳ theo yêu cầu sắp xếp tăng dần hoặc giảm dần.
		- Có thể thay phần "toạ-độ-con-trỏ-nguồn" bằng hàm get(vị-trí-cần-lấy) để nhận về toạ độ con trỏ.
		- Giống như getter() và setter() của các đối tượng.

	sort(tiêu-chí-so-sánh): Giúp tự động so sánh và sắp xếp giữa các đối tượng dựa theo một tiêu chí nào đó (có thể đưa tiêu chí từ bên ngoài vào).

	(Ghi chú: Khi in ra các phần tử trong mảng, nếu gọi trực tiếp tên mảng bên trong câu lệnh println(), những giá trị được in ra sẽ có sẵn định dạng với cặp ngoặc vuông [].)

--------------------

	Ví dụ: Cách khai báo và sử dụng bộ sưu tập ArrayList với những giá trị đơn giản.

		import java.util.ArrayList;
		import java.util.Collections;

		public class ArrayListOfLong {

			// Sử dụng hàm khởi tạo không tham số
			public static ArrayList<Long> list = new ArrayList<Long>();

			// Sử dụng khối lệnh khởi tạo tĩnh và hàm add()
			// để gắn sẵn một số giá trị mặc định cho bộ sưu tập
			// khi vừa mới nạp lớp vào
			static {

				// Mỗi phần tử trong ArrayList là một đối tượng
				list.add(0, new Long(20)); // Chỉ định vị trí cần thêm
				list.add(new Long(20));  // Không chỉ định vị trí cần thêm
				list.add(new Long(20));
				list.add(new Long(10));
				list.add(new Long(40));
				list.add(new Long(30));
				list.add(new Long(50));
			}

			// Xoá phần tử theo vị trí
			list.remove(2);

			// Duyệt và xoá phần tử theo giá trị
			for(int i = 0; i < list.size(); i++) {
				if (list.get(i).longValue() == 20) {
					list.remove(i);
					i--;
				}
			}
			
			// Duyệt và in ra toàn bộ phần tử theo truyền thống
			for(Long l : list)
				System.out.print("Removed list: " + l.longValue() + " ");


			// Đưa toạ độ của phần tử thứ 1 vào vị trí 0
			//	 i	     j
        		list.set(0, list.get(1));     // a[i] = a[j]


			// Sắp xếp theo thứ tự tăng dần
			// và gọi trực tiếp tên mảng bên trong câu lệnh println()
			// để in ra toàn bộ giá trị đã sắp xếp
			Collections.sort(list);
        		System.out.println("Sorted list: " + list);

			// Đảo ngược mảng
			Collections.reverse(list);
        		System.out.println("Reversed list: " + list);
		}

------------------------------------------------------------

* Lưu ý: Các lớp List, Set, Map chỉ chứa danh sách các con trỏ, không chứa các giá trị đơn giản như: số nguyên, số thực...

	- Mặc dù khi gọi hàm có sẵn của các Interface, ta vẫn có thể truyền các tham số là giá trị đơn giản vào hàm.
		Ví dụ: arr.add(10);

	- Nhưng bản chất là những giá trị đơn giản này là được "biến hình" thành những giá trị phức tạp thông qua Wrapper Class.

	- Giúp đồng nhất trong việc xử lý.

--------------------------------------------------------------------------------

[KỸ THUẬT TỔNG QUÁT HOÁ / THAM SỐ HOÁ KIỂU DỮ LIỆU - GENERICS]

	* Tham số hoá: Biến một thứ gì đó trở thành tham số đầu vào của hàm (được đưa từ bên ngoài vào).

	* Generics: Có đặc điểm chung của một giống loài; (thuộc) giống loài.
* Lập trình tổng quát (Generic programming): Kỹ thuật để tạo ra lớp, Interface và phương thức có kiểu dữ liệu chung chung nhất (Generics), cho phép hoạt động / tương thích với nhiều kiểu dữ liệu khác nhau.

	- Theo truyền thống, trong quá trình thiết kế và khi sử dụng, ta sẽ chỉ định rõ một giá trị thuộc một kiểu dữ liệu cụ thể nào đó vào trong phần tham số của hàm.
		-> Tham số hoá giá trị.
			(Giá trị sẽ từ từ được đưa vào sau, nhưng cho biết trước kiểu dữ liệu)

		Ví dụ: Truyền giá trị thuộc một kiểu dữ liệu cụ thể vào tham số của hàm.

			// Thiết kế hàm - Nhận vào giá trị thuộc một kiểu dữ liệu cụ thể

			// 	Truyền tham trị:
			// 	Giá trị "a" đại diện cho kiểu dữ liệu "int"
			void f(int a) {...}

			// 	Truyền tham chiếu:
			// 	Con trỏ "x" đại diện cho một đối tượng "Student"
			void f(Student x) {...}

			// Sử dụng hàm - Chỉ truyền vào giá trị thuộc kiểu dữ liệu đã quy định
			f(1); f(2)...
			f(sv1); f(sv2)...

	- Theo lập trình tổng quan, khi khai báo sẽ sử dụng một kiểu dữ liệu đối tượng chung chung (không phải kiểu đơn giản như: int, double...) ngay trong phần tham số của lớp / hàm, chỉ đến khi sử dụng mới truyền giá trị thuộc một kiểu dữ liệu (đối tượng) cụ thể nào đó vào trong phần tham số của hàm.
		-> Tham số hoá kiểu dữ liệu.
			(Thậm chí đến trước kiểu dữ liệu cũng sẽ từ từ được đưa vào sau)

		Ví dụ: Truyền giá trị thuộc bất kì kiểu dữ liệu nào vào tham số của hàm.

			// Thiết kế hàm - Nhận vào giá trị thuộc bất kì kiểu dữ liệu nào
			class Printer<T> {
				void p(T t) {...}
			}

			// Sử dụng hàm - Truyền vào giá trị thuộc bất kì kiểu dữ liệu nào
			p(Integer a);
			p(Double b);

	- Mọi thứ truyền vào đều phải là đối tượng (kiểu tham chiếu), kể cả kiểu dữ liệu nguyên thuỷ cũng phải sử dụng thêm lớp đóng gói để trở thành đối tượng.

	- Khi sử dụng ở mức tổng quát, trước khi đưa giá trị (dữ liệu) vào, còn cần phải khai báo thêm kiểu dữ liệu; nghĩa là có đến hai thứ cần phải khai báo.

―――――――――――――――――――――――――――――――――――――――――――――――――
│	Xem lớp như tham số để truyền vào hàm	│
―――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

Để đại diện cho một kiểu dữ liệu chung chung / tuỳ ý (arbitrary), ta sẽ có nhiều cách:
	
	1. Sử dụng một kiểu dữ liệu được tham số hoá (Type Parameter / Parameterized Type) cụ thể: Quy ước tên viết tắt của các Type Parameter (kiểu dữ liệu chung chung).

		E: Element (Phần tử trong Collection Framework)
		T: Type (Kiểu dữ liệu bất kỳ thuộc Wrapper Class: String, Integer, Float...)
		K: Key (Khoá - Chỉ số nhưng ở dạng chuỗi)
		V: Value (Giá trị tương ứng với khoá)
		N: Number (Kiểu số: Byte, Short, Integer, Long, Float, Double)
		...
		
		Ví dụ 1: Khai báo lớp.

			// Chỉ có 1 Type Parameter
			class MyClass<T> {...}

			// Có nhiều Type Parameter
			class MyClass<K, V> {...}

			// Có thêm thuộc tính và phương thức
			class MyClass<T> {
				private K key;
				private V value;
				...

				public void setKey(T value) {
					this.value = value;
				}
				
				public T geKey() {
					return value;
				}

				public void setValue(T value) {..}
				
				public T getValue() {...}
			}

			// Sử dụng
			MyClass<String> strObj = new MyClass<>();

			MyClass<Integer> intObj = new MyClass<>();
			intObj.setValue(10);
			int value = intObj.getValue();

		Ví dụ 2: Khai báo Interface.
			interface MyInterface<T> {...}

		Ví dụ 3: Khai báo phương thức.
			public <T> void myMethod(T param) {...}
			public static <T> void myMethod(T[] param) {...}

	2. Sử dụng một ký tự đại diện (Wildcard Character), cụ thể là '?'.

----------------------------------------

Tận dụng việc thông báo lỗi được xuất hiện ngay trong quá trình viết code.
	- Ta có thể sử dụng Type Parameter như một ràng buộc dữ liệu.
	- Ngoài ra, Type Parameter cũng có thể kế thừa hoặc hiện thực hoá một lớp nào đó để giới hạn thêm những loại tham số được phép truyền vào hàm.
		+ Trong kế thừa, Type Parameter sẽ có thể thuộc định dạng của lớp Cha hoặc các lớp Con của lớp Cha này.
		+ Nhưng đối với Type Parameter, việc hiện thực hoá một Interface vẫn sẽ sử dụng từ khoá extends thay vì implements như trong thiết kế lớp.

	Ví dụ: Kế thừa trong Type Parameter.

		// Nhận vào bất kì giá trị nào, nhưng chỉ giới hạn ở số,
		// vì lớp Number là lớp Cha của tất cả các lớp số
		public class Person <T extends Number> {
			private T yob;
		}

		// Báo lỗi
		Person<String> personString = new Person("2000");

		// Thành công
		Person<Integer> personInteger = new Person(2000);

----------------------------------------

Lưu thập cẩm con trỏ:
	- Chứa tham chiếu của tất cả các đối tượng.
	- Rất khó trong việc sử dụng for để duyệt.

	Ví dụ:
		// Thêm vào
		List arr = new ArrayList();
		arr.add(1);
		arr.add("Hello World");
		arr.add(true);

		// Lấy ra
		int nbr = (int) arr.get(0);
		String str = (String) arr.get(1);

Chỉ lưu con trỏ thuộc một kiểu dữ liệu đối tượng (lớp): 
	- Vì các đối tượng đồng nhất với nhau, nên sẽ dễ dàng trong việc đa hình.

	Ví dụ:
		// Thêm vào
		List<Student> arr = new ArrayList();
		arr.add(new Student(...));
		arr.add(new Student(...));

		// Lấy ra
		int nbr = arr.get(0).showProfile();

------------------------------------------------------------

[THAM CHIẾU & HÀM TRẢ VỀ DANH SÁCH CÁC CON TRỎ]

Theo tư duy hướng đối tượng, mọi thao tác (ví dụ: chuẩn bị dữ liệu...) nên được đặt ở một hàm riêng và thuộc về một đối tượng tương ứng, còn hàm main() chỉ nên là nơi để gọi hàm.
	- Bên cạnh việc hàm chỉ trả về một con trỏ, hàm vẫn được phép trả về một danh sách các con trỏ.
	- Giá trị trả về từ hàm có thể lại trở thành tham số đầu vào cho một hàm khác.

	Ví dụ: Hàm để khởi tạo và trả về một danh sách sinh viên (dạng ArrayList).

		public List<Student> initData() {
			List<Student> arr = new ArrayList();
			
			arr.add(new Student("SE555555", "NĂM LÊ", 2003, 5.5));
			arr.add(new Student("SE999999", "CHÍN PHẠM", 2003, 9.9));
			arr.add(new Student("SE888888", "TÁM NGUYỄN", 2003, 8.8));
			arr.add(new Student("SE222222", "HAI VÕ", 2003, 2.2));
			arr.add(new Student("SE444444", "BỐN LÝ", 2003, 4.4));
			
			// Hàm trả về toạ độ của vùng new[]
			return arr;
		}

Bên cạnh việc tạo một danh sách con trỏ bên trong hàm, ta còn có thể nhận một danh sách con trỏ từ bên ngoài truyền tham chiếu vào hàm thông qua tham số đầu vào.
	- Sẽ có một danh sách các con trỏ có sẵn ở đâu đó để truyển vào hàm.
	- Đồng nghĩa với việc hàm sẽ chỉ trỏ vào / neo đậu vào một vùng new[] ở đâu đó.
	- Vì đây là truyền tham chiếu, nên mọi thay đổi trong hàm đều sẽ ảnh hưởng trực tiếp đến danh sách gốc.

	Ví dụ: Hàm nhận tham số đầu vào là danh sách sinh viên (dạng ArrayList).

		public static Student searchAStudent(List<Student> arr, String id) {...}

------------------------------------------------------------

Để so sánh và sau đó thực hiện các xử lý (tìm kiếm, sắp xếp tự động...) giữa những đối tượng, Java cung cấp hai Interface.

	1. Comparable: Tự mình (có khả năng) so sánh với đối tượng cùng loại, vì muốn tự đánh giá năng lực của bản thân.
		-> Ghen ăn tức ở (GATO).

	2. Comparator (Toán tử so sánh): Nhờ trung gian phân xử (cân, đong, đo, đếm) hơn thua.
		-> Trung gian giải quyết.

(Nhập môn Software Testing: Bài 06 - Dependency Injection (phần cuối - phiên bản full):
	- https://youtu.be/6Vi7lVClOk0?t=4844)

----------------------------------------

* Comparable: Là một Interface chứa duy nhất một hàm trừu tượng compareTo(), được sử dụng để làm điều kiện / tiêu chí so sánh (hàm cho những nơi khác gọi) bằng cách tự lấy bản thân mình (từ khoá "this") đi so sánh với thuộc tính của một đối khác chung lớp.
	- Nằm sẵn trong gói java.lang nên có thể trực tiếp sử dụng mà không cần import.
	- Được dùng (ngầm định gọi) khi muốn so sánh dựa trên chỉ một thuộc tính của đối tượng và sắp xếp nó theo một thứ tự tự nhiên (ví dụ: 0-9, a-z...).
	- Được hiện thực hoá ngay bên trong lớp chứa đối tượng cần so sánh (ví dụ: lớp SinhVien, PhuongTienGiaoThong, Sach...).
		+ Khi gọi phương thức sort() của lớp Collections, đối tượng được tạo ra từ lớp chứa hàm compareTo() sẽ ngầm định gọi phương thức này để làm tiêu chí so sánh (giống như việc ngầm định gọi phương thức toString() khi truyền đối tượng vào phương thức println()).
		+ Vì phải được thiết kế trực tiếp trong lớp chứa đối tượng nên sẽ làm thay đổi lớp gốc.

	* Thiết kế bên trong của Interface Comparable:

		@FunctionalInterface
		interface Comparable<T> {
			int compareTo(T o);
		}

		// Tự lấy bản thân mình đi so sánh với đối tượng khác và trả về giá trị số nguyên:
		// - Nếu > 0: Mình (this) lớn hơn người ta (đối tượng đầu vào).
		// - Nếu = 0: Mình (this) bằng người ta (đối tượng đầu vào).
		// - Nếu < 0: Mình (this) nhỏ hơn người ta (đối tượng đầu vào).

	Ví dụ: So sánh sinh viên theo điểm trung bình.

		// Khai báo trực tiếp bên trong lớp chứa đối tượng
		public class Student implements Comparable<Student> {
			private String name;
			private double gpa;

			...

			// Hiện thực hoá phương thức compareTo()
			// để làm tiêu chí so sánh cho hàm sort() của lớp Collections
			@Override
			public double compareTo(Student otherStudent) {
				return Double.compare(this.gpa, otherStudent.gpa());
			}
		}

		// Sử dụng bằng cách ngầm định gọi hàm compareTo()
		List<Student> student = new ArrayList<>();
		...
		Collections.sort(student);

----------------------------------------

* Comparator: Là một Functional Interface với duy nhất một hàm trừu tượng compare(), chuyên nhận điều kiện / tiêu chí so sánh từ bên ngoài vào, sau đó có thể được truyền vào một hàm khác (ví dụ: hàm sort() trong Collections) để bắt đầu so sánh.
	- Nằm sẵn trong gói java.util nên sẽ cần import trước khi sử dụng.
	- Được dùng khi muốn so sánh dựa trên nhiều thuộc tính khác nhau của đối tượng (nhiều tiêu chí để so sánh).
	- Có thể được hiện thực hoá ở bất kì đâu (hoặc thấm chí là nặc danh).
		+ Khi gọi phương thức sort() của lớp Collections,
		+ Vì có thể thiết kế ở bất kì lớp nào nên không làm thay đổi lớp gốc.

	* Thiết kế bên trong của Interface Comparator:

		@FunctionalInterface
		interface Comparator<T> {
			int compare(T o1, T o2);
		}

	Ví dụ: So sánh danh sách sinh viên.

		// Sử dụng lớp nặc danh để chuẩn bị điều kiện / tiêu chí so sánh
		// (hiện thực hoá điều kiện so sánh ở nơi "đồng không mông quạnh")
		Comparator<Student> scale = new Comparator<Student>() {

			@Override

			// Truyền từ bên ngoài vào hai đối tượng sinh viên
			public int compare(Student o1, Student o2) {
				
				// So sánh hai giá trị (số thực) theo truyền thống
				// bằng cách sử dụng tên đối tượng để lấy ra thuộc tính
			//          if (o1.getGpa() > o2.getGpa())
			//              return 1;
			//          else if (o1.getGpa() == o2.getGpa())
			//              return 0;
			//          else
			//              return -1;
				
				// Vì điểm số là số thực (double)
				// nên sẽ sử dụng thêm hàm compare() của lớp Double
				// để nhận dầu vào là hai số thực và tiến hành so sánh,
				// sau đó trả về kết quả là một số nguyên (-1 / 0 / 1)
				return Double.compare(o1.getGpa(), o2.getGpa());
			}
		};

		// Hàm sắp xếp nhận vào từ bên ngoài hai thứ:
		//	1. Nhận danh sách dữ liệu
		//	2. Nhận điều kiện / tiêu chí so sánh
		Collections.sort(list, scale);

------------------------------------------------------------

[NHÀ THẦU PHỤ - ITERATOR]

Iterator: Đưa vào một Collection Framework, Iterator sẽ duyệt tự động và trả về đối tượng cần tìm.

	Ví dụ:
		ArrayList<String> fruit = new ArrayList<>();
		fruit.add("Apple");
		fruit.add("Banana");
		fruit.add("Lemon");

		Iterator<String> fruit = fruits.iterator();

		while(fruit.hasNext())
			System.out.println(fruit.next());

------------------------------------------------------------

[HÀM SAO CHÉP ĐỐI TƯỢNG - CLONEABLE]

Khi một lớp không kế thừa từ lớp nào thì sẽ mặc định kế thừa từ lớp thuỷ tổ Object.
	- Bên trong lớp Object có phương thức clone(), giúp tạo một đối tượng mới bằng cách sao chép giá trị của đối tượng sẵn có sang cho đối tượng mới (chỉ sao chép nội dung, không phải gán địa chỉ con trỏ / cho trỏ ké - vẫn là hai vùng nhớ độc lập trên Heap).
	- Nhưng để lớp Con kế thừa và sử dụng phương thức này, cần phải có "giấy phép sử dụng".

* Cloneable: Là một Interface đánh dấu (Marker Interface) và không có bất kỳ phương thức trừu tượng nào bên trong.
	- Nếu lớp Con hiện thực hoá Interface này, sẽ nhận được một "chứng nhận" cho biết lớp đó hỗ trợ việc sao chép (cloning) đối tượng.
	- Được sử dụng để đánh dấu, "cấp phép" cho một lớp Con được quyền vượt mặt phương thức clone() của lớp Object để sao chép / nhân bản giá trị qua lại giữa các đối tượng của lớp Con.
	- Nhưng trước khi sử dụng, lớp Con chỉ cần vượt mặt phương thức clone() của lớp Object, xử lý ngoại lệ CloneNotSupportedException và ép kiểu dữ liệu (ban đầu là Object) về kiểu cần sử dụng.

	-> Interface để "kích hoạt" tính năng ngầm - Cho phép sao chép đối tượng.

* Lưu ý: Sau khi sao chép đối tượng, chỉ có giá trị là giống nhau, chứ vùng RAM trên Heap của hai đối tượng này là hoàn toàn độc lập nhau.
	- Việc đối tượng "này" thay đổi giá trị bên trong sau khi sao chép không làm ảnh hướng đến giá trị của đối tượng "kia".
	- Nhưng chỉ áp dụng cho giá trị (cấp) đầu tiên, nhưng giá trị tiếp theo nếu cả hai đang cùng tham chiếu đến một vùng nhớ khác thì việc một bên thay đổi cũng sẽ làm ảnh hướng đến bên còn lại.
		-> Shallow Copy.
	- Những giá trị tiếp theo nếu cũng muốn được sao chép để tạo thành một vùng RAM độc lập thì cũng phải được khai báo trong phần vượt mặt của phương thức clone() của cấp đầu tiên.
		-> Deep Copy.

==========================================================================================

[ĐƯA DỮ LIỆU TỪ BÊN NGOÀI VÀO CHƯƠNG TRÌNH]

Việc gán cứng giá trị trong code chỉ phục vụ cho mục đích kiểm thử phần mềm.
	- Trong thực thế, để linh hoạt trong dữ liệu, ta có thể bắt gặp được những phương tiện nhập dữ liệu như: tập tin, máy ảnh, máy quay, máy quét, bàn phím, bàn di chuột... tất cả đều có chung một công dụng là giúp đưa dữ liệu từ bên ngoài vào trong máy tính.
	- Vì vậy, chúng được gom vào chung một nhóm được gọi là Scanner, được hiểu là phương tiện cung cấp dữ liệu.
	-> Nhóm đối tượng được sử dụng để đưa dữ liệu vào trong máy tính.

Java không trực tiếp hỗ trợ đọc dữ liệu từ cửa sổ dòng lệnh (console), vì vậy, ta phải sử dụng lớp Scanner để chỉ định việc đọc dữ liệu từ bàn phím thông qua đối tượng System.in.
	- Sau đó, ta có thể sử dụng những phương thức nextLine(), nextInt(), nextDouble()... để đọc dữ liệu được nhập từ bàn phím.
	- Nhưng để đưa được dữ liệu vào trong máy tính nhằm lưu trữ và xử lý thì ta cần thêm biến.
	- Vì vậy, ta vẫn sẽ cần thêm những biến trung gian để lưu những dữ liệu được nhập vào từ bàn phím.

	Ví dụ: Nhận và lưu trữ dữ liệu được nhập từ bàn phím.

		// Thông báo nhận dữ liệu đầu vào thông qua bàn phím
		Scanner sc = new Scanner(System.in);

		// Tạo biến để lưu chuỗi sẽ được nhập vào
		String name;
		name = sc.nextLine();

* Lưu ý: Vì bảng mã không phải Unicode, nên vẫn sẽ không thể nhập từ bàn phím tiếng Việt có dấu được.

------------------------------------------------------------

Trong trường hợp muốn đọc tập tin từ ổ đĩa.

	- Vẫn sử dụng lớp Scanner, nhưng trước đó phải truyền vào một đối tượng thuộc lớp File đã chỉ định đường dẫn của tập tin.

		Ví dụ: Truyền đối tượng tập tin (thay vì bàn phím) vào Scanner.

			// Khởi tạo đối tượng, mô tả vị trí và tên của tập tin
			File tapTin = new File("du-lieu.txt");

			// Thông báo nhận dữ liệu đầu vào thông qua tập tin
			Scanner scanner = new Scanner(tapTin);

	- Sau đó vẫn có thể thao tác với tập tin để đọc dữ liệu như bình thường thông qua các phương thức nextLine(), nextInt(), nextDouble()...
	
	- Nếu không tìm thấy tập tin hoặc tập tin bị lỗi thì sẽ ném ra ngoại lệ FileNotFoundException.

	- Sử dụng phương thức close() để đóng tập tin khi không còn sử dụng nữa và đảm bảo rằng toàn bộ dữ liệu sẽ được lưu lại, vì một số dữ liệu sẽ được lưu trong bộ đệm (buffer) để giúp tiết kiệm thời gian đọc-ghi trên ổ đĩa.

--------------------------------------------------------------------------------

[CÁC "BỆNH" KHI NHẬP DỮ LIỆU TỪ BÀN PHÍM]

Vì Java có mức độ bảo mật nghiêm ngặt hơn so với C, chẳng hạn như khi khai báo biến (Local Variable) mà không gán giá trị thì Java sẽ thông báo thay vì tự động lấy giá trị rác như bên C; hay cố tình nhập dữ liệu khác với kiểu dữ liệu đầu vào thì Java sẽ tự động ngắt ứng dụng chứ không bỏ qua giống như C.

Khác với việc chủ động gắn sẵn giá trị cho biến để tiện cho việc lập trình và kiểm thử, việc nhập dữ liệu từ bên ngoài vào ứng dụng thông qua bàn phím sẽ có những "tác dụng phụ":

	[1. BỆNH "TỬ TẾ" KHÔNG GÂY BẤT KÌ HẬU QUẢ NÀO]

	*Đây không phải là bệnh và cũng không gây bất kì hậu quả nào, nên được phát huy*
		-> "Hôm nay không có thông báo, khi nào có thông báo thì sẽ thông báo sau. Đề nghị mọi người thường xuyên xem thông báo để biết khi nào có thông báo."

		* Mô tả: nhập theo đúng những gì được yêu cầu, ứng dụng tiếp tục xử lý mà không bình luận gì thêm.

------------------------------------------------------------

	[2. BỆNH "VƯỢT BIÊN" GÂY SAI SÓT TRONG TÍNH TOÁN - OUT OF RANGE]

	* Sai sót: mặc dù nhập đúng theo định dạng/hình thái của dữ liệu được yêu cầu, nhưng lại vượt miền giá trị cần thiết, khiến không ra được giá trị cần thiết để tính toán.
		-> Out of range.

		* Mô tả: vẫn tự tin khẳng định rằng mình nhập đúng, nhưng khi nhận kết quả tính toán thì lại bất ngờ, ngỡ ngàng, ngơ ngác và bật ngửa vì không được như mong đợi.

		* Triệu chứng: không thấy bất kì dấu hiệu bất thường nào cho đến khi biết kết quả xử lý.

		* Nguyên nhân: tuy gặp phải người tử tế vì đã nhập đúng định dạng, nhưng lại chủ quan không giới hạn miền giá trị được phép nhập và cũng không hiển thị thông báo khi người dùng nhập lố.

		* Cách điều trị: sử dụng câu lệnh điều kiện if và các hàm có liên quan để kiểm tra dữ liệu nhập vào và hiển thị thông báo lỗi.
			- Có thể kết hợp thêm với while()/do-while() để yêu cầu nhập lại.
			- Nên kiểm tra từng dữ liệu một và chỉ yêu cầu nhập lại phần bị sai, đừng vì một lỗi sai mà "vơ đũa cả nắm" và bắt nhập lại toàn bộ.
			-> Kiểm tra dữ liệu nhập vào, hiển thị thông báo và yêu cầu nhập lại đến khi đúng thì thôi.
				(Còn thấy đau là còn thương - Còn thấy sai là còn thông báo và yêu cầu nhập lại.)

			Ví dụ: Nhập sinh năm, sau đó sử dụng while và if để kiểm tra thông tin.

				int yob = 0;
				int age = 0;
				Scanner sc = new Scanner(System.in);
				
				// Liên tục và vẫn sẽ tiếp tục cho đến khi gặp câu lệnh dừng
				while(true) {
					System.out.print("Please input your year of birth: ");
					yob = sc.nextInt();

					// Kiểm tra giá trị biên
					if (yob >= 1900 && yob <= getCurrentYear()) {
						age = getCurrentYear() - yob;
						
						if (age < 13)
							System.out.println("Sorry, you need at least 13 years old to register an account!");
						else {
							System.out.println("Please wait. We're directing you to the register page.");
							break;
						}
					}
					else
						System.out.println("Please input an valid year of birth!");
				}

------------------------------------------------------------

	[3. BỆNH "LANH CHANH NHƯ HÀNH KHÔNG MUỐI" GÂY LẠC TRÔI - SKIP GETTING A CHAR/STRING]

	* Lạc trôi lệnh: khi nhập dữ liệu từ bàn phím, các câu lệnh có thể sẽ "tài lanh" khi lấy rác trong bộ đệm để đem đi xử lý thay vì nhận trực tiếp từ bàn phím.
		-> Skip getting a char/string.

		* Mô tả: tuy có thực sự chạy nhưng lại cảm giác như lệnh không chạy và không cho nhập kí tự/chuỗi từ bàn phím.

		* Triệu chứng: đến dòng nhập kí tự/chuỗi thì tự nhiên CPU lại bỏ qua và xử lý câu lệnh khác mà không dừng lại để người dùng có thể nhập. Đặc biệt, chỉ xuất hiện đối với câu lệnh nhập chuỗi khi trước đó là câu lệnh nhập số.

		* Nguyên nhân: nguyên tắc của câu lệnh nextLine() trong Java là kiểm tra bộ đệm trước, lấy hết toàn bộ những kí tự trong đó - kể cả phím [Enter], sau đó loại bỏ phím [Enter] đi và gán phần cần sử dụng vào trong biến.
			- Nhưng do câu lệnh nextInt() để nhập số lại sống không có trách nhiệm, trước đó chỉ dùng đúng phần số nguyên và đã để lại "rác kí tự" trong bộ đệm nhập xuất của bàn phím (buffer).
			- Vì mọi thứ được nhập từ bàn phím đều là kí tự và "rác kí tự" có thể là: phím cách [Space], phím xuống dòng [Enter] hoặc kí tự nào đó... Khiến câu lệnh nhập chuỗi nextLine() đến sau đã hốt luôn phần rác vì tưởng nhầm đó cũng là kí tự mà mình cần dùng.

		* Cách điều trị: xóa bộ đệm bàn phím trước lệnh nhập kí tự/chuỗi. Nhưng vì Java không có câu lệnh để xóa bộ đệm một cách tường minh giống như trong C, nên phải sử dụng cách khác.
			-> Xóa bộ đệm bàn phím trước khi bước vào lệnh nhập chuỗi.

			* Bài thuốc:

				1. Tà đạo - Âu Dương Phong: tận dụng nguyên lý của câu lệnh nextLine() khi sẽ hốt toàn bộ chuỗi, kể phím [Enter] và sau đó loại bỏ phím [Enter].
					-> Dọn sạch rác trong bộ đệm cho câu lệnh đến sau.

						* Cú pháp: tênĐốiTượng.nextLine();

				2. Chánh đạo - Quách Tĩnh: song kiếm hợp bích - sử dụng lớp trai bao (Wrapper Class) và kết hợp với cách Tà đạo.
					-> Nhận vào một chuỗi bằng câu lệnh nextLine() (chỉ bao gồm số và kí hiệu xuống dòng), sau đó dọn sạch phần thừa trong bộ đệm và chuyển phần tử tế thành số.

						* Cú pháp: Integer.parseInt(sc.nextLine());

							* Parse: phân tích / chuyển đổi / suy diễn - từ tổng quát đến cụ thể.

					Ví dụ: Nhập số định danh trước khi nhập tên.

						int id = 0;
						String name;
						Scanner sc = new Scanner(System.in);
						
						System.out.print("Please input your identity numbers: ");
						//id = sc.nextInt(); // Câu lệnh gây lạc trôi
						id = Integer.parseInt(sc.nextLine());
						
						// Câu lệnh trước đó đã được "don dẹp sạch sẽ"
						// trước khi chuyển sang câu lệnh mới
						System.out.print("Please input your name: ");
						name = sc.nextLine();

------------------------------------------------------------

	[4. BỆNH "BA GAI" GÂY ĐĂNG XUẤT - EXCEPTION]

	* Đăng xuất khỏi Trái Đất: mặc định, khi máy ảo Java phát hiện dữ liệu sai lệch và tìm ẩn nguy cơ gây nguy hiểm, nó sẽ gửi thông điệp "an Exception object" đến cho ứng dụng và lập tức ngắt ứng dụng (End process) để đảm bảo an toàn.
		-> Exception.

		* Mô tả: những tình huống bất thường và không mong đợi, không ngờ đến, không thể lường trước... xảy ra trong quá trình thực thi chương trình, nhưng lại không thể sử dụng if để xử lý được.

		* Triệu chứng: chương trình bị ngắt ngang kèm với thông báo đỏ: "...Exception..." (thông điệp Exception e).

		* Nguyên nhân: cuộc sống vốn đầy bất ngờ, không thể nào biết được những điều tốt hay xấu có thể xảy đến, nếu "biết trước được thì đã giàu", nên nhiều người thường chọn mua bảo hiểm nhân thọ để duy trì nguồn tài chính trước rủi ro tai nạn, bệnh hiểm nghèo, ung thư, thương tật toàn bộ vĩnh viễn hoặc thậm chí tử vong.
			- Trong ngôn ngữ lập trình cũng vậy, vì mục đích của Java khi được thiết kế là để đảm bảo an toàn cho dữ liệu, nên một khi dữ liệu đưa vào đã sai thì có tiếp tục xử lý cũng vô nghĩa.
			- Cũng giống như việc một khi đã sai chính tả thì mọi lập luận đều vô nghĩa, có cố đọc thêm thì cũng chỉ là để cho vui; hoặc một khi đề bài đã sai thì bài giải cũng vô nghĩa, nên sẽ được hưởng trọn vẹn điểm cho câu hỏi có đề bài sai.

		* Cách điều trị: mặc định, máy ảo Java sẽ gửi thông báo và sau đó tự động ngắt ứng dụng khi có điều bất thường diễn ra.
			- Vì vậy, ta phải chủ động báo trước cho máy ảo rằng có thể sẽ gặp tình huống ngoại lệ, nên đừng vội ngắt ứng dụng mà hãy bình tĩnh và nhẹ nhàng xử lý.
			- Lúc này, sau khi gửi thông điệp cảnh báo, máy ảo sẽ không vội ngắt ứng dụng ngay lập tức, mà cho cơ hội để "làm lại cuộc đời", nhưng ứng dụng phải cam kết với máy ảo rằng sẽ tự khống chế những tình huống ngoại lệ bằng cặp lệnh try-catch().
			- Tận dụng cơ hội này, bất cứ khi nào nhận được "giấy báo tử" từ máy ảo, ứng dụng sẽ làm lại cuộc đời bằng cách tự nhốt những câu lệnh có nguy cơ gây nguy hiểm vào trong một hộp cát (sandbox) - phần try {}, sau đó điều hướng CPU đến một nơi riêng biệt khác và tiến hành xử lý để không gây nguy hiểm đến xung quanh - phần catch() {}.
			-> Cam kết tự xử lý ngoại lệ bằng try-catch().
				(Tam ban triều điển / Seppuku / Harakiri - Tự xử lý ngoại lệ thay vì để bị khử - Ra đi theo cách của mình.)

			* Các trường hợp cần xử lý ngoại lệ để tránh phát sinh những lỗi không mong muốn:

				- Chuyển đổi dữ liệu không thành công.
					Ví dụ: yêu cầu nhập số nguyên -> nhập kí tự/chuỗi

				- Chia cho 0.
					Ví dụ: không sử dụng if để chặn số chia.

				- Đi vượt quá số lượng phần tử của mảng (out of bounds).
					Ví dụ: sử dụng vòng lặp để truy xuất đến phần từ ngoài mảng.

				- Null Pointer - Chưa gán giá trị cho biến đối tượng (biến con trỏ) mà vẫn chấm.

				- Server chết, kết nối mạng, truyền nhận dữ liệu qua mạng, cơ sở dữ liệu ở xa không ổn định hoặc bị rớt mạng. Tấn công qua mạng. SQL Injection...
					Ví dụ: đang tải tài nguyên thì rớt mạng, đang sao chép dữ liệu thì bị rút USB...

				- Nhập xuất với tập tin, USB...

				- ...

			* Bài thuốc: "Cứ thoả sức ăn chơi trong try, hậu quả cứ để catch() lo".

				try {
					// Nhốt những câu lệnh gây nguy hiểm
					// (hoặc những lời gọi hàm gây nguy hiểm)

					// Khi ngoại lệ thật sự xảy ra,
					// máy ảo sẽ khởi tạo một đối tượng "e"
					// và vẫn gửi thông điệp "e" này đến cho chương trình,
					// nhưng sẽ không lập tức ngắt chương trình
					// mà để cho lập trình viên tự giải quyết
					// (Đây là đối tượng chứa thông điệp
					//  về tình huống nguy hiểm mà máy ảo nắm bắt được,
					//  gồm chi tiết nguyên nhân gây ra)

					// Trong trường hợp không xảy ra ngoại lệ,
					// nếu cặp lệnh try-catch() nằm trong một vòng lặp,
					// để thoát được vòng lặp vô tận này,
					// ta có thể sử dụng câu lệnh break
					// hoặc thậm chí là return

					// -> Chứa các câu lệnh gây ra ngoại lệ

				} catch(Exception e) {

					// CPU sẽ chạy đến những đoạn lệnh trong này
					// nếu tình huống nguy hiểm thật sự xảy ra

					//	* Exception là một lớp chứa mọi sai sót

					// Exception e = new Exception("Có tội, hãy tự xử.");
					// (Thông điệp cũng là đối tượng,
					//  có thể mô tả được thuộc tính và phương thức.)

					// Có thể sử dụng đối tượng "e" kết hợp với dấu chấm
					// để đọc được nội dung của thông điệp này
					// (Giống hệt như lúc ứng dụng bị máy ảo ngắt)
					// e.printStackTrace();

					// Theo lẽ thường, máy ảo sẽ tự động ngắt ứng dụng,
					// nhưng nay chỉ gửi thông báo để ta tự xử lý

					// Sau khi đã giành được "quyền tự quyết",
					// thay thì thật sự tự mình kết liễu ứng dụng
					// thì ta sử dụng các câu lệnh để khắc phục hậu quả

					// Đối với lỗi liên quan đến việc nhập liệu,
					// ta có thể tự xử lý lỗi bằng cách:
					//	1. Gán một giá trị mặc định*.
					//	2. Thông báo lỗi và yêu cầu nhập giá trị tử tế.

					//		(Vì khi đã rơi vào được
					//		 khối lệnh try-catch()
					//		 đồng nghĩa là có nguy cơ
					//		 có thể chưa được gán dữ liệu,
					//		 nên trước khi thoát
					//		 thì bắt buộc phải có giá trị)

					// 	-> Xử lý khi trường hợp nguy hiểm diễn ra,
					//	   giúp những câu lệnh vô tội khác
					//	   không bị ảnh hưởng
					//		=> Trao cho ứng dụng cơ hội tự xử

					// Sau khi xử lý xong, mọi thứ trở lại bình thường,
					// những câu lệnh vô tội khác vẫn được thực thi
				}

				- Nếu trong khối lệnh try{} có nhiều câu lệnh gây phát sinh những loại ngoại lệ khác nhau.
					+ Ngoại lệ xảy ra trước sẽ vô hiệu hoá toàn bộ thực thi của những câu lệnh sau.
					+ Nhưng ta có thể sử dụng nhiều câu lệnh catch{} nối tiếp nhau để xử lý các loại ngoại lệ khác nhau.
					+ Nếu sau khi đã tìm hết tất cả các catch{} nhưng vẫn không tìm thấy phần xử lý cho loại ngoại lệ trong try{}, chương trình sẽ tự động tìm hướng xử lý ở các hàm Cha (là hàm Cha gọi đến hàm gây lỗi), nếu vẫn tiếp tục không tìm thấy thì chương trình sẽ bị ngắt vì tội: "Bắt không trúng ngoại lệ".
					+ Thứ tự đặt các khối catch{} cũng rất quan trọng, chỉ được phép đặt các lớp ngoại lệ Con trước và Cha sau, nếu đặt Cha trước (ví dụ: lớp Exception) thì những câu lệnh catch{} phía sau sẽ không bao giờ được thực hiện.

					Ví dụ:
						try {
							int age = sc.nextInt();	// NL 1
							int error = age / 0;	// NL 2
						} catch (InputMismatchException ime)  {
							// Xử lý cho NL 1
							System.out.println("Lỗi giá trị nhập");
						} catch (ArithmeticException ae) {
							// Xử lý cho NL 2
							System.out.println("Lỗi chia 0");
						}

				- Việc bắt ngoại lệ cũng có cấp bậc (Exceptions Hierarchy), nghĩa là ngoại lệ được bắt sẽ là ngoại lệ Cha, và những ngoại lệ Con của ngoại lệ này cũng sẽ được tự động bắt.
					+ Vì vậy, ta sẽ thường thấy một số khối catch{} chỉ bắt một ngoại lệ duy nhất là Exception, vì đây là Cha của tất cả các ngoại lệ.
					+ Điều này sẽ giúp không bỏ sót bất kì ngoại lệ nào, những sẽ gây khó khăn trong việc "khắc phục hậu quả" khi không thể có từng xử lý cho từng ngoại lệ cụ thể.

				- Bên cạnh đó, ta còn có thêm khối lệnh finally {} để luôn luôn thực hiện một số lệnh nào đó trước khi thoát try-catch() (thoát vì không xảy ra ngoại lệ hoặc thoát sau khi đã xử lý xong ngoại lệ), thường được sử dụng để đóng các kết nối hoặc lưu tập tin.

					try {...}

					catch {...}

					finally {
						// Những câu lệnh luôn được thực hiện
						// trước khi thoát quá trình xử lý ngoại lệ
					}

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Ngoại lệ là những tình huống bất thường,	│
│	xáy ra trong quá trình thực thi chương trình	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

	- Để xử lý ngoại lệ, ta có những cách:
		1. Sử dụng try-catch{} để trực tiếp xử lý.
		2. Sử dụng throws để ném (khai báo) ra ngoài hàm và cho nơi gọi hàm tự xử.

	- Có hai dạng ngoại lệ trong Java:

		0. Lỗi hệ thống (System Error): Do JVM ném ra và được đại diện bởi lớp Error.

		1. Ngoại lệ đã được kiểm tra / kiểm soát (Checked Exception / Compile-time Exception): Trình biên dịch sẽ lập tức thông báo ngay trong quá trình viết code.
			- Thường do những tác động bên ngoài gây ra và được đại diện bởi lớp Exception.
			- Được phát sinh từ các tình huống mà chương trình không thể kiểm soát được, như: kết nối mạng bị gián đoạn, lỗi đọc/ghi tệp tin (sai tên...) hoặc ngoại lệ SQL.
			- Java bắt buộc người dùng phải xử lý những ngoại lệ này, nếu không sẽ không cho biên dịch và thực thi chương trình.

			-> Bắt buộc phải xử lý hoặc khai báo ngoại lệ.

			Ví dụ: Đọc tập tin trên ổ đĩa.

				public static void fileReader(String fileName) {

					// 1.1. Thông báo và uỷ quyền cho nơi khác tự xử lý
					throws FileNotFoundException {...}


					// 1.2. Xử lý bằng try-catch{}
					try {
						// Báo lỗi khi gọi hàm khởi tạo của FileReader,
						// nguyên nhân là để phòng hờ việc
						// tập tin không tồn tại trên hệ thống
						FileReader reader = new FileReader(fileName);
					} catch (FileNotFoundException fnfe) {
						System.out.println("Tập tin không tồn tại");
					}

				}

		2. Ngoại lệ chưa được kiểm tra / kiểm soát (Unchecked Exception / Runtime Exception): Phải thật sự biên dịch và thực thi chương trình thì mới bắt gặp, chứ trình biên dịch không cảnh báo.
			- Thường do lập trình viên gây ra.
			- Được phát sinh từ các lỗi lập trình logic hoặc điều kiện không mong muốn như: NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException, ClassCastException...
			- Là những loại ngoại lệ không yêu cầu phải được xử lý bằng try-catch{} hoặc khai báo (throws).

			-> Không bắt buộc phải xử lý hoặc khai báo ngoại lệ.

			Ví dụ: Các loại ngoại lệ chưa được kiểm tra thường gặp.

				// NullPointerException
				String str = null;
				System.out.println(str.length());
					// Cố gắng truy cập vùng NULL (đối tượng không tồn tại)
					// bằng phương thức length()

				// ArrayIndexOutOfBoundsException
				int[] numbers = {1, 2, 3};
				System.out.println(numbers[4]);
					// Cố gắng truy cập vào phần tử
					// nằm ngoài phạm vi của mảng
					// bằng chỉ số của mảng

				// ArithmeticException
				int result = 10 / 0;
					// Cố gắng chia một số cho 0
					// (một số không xác định)

				// ClassCastException
				Object obj = new Integer(10);
				String str = (String) obj;
					// Cố gắng ép kiểu obj từ Integer thành String
					// khi hai kiểu này không liên quan đến nhau

----------------------------------------

Để biết được những câu lệnh sẽ gây ra những ngoại lệ gì:

	1. Đọc tài liệu.
	2. Thử biên dịch và xem thông báo lỗi của IDE.

----------------------------------------

	- Ngoài việc ném ngoại lệ được trả về từ một hàm và sau đó trực tiếp xử lý bằng try-catch(), ta cũng có thể sử dụng throws (và một từ khoá gần liên quan là throw).

		1. throw:
			- Được đặt bên trong hàm (hàm khởi tạo, hàm thông thường) và khối lệnh.
			- Đây là một hành động, trực tiếp ném ngoại lệ ra khỏi hàm.
			- Mỗi lần chỉ ném ra được một loại ngoại lệ.
			- Ngoại lệ được ném ra là một đối tượng được tạo ra bằng cách new() từ một lớp ngoại lệ nào đó.
			- Khi một ngoại lệ được ném, quá trình thực thi chương trình sẽ dừng lại và tìm kiếm khối catch{} phù hợp để xử lý ngoại lệ đó.

			-> Ném một ngoại lệ cụ thể ra bên ngoài hàm.

			- Việc ném ngoại lệ sẽ do Java thực hiện và thông điệp ngoại lệ cũng sẽ do Java tự tạo ra. Vì vậy, nếu muốn tạo ra một thông điệp ngoại lệ cho các hàm mà người dùng tự thiết kế, để giúp thông điệp lỗi được tường minh hơn.
				* Đảm bảo rằng Java không phải là người trực tiếp ném ngoại lệ.
					Bước 1: Tự tạo đối tượng từ lớp chứa ngoại lệ đó.
					Bước 2: Tự ném ngoại lệ bằng throw với thông điệp tuỳ chỉnh.

			Ví dụ: Trực tiếp ném ra ngoại lệ để try-catch().

				if (age < 13)
					// Biết trước loại ngoại lệ nào sẽ được ném
					// và lập tức tạo ra một đối tượng từ lớp ngoại lệ đó,
					// truyền thông điệp lỗi vào đối tượng ngoại lệ,
					// sau đó ném ra bên ngoài hàm bằng từ khoá throw
					// đi kèm với thông báo tuỳ chỉnh của người thiết kế
					throw new ArithmeticException("Account registration denied!");

			- Ngoài được sử dụng để ném những ngoại lệ sẵn có trong Java.
				+ Ta cũng có thể sử dụng throw để ném những ngoại lệ tự tạo.
				+ Vì Java sẽ không thể biết để ném những ngoại lệ tự tạo này.

				Ví dụ:
					class TuTaoException extends RuntimeException {...}

					// Xử lý trong hàm có nguy cơ gây ngoại lệ
					if (...)
						throw new TuTaoException("Ngoại lệ tự tạo");

		2. throws - con vịt (duck):
			- Được đặt nằm sau phần tham số của hàm.
			- Chỉ mang tính chất thông báo / khai báo sẽ có nguy cơ xuất hiện ngoại lệ (có thể có nhiều ngoại lệ cùng một lúc), còn xử lý thì sẽ do nơi gọi hàm tự xử lý.
			- Nếu hàm có thể gây ra nhiều ngoại lệ, ta có thể liệt kê các ngoại lệ sau từ khoá throws và cách nhau bởi dấu phẩy ','.
			- Cuối cùng, nếu liên tục đùn đẩy trách nhiệm thì hàm main() sẽ phải là nơi xử lý, nhưng nếu hàm main() vẫn tiếp tục né tránh thì hệ điều hành bắt buộc sẽ phải là nơi giải quyết (vì đây là nơi sẽ gọi main()).

			-> Khai báo ngoại lệ (Exception Declaration).
				(Duck - Đùn đẩy, né tránh trách nhiệm)

			Ví dụ: Thông báo rằng hàm này có nguy cơ ném ra ngoại lệ.

				static void checkAge(int age)
					throws TuTaoException,
					       ArithmeticException, 	
					       NullPointerException {
					...
					throw new TuTaoException("Ngoại lệ");
				}

----------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	try-catch{} để trực tiếp bắt và xử lý ngoại lệ, │
│	throw để ném một ngoại lệ cụ thể ra ngoài hàm,	│
│	throws chỉ để thông báo hàm có nguy cơ ngoại lệ	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[MẸO KHI NHẬP DỮ LIỆU TỪ BÀN PHÍM]

Ví dụ: cách thiết kế hàm nhận dữ liệu từ tham số và cách sử dụng linh hoạt bên trong hàm.

	// Thiết kế hàm để nhận vào số nguyên và đồng thời kiểm soát lỗi,
	// chỉ cần viết một lần, nhưng có thể sử dụng lại nhiều lần

	public static int getAnInteger() {
		int n;
		Scanner sc = new Scanner(System.in);

		do {
			try {
				// Có câu lệnh thông báo sẽ tiện dụng cho nơi gọi hàm
				// khi chỉ việc gọi và sử dụng mà không phải viết thêm,
				// nhưng cũng đồng thời gây thiếu linh hoạt
				// khi không biết đang nhập giá trị cho biến nào
				// nếu có nhiều hơn một nơi cần sử dụng hàm này
				System.out.print("Please input an integer: ");

				n = Integer.parseInt(sc.nextLine());

				// Câu lệnh để thoát khỏi vòng lặp
				// hay cụ thể hơn là thoát hẳn khỏi hàm
				// một khi đã có được thứ mình muốn - hàm nhận vào số nguyên
				return n;

					// Nơi gọi hàm
					// int width = MyToys.getAnInteger();

			} catch (Exception e) {
				System.out.println("Please input an integer!");
			}
		} while (true);
	}

	// Nâng cấp hàm để linh hoạt hơn trong việc hiển thị thông báo 
	// bằng cách tận dụng tham số
	public static int getAnInteger(String inputMsg) {
		int n;
		Scanner sc = new Scanner(System.in);

		do {
			try {

				// Lúc này,
				// nơi gọi hàm sẽ truyền tham số vào hàm là một chuỗi,
				// giúp thông báo và cho biết đang nhập giá trị cho biến nào
				System.out.print(inputMsg);

				n = Integer.parseInt(sc.nextLine());

				return n;

					// Nơi gọi hàm
					// int width = MyToys.getAnInteger("Please input the width of a rectangle: ");

				// Bên cạnh đó, nếu có thêm tham số
				//	(ví dụ: số dòng và cột của ma trận,
				//		số giá nhỏ nhất và lớn nhất...)
				// thì ta hoàn toàn có thể linh hoạt sử dụng câu lệnh if
				// để ngăn chặn những giá trị nằm ngoài biên
				// if (soDong < SO_DONG_TOI_THIEU || soDong > SO_DONG_TOI_DA)
				// if (soNguyen < MIN || soNguyen > MAX)

			} catch (Exception e) {

				// Tương tự với những câu thông báo lỗi,
				// ta vẫn có thể tạo riêng một tham số cho nó
				// và nhập thông báo tuỳ thích từ nơi gọi hàm
				// (ví dụ: errorMsg...)
				System.out.println("Please input an integer!");
			}
		} while (true);
	}

--------------------------------------------------------------------------------

[CÁC CÁCH NGĂN CHẶN LỖI KHI ĐƯA DỮ LIỆU VÀO CHƯƠNG TRÌNH]

Để đảm bảo dữ liệu đầu vào hợp lệ khi thông qua phễu và tránh cho việc sai sót cho quá trình xử lý sau này, ta có hai cách chặn nếu gặp phải dữ liệu cà chớn:

	1. Chặn khi nhập từ bàn phím: Chặn ngay khi thấy điều bất thường được đưa vào thông qua Scanner.

	2. Chặn thông qua phễu...

		2.1. Gán giá trị mặc định: Vẫn cho phép dữ liệu đổ vào thông qua qua phễu, nhưng nếu có điều bất thường thì sẽ sử dụng giá trị mặc định.

		2.2. Ném ra ngoại lệ: Vì đây là dữ liệu đầu vào, nên yêu cầu phải nghiêm ngặt.

==========================================================================================

[CÁC LỚP CÓ SẴN TRONG JDK]

Bên cạnh những lớp:
	- Scanner: Chuyên chứa các phương thức liên quan đến việc đưa dữ liệu vào máy tính.
	- Math: Chứa các phương thức liên quan đến toán học.

Trong JDK còn có sẵn một lớp với công dụng phát sinh ra những giá trị ngẫu nhiên, những thứ ngẫu nhiên sẽ được gom vào chung một nhóm tên là Random.
	- Yêu cầu phải tạo mới đối tượng để có thể sử dụng.
	- Trả về một đối tượng (con trỏ / vùng RAM) để tiếp tục gọi những hàm khác.

	* Cú pháp: Phát sinh giá trị ngẫu nhiên bằng lớp Random

		Random tênĐốiTượng = new Random();
        
		Kiểu-dữ-liệu tênBiến = tênĐốiTượng.nextKiểu-dữ-liệu();

		Ví dụ: Phát sinh các giá trị ngẫu nhiên trong khoảng từ ≈0 .. ≈50

			public static final double MAX_SPEED = 50;

			Random soNgauNhien = new Random();
			
			// Phương thức nextDouble() sẽ trả về
			// một giá trị ngẫu nhiên dưới dạng số thực,
			// nằm trong khoảng từ ≈0 .. ≈1
			double speedD = soNgauNhien.nextDouble() * MAX_SPEED;

			// Phương thức nextInt() sẽ trả về
			// một giá trị ngẫu nhiên dưới dạng số nguyên,
			// nằm trong khoảng từ 0 .. (MAX_SPEED - 1)
			int speedI = soNgauNhien.nextInt(MAX_SPEED);

(Ngoài ra, lớp Math cũng cung cấp nhiều phương thức khác để tự động phát sinh số ngẫu nhiên, đây đều là những phương thức static nên không cần phải tạo đối tượng trước khi sử dụng.)

==========================================================================================
==========================================================================================
==========================================================================================

[4 KỸ THUẬT LIÊN QUAN ĐẾN VIỆC THIẾT KẾ PHẦN MỀM HƯỚNG ĐỐI TƯỢNG]
[OOP PRINCIPLES / OOP CONCEPTS / FUNDAMENTAL CONCEPTS OF OOP / FOUR PILLARS OF OOP]

Các nguyên tắc lập trình hướng đối tượng (OOP principles) giống như một bộ tài liệu hướng dẫn - kim chỉ nam.
	- Giúp các nhà phát triển có thể thiết kế và xây dựng nên các hệ thống phức tạp.
	- Nhưng đồng thời vẫn dễ bảo trì, sửa đổi, mở rộng quy mô và có thể tái sử dụng nhờ vào việc mô-đun hoá các chức năng và mã nguồn được tổ chức một cách hợp lý.

==========================================================================================

[1. TÍNH TRỪU TƯỢNG / SÚC TÍCH - ABSTRACTION]

	* Trừu tượng (Abstract):
		1. [Tính từ] Liên quan đến sự trừu tượng (những điều khó hiểu và không thực tế), không cụ thể ra bên ngoài mà chỉ là những hình dung trong đầu.
		2. [Động từ] Loại bỏ đi những thứ phức tạp để đơn giản hoá vấn đề.
		3. [Danh từ] Là một bản tóm tắt và chỉ tập trung vào những ý chính của bản gốc.

	* Trừu tượng hoá (Abstraction):
		- Là quá trình đơn giản hoá một thứ cho đến khi không thể đơn giản hoá được nữa, mà không làm mất đi yếu tính của nó (méo mó sự thật).
		- Là quá trình giải thích một khái niệm, một vấn đề hay một hiện tượng phức tạp, khó hiểu nào đó bằng những ngôn từ đơn giản mà mọi người thường sử dụng trong cuộc sống hàng ngày.
			(* Tham khảo thêm: https://noidunglavua.com/truu-tuong-hoa-la-gi)

		-> Quá trình chuyển đổi từ cụ thể sang tổng quát bằng cách chỉ tập trung vào những đặc điểm chung và loại bỏ đi những đặc điểm riêng.
	
		(Đây là bước quan trọng nhất, vì nếu không hình dung được thì sẽ không có cách nào để diễn đạt lại được.)

	* Khái quát hoá / Tổng quát hóa (Generalization): Là một hình thức (cách thức tiến hành, quá trình thực hành) trừu tượng hoá bằng tư duy quy nạp - từ riêng đến chung (lưu lại dữ liệu, từ đó hình thành thái độ / cách phản ứng tương ứng).
		- Khái quát (gom những đặc điểm chung) để tập hợp nhiều đối tượng khác nhau và có mối quan hệ với nhau vào cùng một lớp, từ đó chia sẽ những đặc điểm chung.
		- Đem lại góc nhìn chung về tất cả các đối tượng trong cùng một lớp.
		- Dễ dẫn đến thiên kiến nếu chỉ dựa trên những dấu hiệu chung giống nhau để nói về các đối tượng.

		-> Quá trình tạo nên cách giải quyết có thể áp dụng chung cho nhiều trường hợp.

		Ví dụ 1: Bản đồ với tỉ lệ thu nhỏ là kết quả sau khi đã điều chỉnh nội dung và lược bỏ bớt các chi tiết so với tỉ lệ thực tế, nhưng vẫn truyền tải được thông tin về không gian địa lý.

			- Đơn giản hóa những đối tượng địa lý thành những ký hiệu và biểu tượng dễ hiểu, chẳng hạn như:
				+ Máy bay -> Sân bay
				+ Mỏ neo -> Cảng biển
				+ Đường nét rời / nét đứt -> Ranh giới tỉnh
				+ Hình tam giác -> Sắt / Thiết
				+ ...

		Ví dụ 2: Các căn hộ dịch vụ thường sẽ được thiết kế theo một bản thiết kế (trừu tượng).
			- Mặc dù có thể có đôi chút khác biệt trong quá trình thi công (ví dụ: Màu sơn, hoạ tiết trang trí, nội thất...), nhưng tất cả đều phải tuân thủ theo thiết kế về diện tích của bãi giữ xe, bếp, phòng sinh hoạt...
			- Để khi có xảy ra sự cố (ví dụ: Hoả hoạn...) thì việc khắc phục hậu quả cũng sẽ đơn giản hơn, vì cấu trúc của các toà nhà đã được thống nhất và đồng bộ.

	"Khi bắt gặp những vấn đề có tính lặp lại..
		- Thay vì phải giải quyết riêng cho từng trường hợp cụ thể, con người sẽ bắt đầu trừu tượng hoá và sau đó tổng quát hoá.
		- Điều này sẽ giúp tạo ra một giải pháp chung, giúp xử lý hàng loạt những vấn đề thường xuyên lặp lại."

	"Khi tiếp cận với một vấn đề trừu tượng, mỗi cá nhân sẽ bắt buộc phải tự diễn giải và bổ sung những ví dụ từ chính cuộc đời của mình, giúp mỗi cá nhân có một cái nhìn rất riêng."

------------------------------------------------------------

Tiếp cận và giải quyết vấn đề theo tư duy chia một vấn đề phức tạp thành những vấn đề nhỏ hơn, giải quyết từng vẫn đề cụ thể xong thì vấn đề phức tạp sẽ tự động được giải quyết (buttom up).

	- Một trong những nguyên tắc và ưu điểm của lập trình hương đối tượng là "tránh cụ thể hoá, mà hãy tổng quát hoá (trừu tượng)", vì càng tổng quát thì việc mở rộng sau này sẽ càng dễ dàng.

	- Từ những đối tượng cụ thể trong thế giới thực, sau đó tổng quát hoá lên (bỏ đi những chi tiết khác biệt, chỉ giữ lại những điều cốt lõi) và áp dụng ngược trở lại vào hệ thống.

	-> Chấp nhận từ bỏ cái riêng để giữ lại cái chung.
		(Hy sinh lợi ích ngắn hạn cho đại cục.)

* Tính trừu tượng / súc tích / cô đọng (Abstraction): Là cách tư duy (suy nghĩ) để chuyển đổi và biểu diễn lại những thông tin phức tạp trong cuộc sống thành những thứ đơn giản hơn, nhưng vẫn đảm bảo truyền tải đầy đủ ý nghĩa ban đầu của sự vật.

	- Là cách nói về những thứ phức tạp trong cuộc sống thông qua một thứ khác đơn giản hơn, biểu diễn lại những thứ phức tạp theo cách đơn giản hơn.
		(Using a simple things to represent the complex things...)

	- Nắm bắt (hình dung trong đầu) và rút trích, chắt lọc ra những dữ liệu tiêu biểu / quan trọng / cốt lõi nhất của một đối tượng phức tạp trong cuộc sống, sau đó biểu diễn lại chính đối tượng đó theo cách mà ai cũng có thể hiểu.
		(Extract the significant features / Characteristic of a complex things to form a simple / easy catching things...)

	- Đích đến cuối là đơn giản hơn, nhưng vẫn không làm mất ý nghĩa gốc.
		(...without losing the original meaning of the complex ones)

	- Là cách mô tả ngắn gọn mọi thứ, nhấn mạnh vào những điều cốt lõi (bằng cách lược bỏ đi những chi tiết không cần thiết, không liên quan) để sao cho ai cũng hiểu đúng và đủ, giúp dễ dàng kiểm soát khi tương tác và giao tiếp với nhau hiệu quả hơn hơn khi bàn về sự vật.

	- Phải hình dung được trong đầu về vật thể, dù có thể không xuất hiện trước mặt.

	- Tương tác với đối tượng được rút gọn cũng tương đương với việc tương tác với đối tượng gốc, từ đó cũng sẽ giúp tiết kiệm công sức hơn.

	- Ngoài ra, sau khi đã trừu tượng hoá, nếu có sự nhầm lẫn - Tam sao thất bản, rất có thể là do chúng ta đã chắt lọc và biểu diễn lại dữ liệu chưa được tốt.

	-> Biểu diễn lại thông tin phức tạp theo cách đơn giản hơn, nhưng vẫn giữ nguyên "chất".
		=> Cách thức tìm và lựa chọn ra những đặc điểm và hành vi quan trọng nhất của một lớp / khuôn.
		(Tập trung vào khả năng có thể làm thay vì cách thức thực hiện.)

	Ví dụ: Tính trừu tượng xuất hiện trong cuộc sống.

		- Một bệnh nhân cũng có rất nhiều thông tin, nhưng bệnh viện chỉ quan tâm đến một số thông tin như: Mã bệnh nhân, tên, năm sinh, số điện thoại, dị ứng, tiền sử bệnh, đơn thuốc...
			(Sinh viên, Giảng viên, nhân viên... đều tương tự.)

		- Trả bài đầu giờ: Nắm bắt nội dung buổi học, lượt bỏ đi những thông tin chi tiết và chỉ giữ lại những thông tin quan trọng nhất, sau đó diễn đạt lại để người nghe gợi nhớ lại được nội dung trong buổi học trước.

		- Tivi: Chỉ quan tâm đến việc có thể phát ra hình ảnh và âm thanh, có thể dò kênh, có thể kết nối với internet hoặc không...

Trong lập trình, tính trừu tượng yêu cầu mã nguồn phải được thiết kế ở mức khái niệm chung chung (vĩ mô), không nên đi vào chi tiết.
	- Từ đó sẽ giúp tăng khả năng tái sử dụng trong các ngữ cảnh khác nhau.
	- Cách sử dụng sẽ không bị ảnh hưởng, dù cho chi tiết triển khai bên trong bị thay đổi.

	Ví dụ: Thay vì thiết kế mã nguồn chỉ tương tác được với một cơ sở dữ liệu cụ thể, ta hãy nên thiết kế làm sao để có thể giao tiếp được với bất kỳ cơ sở dữ liệu nào.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Từ những đối tượng với rất nhiều thông tin; thông qua việc rút trích, 	│
│	liệt kê ra những điểm đặc trưng nhất để đại diện cho nhóm đối tượng này	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――
│	Đơn giản hoá những thứ phức tạp,	│
│	nhưng vẫn giữ nguyên được ý nghĩa	│
―――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――
│	Lớp là sự trừu tượng hoá các đối tượng	│
―――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

Các cơ chế trừu tượng hóa (cách phân loại):

	1. Trừu tượng hóa về mặt dữ liệu (Data Abstraction): Những thông tin chung (thuộc tính và phương thức) và quan trọng nhất của đối tượng sẽ được gom vào một lớp, sau đó chỉ hiển thị ra bên ngoài những thông tin cần thiết để sử dụng và che giấu đi những thiết kế chi tiết.
		-> Tính trừu tượng (Abstraction) - Giấu đi dữ liệu và cách thức xử lý của hàm.

	2. Trừu tượng hóa về mặt hành vi (Behavioral Abstraction): Cha chỉ có tên hàm, không có code bên trong, các lớp Con sẽ phải tự mình thiết kế xử lý cho hàm bằng phần khung (tên hàm, danh sách tham số và kiểu dữ liệu trả về) - quy trình mà Cha đã dựng sẵn.
		-> Lớp trừu tượng (Abstract class) - Bỏ ngõ việc xử lý của hàm lại cho nơi khác.

	(???) Procedural / Process Abstraction

--------------------------------------------------------------------------------

	[LỚP TRỪU TƯỢNG & PHƯƠNG THỨC TRỪU TƯỢNG
	 ABSTRACT CLASS & ABSTRACT METHOD]

* Trừu tượng / Ý niệm (Abstract): Tuy có tồn tại, nhưng lại không cụ thể để có thể chạm vào được, mà chỉ dừng lại ở mức mô tả ý tưởng / khái niệm.
	-> Biết là có, nhưng không "nắm" được gì cả.
	-> Một khái niệm chung chung (không cụ thể) chỉ để thông báo về sự tồn tại.
		=> Chỉ nói chứ không làm.
		("Chỉ được cái nói thôi, ngoài ra đâu có làm được cái gì đâu.")

* Hiện thực hoá / Triển khai (Implement): Hoàn thiện những điều còn dang dở khi trừu tượng.

=> Các Vua Hùng đã có công dựng khung, Bác cháu ta phải cùng nhau viết code
	(Các Vua Hùng đã có công dựng nước, Bác cháu ta phải cùng nhau giữ lấy nước).

------------------------------------------------------------

Sự trừu tượng đạt được thông qua việc sử dụng các lớp trừu tượng, giao diện (Interface) và phương thức trừu tượng.

Nếu lớp là cách để gom các đối tượng vào chung một khuôn; thì lớp trừu tượng sẽ là hình thức phân loại và gom nhóm các lớp có điểm tương đồng với nhau lại để tạo ra một khuôn mới - ở mức cao.

Lớp trừu tượng (Abstract Class) phải thoả một trong các tiêu chí:
	1. Có từ khoá "abstract" ở tên lớp (và ở phương thức nếu có thêm phương thức trừu tượng).
	2. Có thể không có hoặc có ít nhất một phương thức trừu tượng...
		- Để trống phần xử lý, chỉ có tên hàm và danh sách tham số (phần định nghĩa / chứ ký hàm - Method Signature).
		- Phần triển khai (xử lý và trả về kết quả - phần hiện thực hoá) sẽ do một lớp khác (kế thừa từ lớp trừu tượng) đảm nhận.

	* Cú pháp:

		- Tại lớp Cha - Trừu tượng hoá:

			public abstract TênLớpCha {

				// Các hàm trừu tượng (không có code)
				//...
			}

		- Tại lớp Con - Hiện thực hoá:

			// Mỗi Con chỉ được phép kế thừa từ một Cha
			public class TênLớpCon extends TênLớpCha {

				// Tất cả các hàm vượt mặt (triển khai code)
				// mà ta đã thông báo sẽ hiện thực trước đó
				@Override

			}

	- Lớp trừu tượng mang ý nghĩa rằng đây chỉ mới là một bản phác thảo / thử nghiệm, chưa thể chính thức xử lý dữ liệu, nên cần phải được đánh dấu bằng từ khoá "abstract" vào ngay sau phạm vi truy cập của lớp và của phương thức.
		+ Thông thường, thuộc tính sẽ không có tính trừu tượng, vì chỉ việc đưa giá trị cụ thể vào là xong.
		+ Trừu tượng là điều chỉ phương thức (và lớp) mới có, vì tuỳ từng lớp mà những xử lý cho lớp đó cũng sẽ khác nhau.

	- Mục đích không phải là để trực tiếp tạo ra đối tượng mới, mà lớp trừu tượng được sử dụng để làm cơ sở và cho phép những lớp khác kế thừa, sau đó tự mình thiết kế lại những phương thức bằng phương pháp vượt mặt (Override - dẫn đến tính đa hình).

		Ví dụ 1: Sau khi phát hiện những lớp như: ConMèo, ConChó, ConGấu, ConHeo, ConChimCánhCụt... đều có chung một số đặc điểm.
			- Chúng ta sẽ tạo ra một lớp trừu tượng ĐộngVật và liệt kê ra những hành vi chung như: di chuyển, kiếm ăn, vui chơi, nghỉ ngơi... cho tất cả các loài động vật.
			- Sau này, tuỳ vào những lớp khác nhau mà sẽ có những cách thức triển khai khác nhau ở mỗi con vật.

			// Lớp trừu tượng ĐộngVật
			public abstract class DongVat {
				
				// Hàm trừu tượng không hề có xử lý bên trong,
				// những lớp ConMèo, ConChó, ConGấu...
				// sẽ phải tự mình thiết kế hàm
				public abstract void phatRaTiengKeu();
			}

		Ví dụ 2: Trong một công ty, đa phần nhân viên đều sẽ có lương.
			- Nhưng những nhân viên với chức vụ khác nhau sẽ có những cách tính lương khác nhau.
			- Vì vậy, công thức tính lương cho lớp NhânViên sẽ là trừu tượng, sau đó tuỳ vào những lớp nhân viên cụ thể như QuảnLý, LậpTrìnhViên, KiểmThửViên... mà sẽ có những quy tắc và cách tính cụ thể của họ.

			// Lớp trừu tượng NhânViên
			public abstract class NhanVien {
				
				// Hàm trừu tượng không hề có xử lý bên trong,
				// những lớp QuảnLý, LậpTrìnhViên, KiểmThửViên...
				// sẽ phải tự mình thiết kế hàm
				public abstract double tinhLuong();
			}
	
	- Ngoài việc có thêm phương thức trừu tượng và không thể trực tiếp tạo đối tượng từ lớp này, lớp trừu tượng vẫn giống như một lớp thông thường.
		+ Vẫn có thể có thuộc tính và phương thức (khởi tạo, tĩnh...).
		+ Vẫn được phép kế thừa từ lớp khác (thông thường và trừu tượng).

	- Cũng giống với việc không thể bán một sản phẩm mà đang có một tính năng của nó chỉ mới ở giai đoạn lý thuyết...
		+ Một lớp cũng sẽ không thể trực tiếp tạo đối tượng nếu được khai báo là lớp trừu tượng, mà phải thông qua những lớp Con kế thừa từ lớp này.
		+ Nhưng cũng vì không thể tạo mới đối tượng trực tiếp từ lớp trừu tượng, mà lớp này cũng không nhất thiết phải có phễu (nhưng vẫn có thể có); lúc này, trình biên dịch sẽ tự động cung cấp một hàm khởi tạo mặc định.
		+ Một lớp trừu tượng có thể có một hoặc nhiều phễu để khởi tạo giá trị cho thuộc tính vì lớp trừu tượng vẫn có thuộc tính, phễu sẽ được gọi thông qua từ khoá super() khi tạo mới đối tượng ở lớp Con kế thừa từ lớp trừu tượng.

	- Tất nhiên, lớp trừu tượng không nhất thiết phải có hàm trừu tượng bên trong (giống như việc sinh viên không phải cứ cắm đầu đi học, giảng viên không phải cứ cắm mặt dạy học), vì vẫn có trường hợp lớp trừu tượng "có tiếng mà không có miếng".
		+ Đôi khi, dù không có bất kì hàm trừu tượng nào, nhưng đằng sau tên lớp vẫn có chứa từ khoá "abstract" và đây vẫn sẽ được xem là lớp trừu tượng.
		+ Còn một khi có xuất hiện hàm trừu tượng và dù chỉ là duy nhất một hàm trừu tượng, thì lớp đấy bắt buộc cũng phải là lớp trừu tượng.

	- Nếu lớp Con kế thừa từ lớp Cha trừu tượng này, đồng nghĩa với việc trong lớp Con cũng đang chứa những hàm trừu tượng, từ đó dẫn đến hệ quả:
		+ Nếu lớp Con cố tình không hiện thực hoá một trong số các hàm trừu tượng thì lớp Con cũng sẽ được xem là lớp trừu tượng.
		+ Nhưng nếu lớp Con quyết định hiện thực hoá bằng cách vượt mặt các phương thức trừu tượng của Cha, sẽ giúp cho các đối tượng sau này tự do hơn trong các hành động.

	- Lớp trừu tượng không thể có phạm vi truy cập là private và cũng không thể nào là static.
		+ Không thể có phạm vi truy cập là private vì nếu phương thức này đã là trừu tượng (thiếu phần thực thi), mà những lớp Con khi kế thừa lại không có cách nào để truy cập và vượt mặt (bổ sung phần thực thi), thì phương thức này sẽ trở thành trừu tượng vĩnh viễn.
		+ Không thể nào là static vì phương thức static là phương thức có thể sử dụng trực tiếp thông qua tên lớp mà không cần tạo đối tượng (yêu cầu phải là một lớp hoàn chỉnh), trong khi phương thức trừu tượng lại không có phần thực thi và cần phải có một lớp khác triển khai những phần trừu tượng chứ không thể nào tạo mới đối tượng trực tiếp từ lớp trừu tượng, nên nếu sử dụng tên lớp trừu tượng để trực tiếp gọi phương thức "static abstract" thì sẽ gây nên mâu thuẩn khi phương thức này đang được sử dụng trong trạng thái "không hề có xử lý gì".

	-> Chỉ là bàn phác thảo, chưa thể xử lý được và phải chờ để hoàn thiện.
		(Đã có hàm trừu tượng, phải chịu làm lớp trừu tượng - Tay đã nhúng vào chàm, khó mà rửa sạch được.)
		=> Được sử dụng để phân loại lớp.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Lớp trừu tượng là cách phân loại và gom nhóm các lớp	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Lớp trừu tượng chỉ đề ra những hành vi chung nhất,	|
│	làm nền để những lớp khác kế thừa và hiện thực hoá	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

* Dấu hiệu để nhận biết một lớp là trừu tượng: Khi nói về đối tượng được xuất phát từ một lớp nào đó...
	1. Nếu đã cụ thể và biết được hình dáng -> Không là trừu tượng.
	2. Nếu vẫn cần giải thích thêm -> Là trừu tượng.

	Ví dụ: Phân biệt cụ thể và trừu tượng.

		- Sử dụng [đối tượng] phương tiện giao thông để đi học.
			-> "Phương tiện giao thông" là trừu tượng.

		- Sử dụng [đối tượng] xe đạp để đi học.
			-> "Xe đạp" là cụ thể.

--------------------------------------------------------------------------------

* Lưu ý: Không được nhầm lẫn giữa tính trừu tượng (abstraction) với lớp trừu tượng (abstract class).

	- Tính trừu tượng (Abstraction):
		- Sự rút trích và tổ chức lại thông tin để cho ra được những đặc điểm nổi bật.
		- Tập trung vào việc khái niệm hoá và cố gắng thiết kế mã nguồn ở mức cao để hoạt động tốt trong mọi hoàn cảnh.

	- Lớp trừu tượng (Abstract class):
		+ Phân loại lớp và vẫn được xem là một lớp cụ thể để ta có thể tương tác.
		+ Tuy là một lớp cụ thể và không thể tạo ra đối tượng, nhưng cho phép kế thừa để hiện thực hoá những gì trừu tượng và sau đó sẽ được phép tạo ra đối tượng.

==========================================================================================

[2. TÍNH ĐÓNG GÓI / CÔ LẬP - ENCAPSULATION]

Là hệ quả / kết quả của quá trình trừu tượng hoá, là cách thức thực hiện việc trừu tượng sau khi đã rút trích ra được những thông tin đặc sắc nhất về đặc điểm và hành vi của đối tượng (sau đó gói gọn các cơ chế chi tiết về cách thức hoạt động phức tạp vào bên trong, chỉ cung cấp ra bên ngoài những điều đơn giản nhất - giới hạn khả năng giao tiếp với bên ngoài).
	- Để nhận diện một đối tượng, thường sẽ thông qua đặc điểm và hành vi.
	- Tính trừu tượng (abstraction) sẽ giúp ta rút ra được những đặc trưng.
	- Những đặc điểm và hành vi đặc trưng sau đó sẽ được gom chung vào một đơn vị (lớp / đối tượng).
	- Từ đó giúp che giấu đi những thông tin bí mật và chỉ cho phép tương tác với thế giới bên ngoài khi cần thiết.
	- Từ đây, đảm bảo đối tượng chỉ làm đúng phần việc đã được thiết kế / chỉ định.
	- Khả năng che giấu dữ liệu là một trong những nguyên tắc và ưu điểm của lập trình hương đối tượng bên cạnh khả năng tổng quát hoá (trừu tượng).

	-> Đóng gói lại những gì đã trừu tượng hoá.

	(Giống như một đối tượng ngoài đời sẽ có riêng cho mình một "vỏ bọc",
	 những thứ phức tạp đều được xử lý ngầm bên trong và trả ra kết quả.)

* Tính đóng gói / cô lập (encapsulation): Là kỹ thuật gom biến (dữ liệu / thông tin) và hàm (xử lý dữ liệu) có liên quan với nhau vào trong một khuôn (class), để từ đó hình thành nên "chất riêng" của đối tượng.

	- Mọi thông tin chi tiết của một đối tượng sẽ nằm gọn bên trong một lớp, giúp đảm bảo rằng những thông tin ấy thuộc về đúng một nhóm đối tượng nào đó - Nước sông không phạm nước giếng.
	
	- Dù đã ẩn tất cả các thông tin, nhưng vẫn sẽ chừa chỗ để có thể giao tiếp với bên ngoài, đó là thông qua các phương thức.

	- Giúp che giấu đi những chi tiết bên trong và chỉ hiển thị ra bên ngoài khi cần thiết, đại diện cho một đối tượng riêng biệt với những đặc tính và phương thức nằm trọn vẹn trong một khu vực/đơn vị (unit).
		+ Mỗi đối tượng sẽ có riêng cho mình một "vỏ bọc" bên ngoài (Black box), giúp ẩn giấu đi những chi tiết phức tạp bên trong, để chủ yếu phục vụ cho mục tiêu giao tiếp.
		+ Khi này, việc tạo khuôn đã được xem là đóng gói và người dùng chỉ cần biết cách sử dụng, không cần biết cách cấu thành.
		+ Mỗi hành động sẽ thường được đóng gói và gán liền với đối tượng, giống như một cách để giới hạn phạm vi hoạt động của đối tượng, đối tượng không thể làm những gì mà mình không có khả năng hoặc không được phép (tránh những sự can thiệp trái phép vào dữ liệu).
	
	- Tuy được nhân bản từ cùng một khuôn, nhưng mỗi đối tượng sẽ có một vùng RAM khác nhau, độc lập và không làm ảnh hưởng đến những đối tượng khác nếu bản thân có thay đổi.

	-> Kỹ thuật gom/đóng gói/cô lập các thuộc tính và phương thức vào trong cùng một khuôn (đơn vị), để sau đó tạo nên một đối tượng với các đặc tính và hành động duy nhất / riêng biệt.
		=> Kỹ thuật đóng gói mọi thứ lại thành một đơn vị.
			(Che những chỗ cần che, hở những chỗ cần hở; nên biết cách sử dụng hơn là biết cách cấu thành.)

Kết hợp nhiều thuộc tính và phương thức vào khuôn.

	Ví dụ 1: Trong các thiết bị điện tử, để phục vụ tốt nhất cho việc sử dụng.
		- Ẩn giấu - Cấu thành: Các linh kiện điện tử...
		- Hiển thị ra - Sử dụng: Màn hình, loa, máy ảnh, các cổng kết nối...
		-> Che giấu chi tiết bên trong, quy định cách thức giao tiếp với bên ngoài.

	Ví dụ 2: Trong máy ATM, để phục vụ tốt nhất cho các giao dịch liên quan đến tiền.
		- Ẩn giấu đi - Cấu thành: Cấu trúc bên trong của máy đọc thẻ, khay nhận tiền, khe rút tiền, máy in hoá đơn, két đựng tiền, bộ phận kiểm tra độ dày của tiền...
		- Hiển thị ra - Sử dụng: Bàn phím, màn hình...
		-> Che giấu chi tiết bên trong, quy định cách thức giao tiếp với bên ngoài.

	Ví dụ 3: Trong xe máy, để phục vụ tốt nhất cho việc sử dụng phương tiện.
		- Ẩn giấu đi - Cấu thành: Dây, đường ống, khung...
		- Hiển thị ra - Sử dụng: Bửng xe / yếm xe, các bút bấm, tay ga...
		-> Che giấu chi tiết bên trong, quy định cách thức giao tiếp với bên ngoài.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Đóng gói những đặc điểm và hành vi quan trọng vào một đơn vị,		│
│	sau đó che giấu thông tin bí mật, chỉ mở cửa để tương tác khi cần thiết	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Đóng gói thông tin vào một nơi,					│
│	quy định những gì được phép và không được phép công khai	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

Khi không phải toàn bộ thông tin cần thiết đều sẵn có, để có được thông tin dựa trên sự tính toán của những thông tin sẵn có, ta có các cách:

	1. Lấy thông tin sẵn có bằng phương thức getter() và sau đó tự tính toán để ra được thông tin cần thiết.

	2. Để đối tượng tự tính toán, vì họ là người nắm được và hiểu rõ nhất về thông tin đó, sau đó chỉ việc sử dụng kết quả mà đối tượng đã tự tính toán.

		- Vì toàn bộ những thông tin ấy đều là của đối tượng, nên đối tượng phải là người có được đầy đủ và hiểu rõ nhất về những thông tin đó.

		- Để cung cấp tiện ích ra bên ngoài, bên nào có nhiều thông tin thì hãy cứ để người ấy xử lý, tránh để một bên khác xử lý giùm.
			+ Hàm được sử dụng để xử lý dữ liệu, mà đối tượng sẽ là nơi nắm rõ và có nhiều dữ liệu nhất.
			+ Vì vậy, cùng với thuộc tính, hàm nên gắn liền với / thuộc về lớp và đối tượng.
		
		- Danh sách những đối tượng cũng là một dạng thông tin, vì vậy, đây cũng được xem là thuộc tính và nên được lưu trữ bên trong đối tượng.

			Ví dụ: Ai có nhiều thông tin thì người đấy nên xử lý thông tin.
				- Học sinh.
					+ Đang tuổi ăn, tuổi học.
					+ Được học nhiều môn học trong trường.
					+ Có trí nhớ tốt.
					-> Đi học và thành tài.

				- Doanh nhân.
					+ Đến lúc ra xã hội và kiếm tiền.
					+ Có nhiều kinh nghiệm trong thương trường.
					+ Có máu kinh doanh.
					-> Làm ăn và phát đạt.

		-> Thuộc tính và phương thức nên được đặt bên trong khuôn để xử lý những thông tin của chính đối tượng.

------------------------------------------------------------

	* Thuộc tính dẫn xuất (Derived field): Những đặc điểm được tính toán dựa trên những đặc điểm khác.

		- Nên cân nhắc khi thiết kế thuộc tính dẫn xuất.
			+ Phải đảm bảo dữ liệu nhập vào cho thuộc tính dẫn xuất phải đúng với kết quả được tính ra từ công thức.
			+ Phải đảm bảo dữ liệu của thuộc tính dẫn xuất vẫn luôn đúng, dù cho các dữ liệu liên quan có thay đổi giá trị.

		- Mọi việc xử lý, tính toán là việc của phương thức. Vì vậy, tốt nhất, những thuộc tính dẫn xuất nên được tính toán và trả về kết quả thông qua hàm.

		- Kết quả của thuộc tính dẫn xuất chỉ được tính toán thông qua hàm khi có yêu cầu.
			+ Đảm bảo luôn luôn chính xác.
			+ Nhưng tốn thời gian để tính toán.

		-> Để đảm bảo tính đồng bộ / nhất quán (consistency) trong thiết kế dữ liệu, ai có nhiều dữ liệu thì người đấy nên xử lý dữ liệu.

		Ví dụ 1: Trong hình chữ nhật.
			- Đặc điểm diệnTích được tính toán bằng công thức "chiềuDài * chiềuRộng".
			- Phải đảm bảo tính nhất quát của dữ liệu...
				+ Tuyệt đối không được cho phép nhập cả ba thuộc tính chiềuDài, chiềuRộng và diệnTích, vì diệnTích nhập vào sẽ chưa chắc sẽ trùng với kết quả tính toán được từ công thức tính diện tích.
				+ diệnTích phải được cập nhật theo khi chiềuDài hoặc chiềuRộng bị thay đổi.

		Ví dụ 2: Trong kinh doanh, buôn bán.
			- Được biết: tổngTiền = sốLượng * đơnGiá
			- Khi sốLượng hoặc đơnGiá bị thay đổi thì tổngTiền phải được cập nhật theo.

		Ví dụ 3: Trong việc dạy dỗ trẻ em.
			- Được biết: tuổiHiệnTại = nămHiệnTại - nămSinh
			- Thay vì nói luôn cho trẻ biết tuổi của mình, nên dạy trẻ cách tính tuổiHiệnTại để trẻ có thể tự suy ra cho tất cả các năm.

		Ví dụ 4: khi họp mặt gia đình vào dịp Tết Nguyên Đán.
			(Gặp một người họ hàng định cư ở nước ngoài đã lâu, nay mới về quê.)

			A: Chào chị, lâu rồi mới gặp, chị vẫn khoẻ chứ?
			B: Chị vẫn khoẻ, cảm ơn em.

			A: Con của chị hả, bé bao nhiêu tuổi rồi ạ?
			B: Bé gái đầu lòng của chị đấy, được 32 tháng rồi em.

			A: ("12 nhân cho bao nhiêu để ra được 32 ta?")
			A: Thôi, chị nói luôn tuổi cho nó nhanh giúp em ạ!

			-> Mục tiêu cuối cùng là biết tuổi.

		Ví dụ 5: Thiết kế hàm tính tuổi ngay bên trong khuôn.

			public class Dog {
				// private int age; // Không nên,
						    // vì sẽ bị liên tục thay đổi qua các năm
				private int yob;
				...
				
				// Nên được tính toán theo công thức
				// để ai cần biết thì chỉ việc hỏi trực tiếp là xong
				public int getAge() {
					return getCurrentYear() - yob;
				}
			}

--------------------------------------------------------------------------------

	[PHẠM VI TRUY CẬP / QUYỀN TRUY XUẤT]
	[ACCESS MODIFIER / ACCESS SPECIFIER / ACCESS LEVEL]

	Trong cuộc sống, theo lẽ tự nhiên, con người thường có xu hướng "đẹp khoe xấu che" - giấu đi những điều riêng tự, chỉ khoe ra những thứ mà bản thân tự tin và muốn người khác nhìn thấy.

	Mặc định, vì lý do bảo mật, các đối tượng sẽ giấu các thông tin và hành động (thuộc tính và phương thức) của mình cho đến khi cần thiết phải hiển thị ra.
		-> Các đối tượng khi mới tạo ra sẽ giấu hầu hết tất cả các thông tin.

		Ví dụ 1: một đối tượng con người ngoài đời thật.
			- Sẽ che giấu thuộc tính thuNhập
			- Sẽ che giấu phương thức gianLận()

		Ví dụ 2: một đối tượng con người trên mạng xã hội.
			- Sẽ che giấu thuộc tính tênThật, sởThích...
			- Sẽ công khai phương thức nhắnTin(), thảBiểuTượngCảmXúc()...

	Đối với những thông tin được công khai, nếu không muốn bị nhầm lẫn giữa các thông tin ấy thì ta phải sử dụng tên đối tượng kết hơp với dấu chấm "." khi mô tả về thông tin cần sử dụng, vì dấu chấm là con trỏ với nhiệm vụ đi đến toạ độ được chỉ định để lấy thông tin.

		Ví dụ: cách sử dụng con trỏ trong lập trình cấu trúc và lập trình hướng đối tượng

			// * Lập trình cấu trúc
				// Cách sử dụng: *tênBiếnConTrỏ
			int a = 100;
			int* pointer = &a;
			printf("a has value of %d\n", *pointer); // In ra 100


			// * Lập trình hướng đối tượng

			// Trong lớp Dog
			public class Dog {
				public String name; // Công khai thuộc tính tên
				private int yob;    // Che giấu thuộc tính năm sinh

				// Hàm khởi tạo Dog(...) {...}

				// Hàm công khai năm sinh
				public int getYob() {
					return yob;
				}
			}

			// Trong hàm main()
				// Cách sử dụng: tênBiếnConTrỏ.thuộcTính/phươngThức
			public static void main(String[] args) {
				Dog cauVang = new Dog("Cậu Vàng", 1943, 12.0);

				String s = cauVang.name;
				cauVang.getYob();
			}

------------------------------------------------------------

	* Quyền được phép truy cập/truy xuất ("sờ") thông tin của một đối tượng (truy cập vào lớp, thuộc tính và phương thức) thông qua dấu chấm "." khi đứng từ bên ngoài lớp (sử dụng - gọi đến lớp):

		- private: che giấu hết tất cả thông tin, chỉ nơi định nghĩa ra (lớp) mới được thoải mái sử dụng, còn bên ngoài thì không thể nhìn thấy hay sử dụng (kể cả Con thừa kế).

		~ default: chỉ người thân trong nhà (cùng lớp và cùng gói) mới được phép.

		# protected: ngoài công khai với người thân (lớp cùng gói), còn công khai với dòng họ (lớp khác gói) nhờ kế thừa - đồ gia truyền.

		+ public: cho không biếu không - bên ngoài thích thì cứ đến xem, lấy và thay đổi.

		(Trong Java và C#, nếu không khai báo phạm vi truy cập thì sẽ được ngầm hiểu là default.)

	* Bảng tổng kết về phạm vi truy cập:

	-----------------------------------------------------------------------------------------
	| Vị trí   /    Phạm vi	|    private	|    default	|   protected	|     public	|
	|-----------------------|---------------|---------------|---------------|---------------|
	| Cùng lớp		|	x	|	x	|	x	|	x	|
	|-----------------------|---------------|---------------|---------------|---------------|
	| Cùng gói (Là lớp Con)	|		|	x	|	x	|	x	|
	|-----------------------|---------------|---------------|---------------|---------------|
	| Cùng gói (K° là Con)	|		|	x	|	x	|	x	|
	|-----------------------|---------------|---------------|---------------|---------------|
	| Khác gói (Là lớp Con)	|		|		|	x	|	x	|
	|-----------------------|---------------|---------------|---------------|---------------|
	| Khác gói (K° là Con)	|		|		|		|	x	|
	-----------------------------------------------------------------------------------------

------------------------------------------------------------

	* Non-access Modifier: Là những từ khoá đi kèm với tên lớp, nhưng không phải là phạm vi truy cập, bao gồm: static, final, abstract.

==========================================================================================

[3. TÍNH KẾ THỪA / TÁI SỬ DỤNG - INHERITANCE]

	“ Con ta không phải của ta
	  Tai họa của nó mới là của ta
	  Của chìm của nổi trong nhà
	  Của ta rồi sẽ lại là của con ”
				- Nguyễn Bảo Sinh


* Loạt sản phẩm (Series): Gồm các biến thể khác nhau của cùng một dòng sản phẩm.

* Sự đồng dạng (Similarity): Các hình có hình dạng và cấu trúc giống nhau nhưng khác nhau về kích thước.

	Ví dụ 1: Các dòng điện thoại của Samsung.

		* Các điện thoại trong cùng một dòng Galaxy Note.
			- Đều có hỗ trợ bút cảm ứng.
			- Đều có kích thước màn hình khá lớn.

		* Cùng là Galaxy Note 20 Ultra; nhưng giữa các phiên bản sẽ khác nhau về màu, CPU, dung lượng ROM và RAM...
			- Có hai phiên bản là 4G/LTE và 5G.
				+ Phiên bản 4G có 8GB RAM và các tùy chọn ROM 256GB/512GB.
				+ Phiên bản 5G có 12GB RAM và các tùy chọn ROM 128GB/256GB/512GB.
			- Có các màu:
				+ Đồng Huyền bí (Mystic Bronze).
				+ Đen Huyền bí (Mystic Black).
				+ Trắng huyền bí (Mystic White).
			- Sử dụng chip cho các khu vực / thị trường...
				+ Quốc tế: Châu Âu, Các Tiểu vương quốc Ả Rập Thống nhất (UAE), Châu Á – Thái Bình Dương (Ngoại trừ Đông Á) và Brasil sẽ sử dụng Samsung Exynos 990.
				+ Đông Á (Trung Quốc, Hàn Quốc, Nhật Bản), Bắc Mỹ và Mỹ Latinh (Ngoại trừ Brasil) sẽ sử dụng Qualcomm Snapdragon 865+.

	Ví dụ 2: Các mẫu xe của Yamaha.

		* Xe tay ga sẽ được trang bị nhiều thiết bị hiện đại:
			+ Động cơ Blue Core.
			+ Hệ thống trợ lực điện Hybrid cho xe vận hành êm ái, dễ dàng tăng tốc, cầm lái thoải mái và tiết kiệm nhiên liệu hiệu quả.
			+ Thiết kế tinh tế, thời thượng.
			+ Bảng màu sắc đa dạng.

		* Cùng là mẫu xe tay ga Yamaha Grande; nhưng giữa các phiên bản Tiêu chuẩn, Đặc Biệt và Giới hạn sẽ khác nhau về màu, trọng lượng ướt, phanh trước...

	Ví dụ 3: Các hình học.

		- Hình chữ nhật là tứ giác lồi với bốn cạnh góc vuông.
		- Hình vuông cũng là một hình chữ nhật đặc biệt.

		- Tam giác là một đa giác có ba cạnh.
		- Tam giác vuông là một tam giác
		- Tam giác đều là một tam giác cân.

------------------------------------------------------------

	* Di sản (Legacy, Heritage): Tài sản thuộc sở hữu của thế hệ trước để lại.

	* Thừa hưởng (Inherit): Nhận được tính cách, hành vi hoặc có được và sử dụng lại đồ từ người trước.

		- Thừa: Hứng, đón lấy, nhận lấy, tiếp thu.
			-> Nhận được từ người khác trao cho.

		- Hưởng: Hưởng thụ.
			-> Nhận lấy mà dùng.

* Tính kế thừa / tái sử dụng (Inheritance): Thừa hưởng, giữ gìn và tiếp tục phát huy.
	- Việc tận dụng lại những gì đã sẵn có để tiếp nối và phát triển thêm.
	- Giúp nhanh chóng tạo ra được một sản phẩm mới, nhưng vẫn mang được "thần thái" của sản phẩm cũ.
	- Trong lập trình, kế thừa là kỹ thuật cho phép một lớp kế thừa lại những thuộc tính và phương thức của một lớp khác (trong tầm kiểm soát).

	-> Tận dụng lại và từ đó phát triển thêm.

----------------------------------------

// Khi nào sử dụng kế thừa?
Khi thấy có sự tương đồng giữa các lớp với nhau.

	Ví dụ: lớp KháchHàngThânThiết được kế thừa từ lớp KháchHàng
		- Có sự tương đồng khi KháchHàngThânThiết cũng là một dạng KháchHàng.
		- KháchHàngThânThiết sẽ sở hữu những thông tin về đặc điểm của KháchHàng, chẳng hạn như: tên, tiến tiền đã thanh toán, các món hàng đã mua...

----------------------------------------

	[LỢI ÍCH KHI SỬ DỤNG KẾ THỪA]

Để nhanh chóng có được một thứ, tốt nhất là phải tham khảo từ những thứ đã có sẵn trước đó.

	- Làm ra một phiên bản mới, dựa trên cái cũ. Một thứ vốn đã tốt sẵn rồi, nay chỉ phát huy và phát triển thêm.

	- Là một phiên bản được điều chỉnh / "độ" lại từ khuôn gốc đã sẵn có.
		+ Giúp tận dụng lại toàn bộ những ưu điểm vốn có.
		+ Sau đó tự phát triển thêm những ưu điểm cho riêng mình.
		+ Có thể chỉ là những điều chỉnh rất nhỏ, dần dần thay đổi sau nhiều phiên bản.

	- Sản phẩm mới vẫn có chút hình bóng gì đó của sản phẩm cũ.
		+ Giống như các phiên bản đặc biệt của một dòng sản phẩm chỉ thay đổi mỗi vẻ bề ngoài.
		+ Nhưng khi đặt cạnh nhau không những không loại trừ lẫn nhau, mà ngược lại còn tương hợp với nhau để tạo thành một "vũ trụ" nhiều thứ tương đồng - mang những nét giống nhau.
		+ Nhưng nếu quá khác phiên bản cũ, thì có thể được xem là "cách mạng / cách tân" và có thể rẻ nhánh sang một dòng hoàn toàn mới.
		(Không có gì mới thì cũng có thể tạo ra một phiên bản mới "không khác gì phiên bản cũ" để thiên hạ thèm chơi một phiên bản thật sự đột phá.)

	- Tạo thành một bộ thư viện hỗ trợ làm ứng dụng nhanh thay vì phải sao chép và dán.
		+ Từ đó giúp tăng tốc độ viết code và tránh phải làm lại từ đầu.
		+ Cho phép mở rộng thư viện theo nhu cầu riêng.

	-> Đứng trên vai người khổng lồ, Đừng phát minh lại chiếc bánh xe.
		=> Điều chỉnh / "độ" để tạo ra những thứ mới dựa trên một nền tảng, chứ không làm phải làm từ đầu.

----------------------------------------

Bên cạnh đó, việc duyệt mảng bằng for để phục vụ cho việc tìm kiếm, sắp xếp...

	- Theo truyền thống, yêu cầu các phần tử nằm trong cùng một mảng và phải có cùng kiểu với nhau.

	- Nhưng nếu muốn sắp xếp các phần tử không thuộc cùng một mảng (dựa vào một thuộc tính chung nào đó - ví dụ: diện tích).
	
	-> Sử dụng kế thừa.

* Lưu ý: Nếu sử dụng kế thằ, mảng chỉ có thể chứa các phần tử ngang hàng với Cha trở xuống, không thể đi ngược trở lên.

	Ví dụ: Những phần tử có thể nằm trong cùng một mảng sau khi kế thừa.

		A <---extends--- B <---extends--- C

		(B kế thừa từ A và C kế thừa từ B)

		- Nếu là mảng A thì sẽ có thể chứa các phần tử thuộc mảng A, B và C.
		- Nếu là mảng B thì chỉ có thể chứa các phần tử thuộc mảng B và C, không thể chứa các phần tử thuộc mảng A.

--------------------------------------------------------------------------------

[CÁC MỨC NHẬN THỨC VỀ ĐỐI TƯỢNG VÀ LỚP]

Khi nói về việc gom nhóm và tổng quát hoá, có các mức nhận thức về đối tượng và lớp:

	0. Tự thiết kế thủ công từng đối tượng và khuôn một, mặc kệ chúng có những điểm tương đồng và chấp nhận việc tốn thời gian.
		-> Thiết kế thủ công tất cả mọi thứ từ đầu.
			(Làm thủ công từng đối tượng.)

	1. Từ các đối tượng trong cuộc sống, ta sẽ tìm ra được cách để gom các đối tượng này vào cùng một lớp, khi đã có được khuôn mẫu thì ta sẽ có thể nhanh chóng đúc ra được nhiều đối tượng giống nhau.
		-> Muốn nhanh tạo ra đối tượng thì sử dụng khuôn.
			(Nhiều đối tượng giống nhau ra đời.)

		Ví dụ: Giữa các đối tượng Sơn Tùng M-TP, Hoàng Thuỳ Linh, Đen Vâu...
			-> Đều có điểm chung là thuộc nhóm CaSĩ.

	2. Khi giữa các khuôn lại có những điểm tương đồng, thay vì phải lặp lại những phần trùng nhau cho toàn bộ các khuôn, ta nhận thấy việc có thể làm ra những phiên bản mới dựa trên những thứ đã có sẵn.
		-> Muốn nhanh tạo ra khuôn thì kế thừa từ khuôn sẵn có.
			(Lớp Cha ra đời.)
		
		Ví dụ: Giữa sinh viên, giảng viên, nhân viên...
			-> Đều có điểm chung là các thuộc tính tên, tuổi, nămSinh, địaChỉ, sốĐiệnThoại...

	3. Khi có tham vọng lớn hơn, chỉ muốn sử dụng duy nhất một khuôn đặc biệt (thuỷ tổ - trừu tượng) để tạo ra nhiều khuôn mới khác nhau (chứ không phải mỗi khuôn sẽ kế thừa từ một khuôn khác - tạo thành một cặp), từ đó giúp đa dạng các đối tượng được tạo ra.
		-> Muốn nhanh tạo ra nhiều khuôn thì kế thừa từ khuôn thuỷ tổ.
			(Lớp Cha thuỷ tổ - trừu tượng ra đời.)
		
		Ví dụ: Giữa hình chữ nhật, tam giác, hình ôvan...
			-> Đều có điểm chung là hình học với: màu sắc, chu vi, diện tích...

	4. Khi việc phân loại và gom nhóm thường dựa trên những điểm tương đồng, nhưng nay ta lại có thêm một kiểu gom nhóm đặc biệt khi giữa các khuôn chỉ quan tâm việc chung nhau về hành vi, tất cả những đặc điểm còn lại đều không quan trọng.
		-> Cố chấp chỉ gom nhóm theo hành vi.
			(Interface - Lớp Cha trừu tượng ra đời.)

		Ví dụ: Giữa CậuVàng và Exciter.
			-> Đều có chung hanh vi chạy().

--------------------------------------------------------------------------------

	[CÁCH NHẬN BIẾT QUAN HỆ KẾ THỪA]

* Cách nhận biết: Tìm điểm chung bằng cách kiểm tra xem giữa các lớp đối tượng...
	1. Có xuất hiện từ khoá là một (is a/an, is a kind of, is a version of).
	2. Chỉ ở dạng một chiều.
		A -----> B
		A <--x-- B

	-> Xác định được đâu là Cha và đâu là Con.

	Ví dụ 1: Quan hệ giữa hình chữ nhật và hình vuông.

		- Hình vuông "là một" hình chữ nhật đặc biệt.
		  (A square "is a" special "kind of" rectangle)
			-> Đúng.

		- Hình chữ nhật "là một" hình vuông.
		  (A rectangle "is a" square)
			-> Sai.

		=> Kế thừa: Quan hệ một chiều & Có xuất hiện từ khoá là một (is a/an).

	Ví dụ 2: Quan hệ giữa các hình tam giác.

		1. Tam giác và tam giác vuông.
			- Tam giác vuông "là một" tam giác.
			  (A right-angled triangle "is a" triangle)
				-> Đúng.

			- Tam giác "là một" tam giác vuông.
			  (A triangle "is a" right-angled triangle)
				-> Sai.

		=> Kế thừa: Quan hệ một chiều & Có xuất hiện từ khoá là một (is a/an).
	

		2. Tam giác đều và tam giác cân.
			- Tam giác đều "là một" tam giác cân.
			  (An equilateral triangle "is an" isosceles triangle)
				-> Đúng.

			- Tam giác cân "là một" tam giác đều.
			  (An isosceles triangle "is an" equilateral triangle)
				-> Sai.

		=> Kế thừa: Có xuất hiện từ khoá là một (is a/an) & Quan hệ một chiều.

	Ví dụ 3: Suy SAI luận kiểu "teen".

		"Tam giác" là "tát giam".
		"Tát" là "đánh", "giam" là "nhốt".
		"Đánh nhốt" là "đốt nhánh".
		"Đốt" là "thiêu", "nhánh" là "cành".
		"Thiêu cành" là "Thanh kiều", "Thanh kiều" là "thank you".
		"Thank you" là "cám ơn", vậy "tam giác" nghĩa là "cám ơn".

		=> KHÔNG KẾ THỪA: Có quan hệ một chiều, nhưng mới chỉ có "là" chứ chưa phải "là một".

--------------------------------------------------------------------------------

[CHI TIẾT VỀ KẾ THỪA]

Việc kế thừa chỉ dành cho "người nhà" - có quan hệ gần gũi với nhau, nhưng chỉ tính trong phạm vi một cặp - hai lớp khác nhau.
	- Phiên bản gốc sẽ được gọi là Cha / Căn nguyên (parent, super, base).
	- Phiên bản kế thừa sẽ được gọi là Con (child, sub, derived).

* Các nguyên tắc đi kèm với kế thừa:

	- Sau khi kế thừa, Cha và Con sẽ tương đồng (Cha có hoặc mất gì thì Con cũng sẽ bị ảnh hưởng theo).

	- Cha cho thừa kế thì Con mới được phép nhận, Cha giấu bí mật thì đến Con cũng không thể biết.

	- Con được phép kế thừa cả thuộc tính và phương thức từ Cha (không giống như interface khi chỉ được kế thừa phương thức).

	- Nhưng những gì Con có thì chưa chắc Cha đã có, nếu Cha vẫn muốn thấy những thứ Con có:
		1. Phải sử dụng danh nghĩa của Con (khai báo Con).
		2. Vẫn sử dụng danh nghĩa của Cha (Khai báo Cha), nhưng sẽ "tổ lái" sang Con.

----------------------------------------

	[LỚP OBJECT]

Trong một số ngôn ngữ lập trình (ví dụ: Java, C#...), mọi lớp đều sẽ mặc định kế thừa từ lớp Object nếu không kế thừa từ lớp nào khác.

* Lớp Object: Lớp thuỷ tổ của mọi lớp.

	- Trong Java, mọi lớp Con...
		+ Nếu không tường minh chỉ rõ kế thừa từ lớp nào, sẽ ngầm định kế thừa từ lớp Object (không cần viết ra, nhưng vẫn kế thừa).
		+ Nếu đã kế thừa từ một lớp nào đó thì sẽ không mặc định kế thừa lớp Object nữa, vì như vậy sẽ trở thành đa kế thừa.

	- Trong lớp Object, các phần tử (lớp) được phép khác kiểu nhau.
		+ Có thể sử dụng đối tượng từ lớp Object để tham chiếu đến bất kì lớp nào.
		+ 
	
	- Có sẵn một số phương thức:
		+ toString(): Trả về chuỗi (String), đại diện cho đối tượng.

			Ví dụ: Lớp SảnPhẩm vượt mặt phương thức toString() của lớp Object.

				@Override
				public String toString() {
					return String.format("- Mã sản phẩm: %s\n
							      - Tên sản phẩm: %s\n",
							      this.maSanPham, this.tenSanPham);
				}

		+ hashCode(): Trả về mã băm của đối tượng.

			Ví dụ: Lớp SảnPhẩm vượt mặt phương thức hashCode() của lớp Object.

				@Override
				public int hashCode() {
					int hash = 5;
					hash = 97 * hash + Objects.hashCode(this.maSanPham);
					return hash;
				}

		+ equals(Object obj): So sánh để xem hai đối tượng có bằng nhau hay không, tiêu chí so sánh sẽ được chuyển về mã băm (nếu hai đối tượng bằng nhau thì mã băm cũng phải giống nhau).

			Ví dụ: Lớp SảnPhẩm vượt mặt phương thức equals() của lớp Object.

				@Override
				public boolean equals(Object obj) {
					SanPham sp = (SanPham) obj;
					return this.maSanPham.toLowerCase()
							.equals(sp.maSanPham.toLowerCase());
				}

		+ clone(): Sao chép một đối tượng sang một đối tượng mới, hai đối tượng sẽ có bộ nhớ trên Heap độc lập nhau (cùng nội dung, khác vùng nhớ).

		+ getClass(): Trả về chuỗi chứa tên lớp (kèm đường dẫn tên gói) mà đối tượng được tạo ra.

------------------------------------------------------------

"Người thừa kế (Con)" sẽ được thừa hưởng mọi thứ mà "Người để lại di sản thừa kế (Cha)" cho phép.

	- Con sẽ tận dụng lại hoàn toàn (100%) những gì được thừa kế (trong phạm vi cho phép).

	- Dù tất cả đều là đồ của Cha, nhưng vẫn phải tôn trọng những gì của riêng của Con.
		+ Trước khi trở thành Con của Cha, khuôn của Con vẫn là một khuôn độc lập và vẫn có phễu của riêng mình.
		+ Một khuôn không thể nào thiếu phễu (kể cả khuôn Con), vì dữ liệu sẽ được đổ vào đây trước khi sang bên khuôn và phễu của Cha.
		+ Vì vậy, sau khi khuôn con hoàn thành, nếu muốn đúc đối tượng Con, mặc dù dữ liệu vẫn sẽ được đưa vào theo định dạng của khuôn Con, nhưng sau đó sẽ thực sự được thi công ở khuôn Cha.
		-> Phễu sẽ mặc định không được kế thừa.

	- Khi sử dụng lại đồ của Cha, phải tuân theo những quy tắc do Cha đặt ra.
		+ "Hy sinh đời bố, củng cố đời con", nếu Cha đã thiết kế quá tốt thì Con sẽ chỉ cần sử dụng mà không cần lo nghĩ.
		+ Nếu Cha quyết định thêm thì Con cũng được hưởng theo, nhưng nếu Cha quyết định bớt đi thì Con cũng phải đành chịu.
		-> Đảm bảo sự đồng bộ giữa Cha và Con.

	- Nếu Con không muốn sử dụng lại những hàm có sẵn của Cha.
		+ Con có quyền sử dụng từ khoá @Override để độ lại hàm theo ý thích.
		+ Vì Con đang kế thừa từ Cha, nhưng nay lại muốn tự mình xử lý thay vì nhờ Cha xử lý giùm, mà mọi thông tin (thuộc tính) đều do Cha nắm giữ và Cha lại có một "vùng" riêng bên trong con, nên các thuộc tính của cha Cha phải đặt phạm vi truy cập protected để Con cũng có thể thấy và xử lý riêng.

		* Khi con Gọi hàm đã được @Override...
			- Nếu khai Con, new() Con: Hàm của chính Con sẽ được thực thi, mang danh nghĩa của hàm Con.
			- Nếu khai Cha, new() Con: Hàm của chính Con sẽ được thực thi, nhưng lại mang danh nghĩa hàm của Cha.
			- Nếu khai Cha, new() Cha: Hàm của chính Cha sẽ được thực thi, hàm của Con đã @Override sẽ không có tác dụng trong Cha.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Kế thừa là kỹ thuật cho phép một lớp				│
│	kế thừa lại những thuộc tính và phương thức của một lớp khác,	│
│	lấy đó làm nền để tự phát triển thêm những gì của riêng mình	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Kế thừa là tận dụng lại những thứ đã sẵn tốt,	│
│	để nhanh chóng phát huy tiềm nắng bản thân	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

* Trong sinh học:
	- Di truyền: Kế thừa hoàn toàn, Cha có hoặc mất gì thì Con cũng giống hệt như vậy.
	- Biến dị: Tính trội (Gen trội), Con có những điều khác biệt hơn so với Cha, để thích nghi hơn và sinh tồn được với cuộc sống hiện đại.
	-> Trong lập trình cũng tương tự khi vừa cho phép kế thừa (di truyền), vừa cho phép thiết kế những thuộc tính và hành vi riêng (biến dị).

------------------------------------------------------------

	[CÁC TỪ KHOÁ VỀ KẾ THỪA TRONG JAVA]

* extends: Từ khoá để "xác nhận quan hệ nhân thân", thông báo rằng khuôn Con sẽ được kế thừa từ khuôn Cha.

	Ví dụ: public class Child extends Parent {...}

* super: Từ khoá được sử dụng khi Con muốn truy xuất vào các thành phần của Cha.
	- Chỉ có trong quan hệ kế thừa (trong khi từ khoá this thì lớp nào cũng có).
	- Cho phép truy cập vào các thành viên (thuộc tính và phương thức) của lớp Cha (nếu Cha không để private).
	- Ngoài ra, từ khoá super còn được dùng để gọi phương thức khởi tạo của lớp Cha.

	* super(): Câu lệnh này trong phễu của Con sẽ tương đương với câu lệnh tạo mới đối tượng Cha "new TênLớpCha(...);" - một vùng nhớ của Cha nằm ngay bên trong vùng nhớ của Con (yêu cầu Cha phải có vùng nhớ trước, rồi mới được phép có Con).
		-> Câu lệnh gọi phương thức khởi tạo của lớp Cha.

		- Vì bản chất của câu lệnh new() là cấp phát bộ nhớ. Vì vậy, khi new() Con, bắt buộc phải có vùng nhớ của Cha trước, sau đó Con mới có thể mở rộng (extends) được.
			+ Mục tiêu là để giúp Con phục hồi lại những đặc điểm và hành vi mà mình đã đưa cho Cha giữ để làm điểm chung.
			+ Nếu trong phễu của Con còn có những thuộc tính của riêng Con và được khai báo trước cả câu lệnh super(), sẽ đồng nghĩa với việc “Sinh con rồi mới sinh cha/ Sinh cháu giữ nhà rồi mới sinh ông” - vùng nhớ của Cha chưa được tạo thì không thể nào có được vùng nhớ để Con mở rộng.
			+ Vì vậy, câu lệnh super() phải là câu lệnh đầu tiên nhất xuất hiện trong phễu của Con.
			+ Trong Java, nếu không có câu lệnh super() trong khuôn của Con để khởi tạo vùng RAM cho Cha, Java sẽ ngầm định gọi phương thức khởi tạo không tham số của Cha (chỉ khi Cha có tạo hoặc được tạo mặc định vì Cha không có bất kì hàm khởi tạo nào). Còn nếu Cha không thiết kế hàm khởi tạo không tham số thì Con sẽ bị báo lỗi nếu thiếu câu lệnh super().

		- Ban đầu, phễu của Con sẽ được gọi, dữ liệu cũng sẽ được truyền vào phễu của Con, nhưng sau đó dữ liệu lại được đưa sang cho Cha giữ và xử lý giùm.

		- Tạo mới một đối tượng Con cũng tương đương với tạo mới đối tượng từ Cha.

			Ví dụ: Phễu trong khuôn của Con.

				// Cho phép khuôn Con kế thừa từ khuôn Cha
				public class Child extends Parent {

					// Con có thêm một thuộc tính khác
					// ngoài những gì được thừa kế từ Cha
					private String assetThree;

					// Nhận thừa kế từ Cha,
					// đồng thời kèm thêm tài sản cá nhân
					public Child(String assetOne, String assetTwo, String assetThree) {

						// Câu lệnh super() phải là câu lệnh đầu tiên nhất,
						// vì nó sẽ tiến hành tạo mới đối tượng Cha
						super(assetOne, assetTwo);

						// Vì đây là thuộc tính của riêng Con
						// mà ở Cha không hề có,
						// nên Con phải tự mình xử lý lấy
						this.assetThree = assetThree;
					}
				}

		-> Cha sẽ là nền tảng (base) để Con có thể mở rộng (extends).
			("Ba sẽ là cánh chim, đưa con đi thật xa".)

* implements: Thông báo rằng khuôn Con sẽ hiện thực hoá / triển khai các hàm trừu tượng từ khuôn Cha.

	Ví dụ: public class Child implements Interface {...}

------------------------------------------------------------

	[THỦ TỤC THỪA KẾ]

Sau khi phát được hiện mối quan hệ là một (is a) ở dạng một chiều:

	Bước 1: Đưa những gì chung nhất giữa các Cha-Con sang cho một mình Cha giữ - Đặt nhân tử chung.
		- Để sau này di truyền những điểm chung nhất này xuống cho Con trước khi Con bắt đầu có "chất riêng" của mình.
		- Càng có nhiều Con thì số đặc điểm chung sẽ càng ít dần đi.

	Bước 2: Khi thiết kế khuôn Con, tại phần tên khuôn, chỉ định việc kế thừa từ khuôn Cha bằng từ khoá extends - giúp hai ta bắt đầu về một nhà - xác nhận quan hệ nhân thân.

	Bước 3: Thiết kế đặc điểm / thuộc tính cho khuôn Con.

		1. Nếu không có khác biệt, ta hoàn toàn có thể tận dụng lại những thuộc tính của khuôn Cha (tận dụng lại, chứ không phải là không có).

		2. Nếu chưa có hoặc muốn có sự khác biệt, Con hoàn toàn có thể tự mình thiết kế những thuộc tính cho riêng mình (tương tự với phương thức).

	Bước 4: Thiết kế riêng phễu cho khuôn Con.

		- Về nguyên tắc, một khuôn luôn luôn phải có phễu.

		- Các trường phái thiết kế phễu cho Con:
			1. Vẫn phải thiết kế, nhưng không có sự thay đổi so với Cha.
			2. Có sự thay đổi dựa vào những thuộc tính riêng biệt của Con đã thiết kế bên trên.

		- Mặc dù sống chung nhà và Cha là chủ nhà, nhưng chắc chắn sẽ có những khoảng cách về thế hệ, khi tuổi trẻ thường yêu thích sự sáng tạo và khác biệt, nên Con sẽ phải thoả hiệp hoàn toàn với Cha nếu muốn phá cách.
		
		- Vì vậy, việc thiết kế riêng phễu cho Con sẽ vừa giúp giữ được những bản sắc riêng của Con, nhưng cũng đồng thời dung hoà được với Cha.
			+ Vẫn nhận đầu vào theo phong cách của Con, nhưng lại đổ vào phễu bằng câu lệnh super() theo phong cách của Cha.
			+ Ban đầu sẽ theo phong cách và mang danh nghĩa của Cha, nhưng sau đó lại được thực thi theo phong cách của Con.

		- Mỗi lần sử dụng new() để tạo một đối tượng Con khi khai báo Cha.
			1. Câu lệnh super() sẽ giúp tạo ra vùng RAM của Cha trước.
			2. Một vùng RAM từ phía con sẽ được tạo - bao trùm bên ngoài vùng RAM của Cha (bên trong đã chứa sẵn vùng RAM của Cha).
			3. Một con trỏ theo phong cách của Cha sẽ được sử dụng để trỏ đến vùng RAM này của Con.
			4. Lúc này, nhờ máy ảo Java, con trỏ của Cha chỉ trỏ đến vùng RAM của Cha nằm bên trong Con (trỏ lưng chừng) thay vì trỏ đến đáy vùng RAM của Con.

		-> Hòa nhập mà không hòa tan.

		(Đồng thời, có thể thay đổi thứ tự của các tham số đầu vào nếu cần thiết, nhưng tuyệt đối không được thay đổi thứ tự đặt câu lệnh super().)
		
		Ví dụ: Hình tam giác.

			// Tam giác vuông chỉ cần có hai cạnh góc vuông
			//	-> Khuôn của Con chỉ cần nhận vào hai cạnh góc vuông
			public RightTriangle(double a, double b) {

				// Tam giác thông thường yêu cầu phải có ba cạnh,
				// vì vậy, Con phải tự tính độ dài của c (cạnh huyền)
				// nếu muốn đổ dữ liệu vào khuôn của Cha
				//	-> Khuôn của Cha nhận vào đầy đủ ba cạnh
				super(a, b, Math.sqrt(a * a + b * b));
			}

	Bước 5: Thiết kế các hàm của Con.

		1. Có thể tận dụng lại hoàn toàn các hàm của Cha.
			- Con hoàn toàn có thể không cần thiết kế lại bất kì hàm nào nếu đã cảm thấy đủ.
			- Đồng thời, nếu muốn có đôi chút khác biệt nhưng vẫn giữ nguyên tên hàm từ Cha, Con vẫn có thể tự thiết kế lại bằng cách vượt mặt (@Override).

		2. Nếu muốn mở lối đi riêng - Thoát cái bóng của Cha.
			- Con có toàn quyền thiết kế thêm những hàm mà mình thích.
			- Có thể vừa vượt mặt, vừa nạp chồng hàm; lúc này, từ khoá @Override không cần thiết nữa - hàm được đối xử như một lối đi riêng của Con.
			- Nhưng Con phải sử dụng thêm kỹ thuật Ép kiểu / Tổ lái (Drift) con trỏ để tương tác với vùng đáy RAM của Con để gọi hàm khi "Khai Cha = new Con();", vì đang mang danh nghĩa của Cha mà Cha lại hoàn toàn không biết những gì của riêng Con.

		* Lưu ý: Con trỏ của Cha sẽ không thể thấy các hàm độ lại của Con nếu không bắt gặp từ khoá @Override. Vì vậy, đối với các hàm riêng biệt của Con, nếu muốn sử dụng khi đang mang danh nghĩa của Cha phải sử dụng kỹ thuật tổ lái con trỏ thì Cha mới có thể thấy được.

	Bước 6: Khai Cha - new() Con.

		- Tạo ra một đối tượng Con bằng câu lệnh new(), với tên gọi tắt (tên đối tượng) kèm kiểu dữ liệu của Cha.
			+ Tạo đối tượng con theo khuôn của Cha.
			+ Không quan trọng đối tượng nào được tạo ra, quan trọng là khuôn nào được sử dụng để làm gốc thì khuôn ấy sẽ được có mọi "danh nghĩa" về thuộc tính và phương thức đối với đối tượng (còn xử lý thực tế thì còn phải phụ thuộc vào việc có diễn ra hiện tượng vượt mặt (@Override) hay không).

		- Vì đang mang danh nghĩa của Cha, nên sẽ hành xử theo Cha, trừ khi Con muốn vượt mặt bằng cách vượt mặt (@Override).
			+ Con trỏ lúc này sẽ chỉ trỏ dến vùng RAM của Cha nằm bên trong Con.
			+ Dù Con đã vượt mặt, nhưng việc gọi các hàm vẫn sẽ mang danh nghĩa của Cha, chỉ có điều hàm con mới thực sự là hàm được thực thi.
				(Tính đa hình - Gọi tên hàm Cha, nhưng hàm Con được thực thi.)

		-> “Con dù lớn vẫn là con của mẹ. Đi hết đời, lòng mẹ vẫn theo con”.

		(Việc gọi Con với danh nghĩa của Cha giống như trò gọi tên phụ huynh thời đi học.)

----------------------------------------

* Lưu ý 1: Trong kế thừa, tất cả những gì (mà Cha cho phép) đều sẽ là của Con.
	- Vì vậy, từ khoá this khi chấm sẽ bao gồm cả những gì của riêng Con và những gì được thừa kế từ Cha.
	- Trong khi đó, từ khoá super khi chấm sẽ chỉ bao gồm những gì của riêng Cha.

------------------------------------------------------------

	[CÁC CẤP ĐỘ KẾ THỪA]

* Các cách phân loại đối tượng và khuôn:

	1. Dựa trên cả đặc điểm và hành vi.
		-> Kế thừa & Trừu tượng: Có họ hàng.

	2. Chỉ dựa trên hành vi.
		-> Interface: Chung hội nhóm.

* Khi bàn về khuôn của các đối tượng trong kế thừa, ta sẽ có hai góc độ:

	1. Cụ thể (Concrete): Một khi đã nhắc đến thì không cần giải thích gì thêm; ta có thể tạo mới đối tượng từ đây, vì khuôn này có thật sự tồn tại ở ngoài đời.
		Ví dụ: XeMáy, SinhViên, ConMèo, HìnhChữNhật...

	2. Trừu tượng (Abstract): Cần giải thích cụ thể một khi đã nhắc đến; ta không thể tạo mới đối tượng từ đây, vì khuôn này chỉ tồn tại ở mức khái niệm.
		Ví dụ: PhươngTiệnGiaoThông, ĐộngVật, ThúCưng, HìnhHọc...

Dù có áp dụng bao nhiêu kỹ thuật đi nữa...
	- Đích đến cuối cùng là phải cho ra được đối tượng, có được một vùng RAM để chấm và chạy.
	- Khuôn (kể cả cụ thể hay trừu tượng) cũng chỉ là công cụ được mượn để hỗ trợ tạo nhanh các đối tượng.
	-> Kế thừa để tạo nhanh đối tượng.

----------------------------------------

* Các cấp độ kế thừa: Khi phát hiện mối quan hệ "là một" và một chiều, lập tức tiếp cận cách làm khuôn kiểu mới.

--------------------

	1. Cha cụ thể (Concrete Class): Cả Cha và Con đều có đầy đủ code để chạy.

		- Về cơ bản, Con đã sinh ra ở vạch đích, nên không cần phải làm gì thêm.
			+ Con được quyền có thêm những thuộc tính cho riêng mình, nhưng phải độ lại phễu.
			+ Con vẫn được quyền độ lại những phương thức của Cha bằng cách vượt mặt (Override) dù không bắt buộc; hoặc có thêm những hàm riêng biệt của mình nếu muốn.

		- Khi này, cả Cha và Con đều có đầy đủ code cho hàm, không chứa bất kì hàm trừu tượng nào (chứ không phải kiểu 50/50 - một nửa cụ thể và một nửa trừu tượng).
			+ Cả hai đều có thể song song tồn tại, cùng có quyền tạo ra được những đối tượng cho riêng mình để tương tác như hai đối tượng độc lập.
			+ Nếu Con không có hàm thì sẽ mặc định sử dụng hàm của Cha; hoặc nếu hàm được Con vượt mặt (Override) thì chắc chắn phải sử dụng hàm Con (dù vẫn đang mượn danh nghĩa của Cha).

		// Khai Cha = new Cha() | Dùng trực tiếp, vì đã hoàn hảo
		// Khai Cha = new Con() | Đa hình -> Xảy ra do vượt mặt (@Override)
		// Khai Con = new Con() | Dùng trực tiếp, vì đã hoàn hảo

		Ví dụ: Xây dựng lớp biểu diễn hình học.

			// Lớp Cha cụ thể
			public class Rectangle {
				protected String owner;
				protected String color;
				protected double width;
				private double length;

				public Rectangle(String owner, String color, double width, double length) {
					this.owner = owner;
					this.color = color;
					this.width = width;
					this.length = length;
				}

				@Override
				public String toString() {...}
				
				public double getArea() {
					return width * length;
				}
				
				public void paint() {...} // Tương ứng với Rectangle
			}

			// Lớp Con cụ thể kế thừa từ Cha cụ thể
			public class Square extends Rectangle {

				// Hình chữ nhật đã có sẵn các thuộc tính,
				// nên hình vuông không cần thiết kế lại
				// (mặc định sẽ được thừa hưởng),
				// nhưng vẫn phải thiết kế lại phễu
				// tương ứng với hình vuông
				public Square(String owner, String color, double edge) {
					super(owner, color, edge, edge);
				}
				
				@Override
				public void paint() {...} // Tương ứng với Square
			}

--------------------

	2. Cha trừu tượng (Abstract Class): Cha không có code, nhưng Con kế thừa từ Cha lại có code để chạy.

		- Tuy có chứa những hàm có code - dù là những hàm đơn giản nhất (ví dụ: getter() và setter()), nhưng chỉ cần có duy nhất một hàm trừu tượng (chỉ có tên hàm và không có code) thì lập tức được xem là lớp trừu tượng.

		- Mà một khi Cha đang là trừu tượng, Con chỉ được quyền lựa chọn một trong hai con đường:

			1. Lười biếng (Abstract - Tiếp tục trừu tượng): Con cũng là trừu tượng nốt - Cả hai đều không tạo được đối tượng.

			2. Siêng năng (Implement - Hiện thực / Triển khai): Con viết tiếp khái niệm của Cha đang dang dở - Sử dụng @Override để tiếp tục viết hàm - đa hình.
		
		- Con bắt buộc phải hiện thực toàn bộ các hàm trừu tượng của Cha, nếu không sẽ giống như tự cung mà tuyệt tự, vì không ai trong cả hai có code để xử lý và trả kết quả.

		- Trong quá trình hoàn thiện code cho Cha, Con vẫn được quyền có thêm những hàm riêng biệt của mình.

		- Lớp trừu tượng vẫn được quyền hiện thực (implements) các lớp Interface khác.

			Ví dụ: Lớp trừu tượng hiện thực hoá Interface.

				// Thiết kế Interface
				public interface MyInterface {
					void doSomething();
				}

				// Lớp trừu tượng hiện thực Interface
				public abstract class MyBaseClass implements MyInterface {
					public void doSomething() {...}
				}

		// Khai Cha = new Cha() | Nặc danh -> Không có code nên phải chơi xổi
		// Khai Cha = new Con() | Đa hình -> Xảy ra do vượt mặt (@Override)
		// Khai Con = new Con() | Dùng trực tiếp, vì đã hoàn hảo

		Ví dụ: Xây dựng lớp biểu diễn thông tin cá nhân.

			// Lớp Cha trừu tượng, tổng quát - Thẻ định danh
			public abstract class TheDinhDanh {
				protected String maSoChungNhan;
				protected Date ngayKyChungNhan;
				protected String nguoiKyChungNhan;

				public abstract void xuatTrinhThe();
			}

			// Lớp Con cụ thể - Căn cước công dân
			public class CanCuocCongDan extends TheDinhDanh {
				private String hoTenCongDan;
				private Date namSinh;
				private String gioiTinh;

				public CanCuocCongDan(String hoTenCongDan, Date namSinh, String gioiTinh, String soCCCD, Date ngayKyCCCD, String nguoiKyCCCD) {
					this.hoTenCongDan = hoTenCongDan;
					this.namSinh = namSinh;
					this.gioiTinh = gioiTinh;
					this.maSoChungNhan = soCCCD;
					this.ngayKyChungNhan = ngayKyCCCD;
					this.nguoiKyChungNhan = nguoiKyCCCD;
				}

				public void xuatTrinhThe() {
					System.out.println("Ho ten: " + hoTenCongDan);
					System.out.println("So CCCD: " + maSoChungNhan);
					System.out.println("Nam sinh: " + namSinh);
					System.out.println("Gioi tinh: " + gioiTinh);
					System.out.println("Ngay cap the: " + ngayKyChungNhan);
					System.out.println("Truong cong an: " + nguoiKyChungNhan);
				}
			}

			// Lớp Con cụ thể - Thẻ sinh viên
			public class TheSinhVien extends TheDinhDanh {
				private String hoTenSinhVien;
				private Date namSinh;
				private String gioiTinh;

				public TheSinhVien(...) {...}

				public void xuatTrinhThe() {...}
					// Người ký chứng nhận: Hiệu trưởng
			}

			// Lớp Con cụ thể - Thẻ nhân viên
			public class TheNhanVien extends TheDinhDanh {
				private String hoTenNhanVien;
				private String phongBan;
				private String chucVu;

				public TheNhanVien(...) {...}

				public void xuatTrinhThe() {...}
					// Người ký chứng nhận: Trưởng phòng nhân sự
			}

			// Lớp Con cụ thể - Vé máy bay
			public class VeMayBay extends TheDinhDanh {
				private String hoTenKhachHang;
				private String maHoChieu;

				public VeMayBay(...) {...}

				public void xuatTrinhThe() {...}
					// Người ký chứng nhận: Đại lý phát hành
			}

			// Lớp Con cụ thể - Vé mời sự kiện
			public class VeMoiSuKien extends TheDinhDanh {
				private String hoTenKhachMoi;
				private String tenSuKien;

				public VeMoiSuKien(...) {...}

				public void xuatTrinhThe() {...}
					// Người ký chứng nhận: Ban tổ chức
			}

--------------------

		* Khách vãng lai: Người ở nơi khác, đến rồi lại đi, phân biệt với người sở tại.
		* Xổi: Tạm bợ trong một thời gian ngắn.

	3. Cha nặc danh / Khách vãng lai / Xổi / Ngẫu hứng (Anonymous Class): Khai Cha trừu tượng, đồng thời lại new() Cha trừu tượng này để ra cho bằng được Con cụ thể.

		- Lớp nặc danh là lớp mà đối tượng cụ thể của nó lại được tạo ra nhờ vào việc new() một lớp trừu tượng khác, vì không nhất thiết phải là lớp cụ thể mới có thể tạo ra được một đối tượng cụ thể.
			+ Thường sử dụng trong trường hợp không có sẵn giàn khung (công thức tính toán) và không thể phân nhóm được, đành mượn tạm một khuôn chung chung nhất nhưng không có code để thuộc về - trừu tượng.
			+ Bằng cách (ngầm định) sử dụng tên lớp trừu tượng, ta không còn cần thiết kế mới và sau đó chỉ định một tên lớp cụ thể (tường minh) để tạo mới đối tượng nữa.
			+ Đối tượng được tạo ra sẽ là độc nhất vô nhị và vẫn có một vùng RAM độc lập như bao đối tượng truyền thống khác.
			+ Đối tượng được tạo ra từ lớp nặc danh vẫn có một con trỏ để trỏ đến ngay khi khai báo, nên sẽ không bị mất giống như đối tượng nặc danh, đối tượng này chỉ bị huỷ khi hết hàm hoặc mất con trỏ.

		- Chỉ xảy ra trong quan hệ kế thừa khi Cha là trừu tượng, Con là cụ thể.
			+ Thông thường, không nên new() lớp đang có chứa hàm trừu tượng, vì hàm hoàn toàn không có code bên trong để tiến hành xử lý.
			+ Nhưng nếu vẫn ngoan cố thực hiện thì kiểu gì ở một nơi nào đó cũng sẽ phải viết code - Chạy trời không khỏi nắng.

		- Theo truyền thống, để tạo được một đối tượng cụ thể, ta sẽ cần:
			1. Một khuôn với ĐẦY ĐỦ CODE để còn xử lý sau này.
			2.1. Gọi new() để có thể tạo ra một vùng RAM riêng từ khuôn.
			2.2. Gọi phễu để đưa dữ liệu vào trong vùng RAM mới tạo.
			3. Đưa toạ độ của đối tượng mới tạo cho một biến con trỏ giữ giùm.

		- Nhưng nếu xuất hiện một đối tượng cụ thể mà...
			+ Đối tượng này "lạc loài" đến mức không thể phân loại vào bất kì một nhóm cụ thể nào.
			+ Khi này, nhóm Cha trừu tượng sẽ dang rộng vòng tay để chào đón và cho phép tạo mới đối tượng, mặc dù bản thân Cha vẫn đang chỉ là trừu tượng.

			(Mượn khuôn Cha để tạo đối tượng Con - Mượn gió bẻ măng)

		- Vì bắt buộc vẫn phải có code để xử lý, nên sau khi tạo mới đối tượng từ khuôn Cha trừu tượng, ta sẽ chủ động viết thêm code để đạt được tính hoàn hảo cho lớp nặc danh này.
			+ Tận dụng việc câu lệnh super() (câu lệnh tạo vùng new() cho Cha bên trong khuôn Con) không cần quan tâm rằng Cha là cụ thể hay trừu tượng, JVM vẫn sẽ tạo ra một vùng nhớ của Cha và cho phép Con mở rộng.
			+ Việc gọi phễu và truyền các tham số, vượt mặt các hàm trừu tượng của Cha... sẽ được thực hiện trực tiếp ngay tại nơi tạo đối tượng Con.

		- Chỉ nên sử dụng khi chỉ cần có duy nhất một đối tượng được tạo ra và không muốn tốn công phải thiết kế ra một khuôn mới chỉ để tạo ra đối tượng này.
			+ Vì đây là kiểu viết code "xổi" khi không tìm được điểm chung và phân loại để tạo thành một nhóm riêng biệt, nhưng bù lại sẽ rất tiện lợi nếu muốn lập tức có được đối tượng.
			+ Không giữ lại được khuôn (phễu và hàm vượt mặt) để sau này nhanh chóng tạo ra được những đối tượng tương đồng, dẫn đến việc liên tục phải thiết kế lại khuôn nếu muốn có nhiều đối tượng Con cụ thể được tạo ra từ Cha trừu tượng.
			+ Phễu của Cha thiết kế như thế nào thì Con phải sử dụng giống hệt vậy, không có cách nào có thể thiết kế lại phễu riêng cho Con được, vì đây không được xem là tạo khuôn rời.
			+ Thường sử dụng trong thiết kế các giao diện đồ hoạ người dùng (GUI): nút bấm, checkbox, xử lý sự kiện nhấn chuột / bàn phím...
			-> Sử dụng như một giải pháp tình thế, tạm thời.

		- Vì đây chỉ là vùng nhớ ngẫu nhiên trong RAM - được tạm tạo ra để tiết kiệm thời gian khi không phải thiết kế khuôn và phễu bài bản từ đầu.
			+ Bản chất vẫn là một vùng RAM của Con, bên trong chứa vùng RAM của Cha và vùng mở rộng, cho phép con thiết kế lại hoặc thiết kế thêm các thuộc tính và phương thức nếu muốn.
			+ Tạm thời dễ dàng cho Con khi vượt mặt những hàm trừu tượng do lớp Cha trừu tượng đã thiết kế.
			+ Nhưng sẽ rất khó khăn trong việc gọi các thuộc tính và phương thức của riêng Con tự thiết kế thêm, khi Con không hề có tên (kiểu dữ liệu) để tiến hành ép kiểu con trỏ.
			+ Vì vậy, nếu có thêm những hàm riêng biệt ngay trong vùng này:
				1. Sử dụng dấu chấm trực tiếp sau cặp dấu ngoặc nhọn {}.
				2. Sử dụng kỹ thuật Reflection.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Lớp nặc danh là kỹ thuật mượn khuôn Cha trừu tượng,	│
│	tạo ra vùng RAM mở rộng và hình thành nên đối tượng Con	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Ngầm định tạo đối tượng Con mà không cần đến lớp Cha tường minh	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Lớp không có tên, chỉ có phần thân xử lý	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------

		* Lưu ý: Không giống như đối tượng nặc danh (Anonymous Object) khi đối tượng này sẽ ngay lập tức bị bộ thu gom rác (GC) của JVM dọn dẹp ngay sau khi được tạo ra...
			- Đối tượng Con được tạo ra từ khuôn Cha trừu tượng vẫn sẽ có con trỏ (thuộc khuôn Cha) để trỏ đến.
			- Tuy nhiên, ta vẫn có thể kết hợp giữ lớp nặc danh và hàm nặc danh.

			Ví dụ: Kết hợp đối tượng nặc danh vào trong lớp nặc danh

				new Shape(..., ..., ...) {	// Lớp nặc danh

					@Override
					// Các hàm của Cha trừu tượng

				}.paint();			// Đối tượng nặc danh

--------------------

	4. Tiếng nói chung / Bộ quy tắc ứng xử chung (Interface): Cha không có code, Con bắt buộc phải kế thừa và thiết kế toàn bộ để chạy.

		- Khi hội nhóm / câu lạc bộ là nơi tập hợp các thành viên có chung sở thích và lý tưởng để cùng đồng hành trong một lĩnh vực nào đó, những yếu tố còn lại (ví dụ: xuất thân, công việc, hội nhóm khác đang tham gia...) sẽ bớt quan trọng.
			+ Trong mỗi hội nhóm / câu lạc bộ đều sẽ có những bộ quy tắc ứng xử chung (trừu tượng) - giống như một hợp đồng, liệt kế những điều khoản để các bên có liên quan tuân theo, giúp hiểu ý nhau và từ đó việc giao tiếp cũng trở nên dễ dàng hơn.
			+ Mỗi thành viên tham gia sẽ có nhiệm vụ tuân thủ (hiện thực hoá), thoải mái thể hiện bản thân nhưng không được phép vượt quá khuôn khổ.
			+ Nếu đã tham gia nhiều hội nhóm thì bắt buộc phải hoạt động tích cực trong tất cả các hội nhóm (phải tự thiết kế tất cả xử lý mà trước đó chỉ được các bên liệt kê trên hợp đồng) - “Quyền lực càng cao, trách nhiệm càng nhiều”.
			+ Bên cạnh việc "đóng vai" con cưng của gia đình - kế thừa, một đối tượng vẫn được phép tham gia nhiều hội nhóm khác nhau với những vai trò và nghĩa vụ khác nhau.
			+ Tương tự như vậy, trong hệ điều hành Windows, từ khoá Hội viên (Member Of) được sử dụng để gom nhóm các người dùng (User) lại với nhau và cho phép cùng thực hiện bộ quyền giống nhau, không quan tâm người dùng ấy là ai và đang có tham gia song song những nhóm nào khác.

			-> Cuộc chơi chung khi các bên đã thống nhất về luật chơi.

			Ví dụ 1: Trong hội phượt thủ.
				- Tập hợp những thành viên đến với mục đích là đi phượt, khám phá, chinh phục các vùng đất mới...
				- Không quan tâm thành viên đấy là học sinh, sinh viên, người đi làm, hưu trí...
				- Tự mỗi hội viên sẽ có một kiểu phượt (lái xe) khác nhau.
				-> Là hội viên của CLB Phượt với hành động điPhượt()

			Ví dụ 2: Trong câu lạc bộ tiếng Anh của một trường Đại học.
				- Tập hợp những thành viên đến với mục đích là cải thiện trình độ tiếng Anh, khả năng giao tiếp, rèn sự tự tin...
				- Không quan tâm thành viên đấy là sinh viên hay giảng viên, càng không quan tâm đến chuyên ngành, hệ đào tạo, niên khoá, học lực...
				- Tự mỗi hội viên sẽ có những kiểu nói tiếng Anh khác nhau.
				-> Là hội viên của CLB tiếng Anh với hành động nóiTiếngAnh()

			Ví dụ 3: Tổng hợp các bộ quy tắc / cam kết trong đời thực.
				- Nhà trường ban hành nội quy chung, Giảng viên và Sinh viên trong từng lớp sẽ có nhiệm vụ tuân thủ theo.
				- Mỗi dịp Tết đến, bố mẹ hay bảo với con cái trong nhà: "Nếu muốn nhận tiền lì xì thì hãy ăn mặc đẹp rồi đi ra phòng khách để chúc Tết".

			Ví dụ 4: Để card đồ hoạ mới (ví dụ: Nvidia GeForce RTX 4090...) vẫn hoạt động được trên một chiếc máy tính đang chạy hệ điều hành cũ (ví dụ: Windows 7...).
				- Khi thiết kế hệ điều hành, những nhà thiết kế hệ điều hành đã quy ước, công bố trước với những nhà phát triển phần cứng và phần mềm (hoặc họ phải tự liên hệ với nhà thiết kế hệ điều hành):
					+ Trong lõi của hệ điều hành sẽ có một Interface "Cha" tên là VGACard, chứa một hàm render() trừu tượng (không có phần code xử lý).
					+ Nếu các nhà sản xuất phần cứng muốn giao tiếp được với hệ điều hành thì phải thiết kế (hiện thực hoá) riêng một lớp XXXVGACard "Con" chứa hàm render() đã vượt mặt (@Override) để điều khiển chip đồ hoạ.
					+ Điều này sẽ giúp các bên thống nhất với nhau về tên gọi bằng cách: Phần mềm chỉ cần gọi hàm render() trong Interface "Cha" VGACard của hệ điều hành. Thông qua tính đa hình, tuỳ vào mỗi loại phần cứng khác nhau mà sẽ có những cách thức thực hiện khác nhau.
				- Vì chỉ có các nhà sản xuất phần cứng mới hiểu rõ card đồ hoạ của mình hoạt động ra sao, nên họ cũng sẽ thiết kế một driver (lớp để điều khiển card đồ hoạ):
					+ Đây chính là lớp hiện thực hoá cho Interface "Cha" VGACard của hệ điều hành, giúp phần cứng giao tiếp được với hệ điều hành.
					+ Khi cài đặt driver từ nhà sản xuất phần cứng, quá trình cài đặt sẽ khai báo tên của lớp driver vào trong Registry của hệ điều hành.
					+ Lúc này, hàm render() trừu tượng của hệ điều hành đã bị hàm render() trong lớp driver vượt mặt (@Override).
					+ Khi game bắt đầu được render (phát sinh hình ảnh), hệ điều hành sẽ trực tiếp gọi hàm render() và câu lệnh sau đó sẽ được gửi sang cho card đồ hoạ xử lý, vì lúc này bên trong đã có code cho hàm render().
				- Vì vậy, để card đồ hoạ mới tương thích được với hệ điều hành cũ, chỉ cần sử dụng driver do chính nhà phát triển phần cứng phát hành và driver này vẫn còn đang hỗ trợ cho hệ điều hành cũ.

		- Trong các ngôn ngữ lập trình khác (ví dụ: C++...), một Con được phép kế thừa từ nhiều Cha - Đa kế thừa (Multiple Inheritance), để có thể tận dụng được các hàm của các Cha.
			+ Tuy Java được phát triển dựa trên cú pháp của C và C++, nhưng lại thấy được những rắc rối trong việc đa kế thừa (ví dụ: nếu cả hai lớp Cha đều có chung một tên hàm, lớp Con sẽ không biết gọi hàm của ai).
			+ Vì vậy, Java đã quyết định một Con chỉ được phép có tối đa một Cha - Đơn kế thừa (Single Inheritance) - Mỗi Cha được phép có nhiều Con, nhưng mỗi Con chỉ có thể có tối đa một Cha (đi theo hàng dọc: Con -> Cha -> Ông Nội -> Ông Tổ...).
			+ Nhưng đổi lại, một Con có thể tham gia rất nhiều hội nhóm / câu lạc bộ khác nhau.
			+ "Nhập gia tuỳ tục", với mỗi hội nhóm đã tham gia, Con phải có nghĩa vụ tuân thủ các quy định của nơi đấy bằng cách tự mình hiện thực các hành động.
			+ Vì đến lớp Con mới bắt đầu thiết kế xử lý, nên sẽ không sợ vấn đề không biết phải gọi hàm của lớp Cha nào.

			(Có thể vừa kế thừa từ gia đình, vừa tự mình học hỏi thêm qua các hội nhóm.)

			-> Interface là cách Java giải quyết cho câu chuyện đa kế thừa.

		- Ngoài việc được hiểu giống như một câu lạc bộ với những quy tắc ứng xử chung, ta cũng có thể hiểu Interface giống như một tổ chức chuyên đưa ra những bộ tiêu chuẩn chung.
			- Những doanh nghiệp khác nhau sẽ có những cách khác nhau để triển khai các tiêu chuẩn.
			- Giúp các bên có liên quan dễ dàng giao tiếp và chấp nhận nhau hơn.

			Ví dụ 1: Viện Tiêu chuẩn Chất lượng Việt Nam (thuộc Tổng cục Tiêu chuẩn Đo lường chất lượng - STAMEQ) và các bộ, ngành, tổ chức khác nhau đưa ra các tiêu chí về an toàn thực phẩm (ví dụ: nồng độ / hàm lượng chất bảo quản...).
				-> Mỗi doanh nghiệp sản xuất sẽ dựa theo các tiêu chuẩn này để làm ra các sản phẩm đạt tiêu chuẩn Hàng Việt Nam chất lượng cao (HVNCLC).

			Ví dụ 2: Trong một lớp học văn.
				- Đã thống nhất với nhau về đề bài (một tác phẩm văn học).
				- Đã thống nhất về bố cục của bài văn: Mở, thân và kết bài.
				-> Mỗi học sinh khác nhau sẽ có những cách viết khác nhau.

			Ví dụ 3: Trong một trường đại học, Khoa / Ban đã thống nhất về đề cương môn học.
				-> Mỗi giảng viên sẽ có những phong cách giảng khác nhau, những vẫn dựa vào đề cương.

		- Về bản chất, đây vẫn là một cái khuôn / lớp - nơi tập hợp những đối tượng với một điểm chung nào đó, nhưng lại không chặt chẽ khi chỉ yêu cầu những điểm chung trong hành vi và một số thuộc tính dùng chung (static).

		- Interface cũng là một lớp Cha để kế thừa, nhưng sẽ đặc biệt hơn là chỉ chứa các hàm trừu tượng / tĩnh / mặc định (default) và thuộc tính hằng số (static final) thay vì chứa cả thuộc tính (số nguyên, chuỗi, mảng...) và phương thức (khởi tạo, getter() & setter(), xử lý...) như những lớp Cha khác.
			+ Lớp "Cha" Interface vẫn sẽ có các thuộc tính, nhưng bắt buộc phải là static hoặc final (hoặc cả hai), và phải được gán sẵn giá trị trong lúc khai báo, đồng nghĩa với việc đây là đồ sử dụng chung và không quan tâm đến những thứ riêng biệt.
			+ Còn các phương thức, mặc định sẽ là phương trừu tượng mà không cần phải khai báo từ khoá "abstract" ở sau tên lớp và ở tên hàm (khi định nghĩa lớp và thiết kế hàm trừu tượng), vì Interface đã được ngầm hiểu là nơi chuyên chứa những thứ chung chung và khó hiểu.
			+ Các hàm trừu tượng sẽ mang phạm vi truy cập public (kể cả không ghi thì vẫn mặc định là public) để lớp Con có thể thoải mái kế thừa và vượt mặt theo cách riêng của mình (những hàm do Con hiện thực hoá cũng phải có truy cập là public).
			+ Vì vậy, khi hiện thực hoá Interface, các hàm của lớp Con bắt buộc phải có phạm vi truy cập là public.

			* Lưu ý: Trong Interface, nếu không khai báo tường minh phạm vi truy cập thì hàm hàm trừu tượng sẽ mang phạm vi truy cập public. Vì vậy, khi lớp Con hiện thực hoá, bắt buộc phải khai báo thêm phạm vi truy cập public, nếu không sẽ bị hiểu nhầm là default.
				-> Vi phạm nguyên tắt của vượt mặt.

				Ví dụ: Lỗi khi hiện thực hoá hàm hàm trừu tượng.

					interface A {

						// Phạm vi truy cập mặc định là public
						void show();
					}

					class B implements A {

						// Gây ra lỗi, vì trong lớp thông thường
						// sẽ được hiểu là phạm vi truy cập default
						void show() {...}
					}

		- Trước Java 8, Interface chỉ cho phép chứa những hàm trừu tượng.
			+ Nhưng bắt đầu từ Java 8, hàm trong Interface đã được phép có sẵn code, nhưng kèm với điều kiện đấy phải là những hàm static hoặc hàm có chứa từ khoá default.
			+ Từ Java 9, hàm đã được phép khai báo phạm vi truy cập là private (nhưng phải đi kèm với phần thiết kế xử lý) và có thể là static hoặc non-static, mục đích chủ yếu là để phục vụ cho các hàm mặc định (default).

		- Vì nhiệm vụ chính của Interface là chuyên chứa những hàm trừu tượng, nên có thể ngầm hiểu đây cũng là lớp trừu tượng, còn việc triển khai thực tế các hàm trừu tượng này sẽ do lớp Con quyết định.
			+ Không thể tạo mới đối tượng trực tiếp từ Interface, chỉ có cách kế thừa và lớp Con đã hiện thực hoá toàn bộ những hàm trừu tượng thì mới có thể tạo mới đối tượng.
			+ Nếu Con quyết định kế thừa (thông qua hình thức gia nhập hội), yêu cầu Con phải viết đầy đủ code cho tất cả các hàm trừu tượng trước khi muốn tạo mới các đối tượng, nếu không sẽ phải sử dụng đến lớp nặc danh hoặc cũng quyết định tuyệt tự.

		- Vì không quan tâm đến đặc điểm, nên cũng không cần phải tạo phễu cho Interface để khởi tạo giá trị, nhưng mặc định đã có sẵn phễu rỗng - câu lệnh super() ngầm trong kế thừa để chứng minh rằng đây thật sự là thành viên của hội nhóm.
			+ Nhưng khi tạo mới đối tượng Con, bên cạnh vùng RAM gốc của Interface nằm gọn bên trong vùng RAM của Con, vẫn có một vùng RAM mở rộng (nhỏ) để dành cho các hàm trừu tượng đã được hiện thực hoá.
			+ Con trỏ trong vùng RAM vẫn có thể trỏ lưng chừng tại vùng RAM của Interface và vẫn được phép trỏ xuống vùng RAM đã vượt mặt của đối tượng Con.

		- Từ khoá "extends" đã được sử dụng trong quan hệ kế thừa (is a/an), vì vậy, từ khoá "implements" sẽ được sử dụng trong quan hệ hội viên (member of) để tránh bị nhầm lẫn, mặc dù về bản chất thì đây vẫn là thao tác kế thừa.
			+ "Một khi đã máu thì đừng hỏi bố cháu là ai", mặc kệ gốc gác, Interface bây giờ chỉ quan tâm đến việc là thành viên của hội nhóm nào và có những hành động nào tương ứng với hội nhóm đấy.
			+ Việc tham gia hội nhóm cũng bị ảnh hưởng bởi kế thừa, nếu Cha đã là hội viên thì Con cũng sẽ được thừa kế chức hội viên.
			+ Nếu có thêm từ khoá abstract ở tên lớp song song với từ khoá implements - đồng nghĩa với lớp trừu tượng cũng đang tham gia hội nhóm, thì lớp trừu tượng này sẽ không yêu cầu phải hiện thực các hàm trừu tượng, mà nhiệm vụ sau đó sẽ được giao lại cho tất cả những lớp kế thừa từ lớp trừu tượng này.

		- Giống như các hàm trừu tượng, các Interface vẫn được quyền kế thừa (extends) lẫn nhau (ví dụ: List kế thừa từ Collection, Collection kế thừa từ Iterable...).

		* Có nhiều loại Interface khác nhau:

			- Functional Interface: Chỉ có duy nhất một hàm trừu tượng bên trong (có thể có thêm những hàm static và default, nhưng hàm trừu tượng thì chỉ được có một).
				+ Khi triển khai, chỉ cần viết xử lý cho duy nhất hàm này.
				+ Việc triển khai có thể diễn ra trong một lớp riêng lẻ hoặc triển khai trực tiếp tại nơi cần sử dụng dưới dạng lớp nặc danh (có thể áp dụng thêm biểu thực lambda).

			- Marker Interface: Là loại Interface không chứa bất kỳ phương thức nào.
				- Vì không có phương thức để lớp Con hiện thực hoá, nên chỉ được dùng để đánh dấu và "mở khoá tính năng" cho đối tượng của lớp Con.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Interface là một bộ quy tắc ứng xử (hành động) chung,		│
│	nhưng không có phần hướng dẫn chi tiết về cách thức thực hiện,	│
│	mỗi thành viên tham gia sẽ phải tự mình thực hiện hoá xử lý	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Interface giúp linh hoạt trong mọi tình huống			│
│	vì chỉ cần nói chung chung còn ai muốn hiểu thế nào thì tuỳ	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------

		* Cú pháp:

			- Tại lớp Cha - Trừu tượng:

				public interface TênLớpCha {

					// Các hàm trừu tượng (không có code)
					//...
				}

			- Tại lớp Con - Hiện thực hoá:

				// Vì lớp Con được phép kế thừa từ nhiều lớp Interface,
				// nên các lớp Interface sẽ được liệt kê
				// và viết cách nhau bởi dấu phẩy
				public class TênLớpCon implements TênLớpCha1, TênLớpCha2 {

					// Tất cả các hàm vượt mặt (triển khai code)
					// của tất cả các lớp Interface
					// mà ta đã thông báo sẽ hiện thực trước đó
					@Override
					//...
				}

		* Công dụng của Interface:

			- Giúp cho một lớp / đối tượng có nhiều cách hành xử khác nhau.
				+ Mỗi lớp khi được gọi sẽ có những cách triển khai hàm trừu tượng khác nhau.
				+ Mỗi đối tượng sẽ được phép triển khai nhiều hàm trừu tượng.

			- Là một "hình dạng" của đa kế thừa.

				+ Để tránh tình trạng bối rối (ambiguous) trong đa kế thừa khi gọi đến một hàm mà nhiều Cha cùng có (đầy đủ code hoặc trừu tượng), dẫn đến việc khi được gọi sẽ không biết hàm nào mới là hàm thực sự nên được thực thi.

					Ví dụ: Vợ chồng gọi nhau là... "bố, mẹ"
						- Do bắt chước gọi trong vô thức.
						- Hoặc do khát khao có con nên đã tim kiếm sự bù trừ và an ủi ở một việc khác, từ đó hình thành thói quen, đến khi có con cái họ vẫn giữ kiểu xưng hô như vậy.
						-> Khi có mặt đầu đủ vợ chồng và ông bà,
						   nếu gọi "bố ơi" và "mẹ ơi"
						   thì sẽ ít nhất hai người đáp lại.
				
				+ Đồng thời vẫn muốn tận dụng khả năng đa dạng trong hành động do thừa kế từ nhiều lớp cùng một lúc; tuy Java chỉ cho phép kế thừa từ duy nhất một Cha (cụ thể hoặc trừu tượng), nhưng lại cho phép hiện thực từ nhiều Interface khác nhau.

				+ Khi lớp Con tham gia bất kỳ hội nhóm nào, đều sẽ được "trưởng nhóm" giao "nhiệm vụ" triển khai, mỗi lớp sẽ tự mình làm lấy theo cách riêng của mình chứ không sử dụng những hàm có sẵn, giúp thống nhất nhau về tên gọi của hành động, nhưng lại khác nhau (đa dạng) về cách thức thực hiện tuỳ theo mỗi lớp.

				+ Tận dụng việc Interface (chỉ) chứa các hàm trừu tượng (khi này, mặc kệ việc có kế thừa thêm từ Cha và hàm của Cha cũng có chung tên với hàm của Interface), nhưng Con chỉ cần vượt mặt trước khi muốn thực thi là sẽ giúp thống nhất được xử lý cho tất cả các hàm trùng tên - lớp Con là nơi duy nhất tập kết xử lý cho tất cả các hàm Cha (mặc kệ hàm cụ thể hay trừu tượng) - Đa hình.

			-> Tận dụng lại phương thức trừu tượng từ khắp nơi, nhưng lớp Con là nơi duy nhất hiện thực các phương thức trừu tượng này.
				(Phiên bản của Con là phiên bản cuối cùng được thực thi, giúp tận hưởng các hành động theo cách riêng của mình.)

			(Có thể vừa kế thừa từ gia đình, vừa tự mình học hỏi thêm qua các hội nhóm.)

		* Khi nào sử dụng Interface:

			- Liệt kê sẵn một giàn khung gồm nhiều chức năng, trù tính những hàm cần phải có để cung cấp cho bên ngoài.

			- Không muốn có bất kì mối quan hệ nào với những lớp hiện thực hoá.
				+ Đối với kế thừa, giống như một mối quan hệ gia đình, lớp Cha vẫn hoàn toàn có cách để truy cập vào những thuộc tính và phương thức của lớp Con.
				+ Nhưng đối với Interface, Interface Cha hoàn toàn không thể truy cập vào những thuộc tính và phương thức của lớp Con.
				+ Khi sử dụng phương thức, không cần phải quan tâm về việc đang gọi phương thức của Cha hay Con, vì mọi xử lý đều nằm hoàn toàn ở lớp Con.

			- Lắng nghe (listen) / bắt sự kiện (event) trong lập trình GUI.

			- Dependency Injection (DI) là một trong những ứng dụng quan trọng nhất của Interface.
				+ Giúp giải quyết vấn đề gắn kết lỏng lẻo (loose coupling), đảm bảo rằng code trở nên linh hoạt, dễ dàng thay đổi và mở rộng để thích ứng cho tương lai mà không phải thay đổi code cũ - thay đổi code bằng cách viết mới thay vì sửa code cũ.
				+ Giúp cho cách tổ chức các lớp có ràng buộc với nhau và tạo thành một hệ thống lớn, nhưng lại dễ dàng mở rộng và thay đổi.

			-> Giúp việc thiết kế lớp trở nên dễ dàng và linh hoạt.

		* Kết hợp với lớp nặc danh:

			- Tận dụng việc lớp nặc danh sẽ được tạo khi chỉ cần tạo mới đối tượng từ một lớp trừu tượng (mà Interface thực chất cũng chỉ là một lớp trừu tượng) để có được một vùng RAM mở rộng phục vụ cho việc thiết kế những hàm dùng một lần.

			- Giống như việc sinh viên đi học dự thính cũng phải học hành tử tế giống như sinh viên chính khoá; khi muốn trực tiếp tạo mới đối tượng từ Interface, lớp nặc danh cũng phải vượt mặt các hàm trừu tượng giống như những đối tượng truyền thống.

			- Vẫn sẽ gặp những khó khăn của lớp nặc danh trong việc thiết kế các phương thức riêng biệt, vì rất khó đó lấy được con trỏ của Con.
				+ Nhưng với lớp nặc danh kế thừa từ một lớp trừu tượng, vẫn sẽ có thuộc tính để lớp nặc danh sử dụng.
				+ Trong khi đó, lớp nặc danh hiện thực từ lớp Interface sẽ không có bất kì thuộc tính nào. Vì vậy, phải tự thiết kế thêm các thuộc tính cho riêng mình tại nơi gọi hàm nặc danh.

			Ví dụ: Thiết kế Interface và triển khi bằng lớp nặc danh.

				// Interface - Chỉ chứa các hàm trừu tượng
				public interface RacingBoy {
					public double runToDead();
					public void showHowToDead();
				}

				// Lớp nặc danh - Triển khai các hàm trừu tượng
				RacingBoy vietnamRacingBoy = new RacingBoy() { // Nặc danh

					// Vì Interface không hề có bất kì đặc điểm gì,
					// nên bắt buộc phải tự thiết kế lại (nếu cần)
				
					@Override
					public double runToDead() {...}

					@Override
					public void showHowToDead() {...}
				};

		* Ngoại lệ khi sử dụng Interface: Mặc dù Interface được tạo ra để giải quyết vấn đề đa kế thừa (nhiều lớp Cha có cùng tên hàm), nhưng vẫn có một số trường hợp mà nếu chỉ sử dụng một lớp Con thì không thể nào hiện thực hoá được hết các hàm trừu tượng của tất cả các lớp Cha.

			Ví dụ: Hai Interface có chung tên hàm.

				public interface IA {
					String show();
				}

				public interface IB {
					void show();
				}

				// Phương thức Con hiện thực hoá cả hai Interface IA và IB
				public class C implements IA, IB {
					public String show() {...}

					// Xảy ra vấn đề khi đây không được xem là nạp chồng,
					// vì phạm vi truy cập và kiểu dữ liệu trả về
					// không phải là tiêu chí để xem xét việc nạp chồng
					public void show() {...}
				}

----------

		* Từ Java 8, những phương thức mặc định (Default method / Defender method / Virtual extension method) và phương thức tĩnh (Static method) được phép chứa code bên trong Interface.

			- Phương thức mặc định (default) giúp hỗ trợ cho việc tương thích ngược giữa các phiên bản khác nhau của Interface, giúp người sử dụng không bị bắt buộc phải chạy theo mỗi lần Interface có nâng cấp / sửa đổi.
				+ Một khi sử dụng các Interface, bắt buộc phải hiện thực hoá toàn bộ hàm trừu tượng, vấn đề sẽ phát sinh nếu bên cung cấp Interface quyết định thiết kế thêm hàm và phát hành một phiên bản mới cho Interface.
				+ Bên sử dụng sẽ gặp rắc rối nếu cập nhật phiên bản mới của Interface cho phần code xử lý của mình, vì việc thay đổi cấu trúc Interface của nơi phát hành sẽ gây nên sự mâu thuẫn khi có một số hàm (ở nơi sử dụng) chưa được hiện thực hoá.
				+ Vì vậy, phương thức mặc định sẽ giúp người sử dụng không bắt buộc phải thiết kế xử lý cho hàm mới của Interface nếu chưa có nhu cầu, vì hàm mới đã có sẵn những xử lý bên trong (có thể chỉ là một câu thông báo).
				+ Những lớp nào hiện thực hoá Interface đều có thể gọi phương thức này để sử dụng luôn.

			- Một khi đã là phương thức tĩnh (static), bản chất đã không còn thuộc về lớp (và đối tượng được tạo ra từ lớp) đó nữa, mà được đặt ở một vùng nhớ riêng và được sử dụng như một "tiện ích" của Interface (lớp nào gọi cũng được).

			Ví dụ: Phương thức mặc định và phương thức tĩnh chứa code trong Interface.

				interface TestInterface 
				{
					// Phương thức trừu tượng
					public void square (int a);
					
					// Phương thức mặc định
					default void showDefaultMethod() {
						System.out.println("Default Method Executed");
					}

					// Phương thức tĩnh
					static void showStaticMethod() {
						System.out.println("Static Method Executed");
					}
				}

----------------------------------------

* Lưu ý 1: Bản thân Interface cũng là một dạng của kế thừa, vì vẫn đang ké tên hàm, mặc dù không bàn về hành vi.

* Lưu ý 2: Sự khác biệt giữa Inheritance (+ Abstract) và Interface.

	* Giống nhau:

		- Đều là lớp trừu tượng và chứa các hàm trừu tượng.
			+ Không cho phép trực tiếp tạo đối tượng và phải sử dụng một lớp con khác để "kế thừa".
			+ Đều cho phép các lớp Con và đặc biệt là lớp nặc danh hiện thực các hàm trừu tượng của mình.

		- Mục tiêu chung tối thượng: Gắn kết các lớp với nhau dù có những khác biệt trong hành vi.

		-> Có một sự trùng lại nào đó trong code.

		Ví dụ: Mỗi đối tượng khác biệt trong hành xử, nhưng lại có chung mục đích và sân chơi.

			- Các học sinh / sinh viên từ khắp cả nước tập hợp lại trong cùng một trường học, có chung đam mê học tập, dù phương pháp học có thể khác nhau.

			- Các thần bài trên khắp thế giới tập hợp lại trong cùng một sòng bạc, có chung đam mê cờ bạc, dù có những mánh khoé và kỹ thuật khác nhau.

			- Các tuyển thủ trên khắp thế giới tập hợp lại trong cùng một cuộc thi, có chung đam mê thi đấu, dù có những chiến lược và kỹ thuật khác nhau.

			- Các card đồ hoạ (GPU) sử dụng chung Khe cắm PCIe, dù có những khả năng xử lý đồ hoạ khác nhau.

			- Các thiết bị điện tử sử dụng chung ổ cắm điện (220v), dù có khác nhau về công năng / tính năng sử dụng.

	* Khác nhau:

	---------------------------------------------------------------------------------
	|    ABSTRACT CLASS (LỚP TRỪU TƯỢNG)	|	INTERFACE (LỚP GIAO DIỆN)	|
	|	(BÀ CON, HỌ HÀNG)		|	  (CHA NUÔI, MÁ ĐƯỜNG)		|
	|---------------------------------------|---------------------------------------|
	| Là sự gom nhóm theo cây phân cấp,	| Là sự gom nhóm			|
	| dựa trên cả đặc điểm và hành vi	| chỉ dựa trên một hành vi		|
	|---------------------------------------|---------------------------------------|
	| Tên gọi chung cho cả một gia đình lớn	| Tên gọi chung cho một hội nhóm kín,	|
	| gồm nhiều thành viên,			| mỗi thành viên chỉ đến với hội chỉ vì	|
	| mỗi người chia sẻ chung với nhau	| một số mục đích (hành vi) cụ thể,	|
	| rất nhiều đặc điểm và hành vi		| không quan tâm đến những vấn đề khác	|
	| thông qua việc kế thừa		|					|
	|---------------------------------------|---------------------------------------|
	| Mang tính gắn kết chặt chẽ		| Đảm bảo tính linh hoạt và lỏng lẻo	|
	|---------------------------------------|---------------------------------------|
	| Các mối quan hệ			| Các mối quan hệ			|
	| bị bó hẹp trong dòng họ		| được mở rộng ra xung quanh		|
	---------------------------------------------------------------------------------

	---------------------------------------------------------------------------------
	| Giống như một lớp thông thường khi có	| Chỉ tập trung vào việc chứa những	|
	| đầy đủ thuộc tính và phương thức,	| phương thức trừu tượng		|
	| và có thêm phương thức trừu tượng	|					|
	|---------------------------------------|---------------------------------------|
	| Thuộc tính và hàm có thể được khai báo| Thuộc tính và hàm luôn được khai báo 	|
	| với bất kì phạm vi truy cập nào:	| với phạm vi truy cập là public	|
	| public, default, protected và private	| (sau này có thêm private),		|
	|					| mục đích chính là cung cấp tiêu chuẩn	|
	|					| để nhiều nơi có thể tuân theo,	|
	|					| chứ không phải là để hạn chế truy cập	|
	|---------------------------------------|---------------------------------------|
	| Thuộc tính có thể ở bất kì dạng nào:	| Thuộc tính phải ở dạng hằng số: 	|
	| static, non-static, final, non-final	| public static final			|
	|---------------------------------------|---------------------------------------|
	| Được phép có phễu để tạo đối tượng mới| Không được phép có phễu, vì không phải|
	|					| là lớp và không phải để tạo đối tượng	|
	|---------------------------------------|---------------------------------------|
	| Được phép có những phương thức	| Ngoài những phương thức trừu tượng,	|
	| trừu tượng, phương thức cụ thể	| Được phép có những phương thức tĩnh	|
	| hoặc thậm chí là phương thức tĩnh	| và phương thức mặc định		|
	|					| (miễn không cần dùng đến thuộc tính)	|
	|---------------------------------------|---------------------------------------|
	| (Trong Java) Mỗi lớp Con chỉ được phép| Mỗi lớp Con được phép hiện thực	|
	| kế thừa từ một lớp Cha duy nhất,	| nhiều Interface			|
	| nhưng sau khi kế thừa vẫn được phép	|					|
	| hiện thực nhiều Interface		|					|
	---------------------------------------------------------------------------------

		Ví dụ: Nếu xem việc sử dụng lớp trừu tượng (Abstract Class) và Interface như một chuyến đi chơi.

			- Lớp trừu tượng (Abstract Class): Đi du lịch theo tour.
				+ Được công ty du lịch chuẩn bị sẵn hết mọi thứ giống như đã nêu rõ trong điều khoản.
				+ Được sắp xếp sẵn nơi ở, phương tiện đi lại, nơi ăn uống, nơi mua sắm...
				+ Được tham quan với sự giám sát, hướng dẫn của những hướng dẫn viên du lịch.
				+ Chi trả chi phí một lần duy nhất cho công ty du lịch trước khi bắt đầu đi tour và tự chi trả cho những chi phí phát sinh trong quá trình đi du lịch (ví dụ: mua sắm...).

				-> Là sự kết hợp giữa trừu tượng và cụ thể.

			- Interface: Đi du lịch tự túc.
				+ Tự tay lên lịch trình, tự đặt vé máy bay, chỗ ở...
				+ Chủ động trong việc việc di chuyển, tìm nơi thuê phương tiện di chuyển, tìm những quán ăn ngon, chỗ ăn nổi tiếng, nơi mua sắm...
				+ Tự tìm hiểu điều kiện tự nhiên, lịch sử, cuộc sống và văn hóa của người dân địa phương.
				+ Tự chi trả cho mọi hoạt động diễn ra trong suốt quá trình đi du lịch.

				-> Tất cả mọi thứ đều là trừu tượng.

--------------------------------------------------------------------------------

[VÙNG RAM KHI KẾ THỪA]

Vùng RAM của khuôn Con sẽ rất lớn, mặc dù có thể ít code hơn.
	- Vì phải chứa thêm cả khuôn của Cha bên trong.
	- Vùng nhớ của cha sẽ làm nền (base) để con có thể kế thừa và mở rộng (extends).
	- Nhờ đó mà những đối tượng được đúc từ khuôn Con mới có thể chấm để gọi ra được những thuộc tính và phương thức của Cha - thừa kế tất cả những thứ được cho phép.
	-> Vùng nhớ của Cha, nếu mở rộng sẽ thành vùng nhớ của Con.

		* Cha (super) + Vùng mở rộng (extends) = Con (sub) *

Vùng RAM sẽ bị tốn thêm một cách không cần thiết, nhưng lại giúp tiết kiệm công sức trong việc thiết kế các đoạn mã soạn sẵn và các hàm.

------------------------------------------------------------

	[CON TRỎ & VÙNG RAM TRONG KẾ THỪA]

1. Khai Cha = new Cha();

	- Con trỏ sẽ trỏ đến đáy vùng RAM của Cha.

	- Khi chấm sẽ hiện ra toàn bộ thuộc tính và phương thức của riêng Cha.

2. Khai Con = new Con();

	- Con trỏ sẽ trỏ đến đáy vùng RAM của Con, mặc dù bên trong Con có chứa vùng nhớ của Cha.

	- Khi chấm sẽ hiện ra:
		+ Toàn bộ thuộc tính và phương thức của Cha.
		+ Những phương thức do con vượt mặt (Override).
		+ Những phương thức của riêng Con.

3. Khai Cha = new Con();

	- Con trỏ sẽ chỉ trỏ đến đúng đáy vùng RAM của Cha nằm bên trong Con (vùng super).
		+ Dù đang new Con, nhưng bản chất quan trọng nhất vẫn là đang khai Cha.
		+ Đồng thời, con trỏ sẽ chỉ trỏ xuống vùng RAM của Con (vùng extends) khi bắt gặp từ khoá @Override.

	- Khi chấm sẽ hiện ra:
		+ Toàn bộ thuộc tính và phương thức của riêng Cha.
		+ Mặc dù khi thực thi, những hàm do Con Override đồng thời sẽ do Con đảm nhận việc xử lý -  đa hình; nhưng đây vẫn là khai Cha và con trỏ của Cha, nên vẫn sẽ mang danh nghĩa của Cha - không hiển thị hàm do Con Override.
		+ Ngoài ra, nếu không có từ khoá @Override, dù Con có thiết kế bao nhiêu hàm cho riêng mình đi nữa thì cũng không thể thấy và sử dụng được.
			* Nếu muốn, phải sử dụng kỹ thuật "Tổ lái con trỏ" - Drift.

------------------------------------------------------------

	[KỸ THUẬT ÉP KIỂU / TỔ LÁI CON TRỎ - CASTING / DRIFT]

Khi đã khai Cha và new Con(), đồng nghĩa với việc sẽ sử dụng Con với danh nghĩa của Cha. Vì vậy:
	- Mọi hàm do Con Override chỉ thật sự có tác dụng khi thực thi, còn trên danh nghĩa (hiển thị) thì vẫn sẽ là của Cha.
	- Nhưng những hàm của riêng Con và không hề được Override sẽ không được hiển thị (đối với Cha), vì con trỏ đang chỉ giới hạn trỏ đến vùng RAM của Cha nằm bên trong vùng RAM của Con.
	
	-> Sử dụng thêm kỹ thuật để đưa con trỏ của Cha xuống đáy vùng new của Con.

* Ép kiểu / Tổ lái (Casting / Drift) con trỏ: Đánh lái địa chỉ vùng RAM (đối tượng) đến một vùng RAM (đối tượng) khác không cùng một lớp.
	- Cho phép lấy toạ độ, thay đổi hình dáng của dữ liệu (ép kiểu dữ liệu), sau đó cất toạ độ vừa chuyển đổi được vào một nơi.
	- Yêu cầu vùng RAM (được tổ lái đến) phải có một tên gọi cụ thể, không nên là kiểu nặc danh, vì khi ấy phải sử dụng đến kỹ thuật Reflection để có thể lấy được con trỏ.

	- Có hai dạng ép kiểu:

		1. Down casting: Đưa con trỏ (mang danh nghĩa) của Cha xuống đáy vùng nhớ của riêng Con, cho phép Cha thấy được những hàm riêng biệt của Con.
			- Bản chất của việc ép kiểu là vẫn đứng yên tại chỗ nhưng sẽ được nhìn với một "ngoại hình" khác.
			- Vì vậy, cần phải cần thận vì đôi khi thấy được những thuộc tính và phương thức của riêng Con, nhưng Cha lại không có những thuộc tính và phương thức tương ứng để tiến hành xử lý.

		2. Up casting: Đưa con trỏ của Con lên vùng nhớ của riêng Cha.

----------------------------------------

* Các kỹ thuật ép kiểu con trỏ:

	* Tường minh (Explicit): Sử dụng một con trỏ tạm để nhận địa chỉ.

		1. Chuẩn bị một con trỏ tạm để đi xuống đáy vùng new() của Con và lưu toạ độ của Con.
		2. Vì Con đang được khai báo dưới danh nghĩa của Cha, nên trước khi sử dụng phải ép kiểu trở lại thành Con chính gốc.

		* Cú pháp:
			(Kiểu-dữ-liệu-của-Con)biếnConTrỏCủaChaĐangTrỏLưngChừng;

		Ví dụ: Ép kiểu con trỏ tường minh.

			Parent c2 = new Child(...);

			// Về nguyên tắc,
			// con trỏ của Con sẽ cần một vùng new Con()
			
			// Vì vậy, ta sẽ tiến hành khai báo Con (tạm thời)
			// và sử dụng con trỏ này tạm để chuẩn bị lưu toạ độ,
			// sau đó ép kiểu cho Con và đưa vùng RAM
			// (vừa ép kiểu xong) vào cho con trỏ tạm
			Child x = (Child)c2;
			
			// Lúc này,
			// ta hoàn toàn có thể sử dụng con trỏ tạm
			// để thực thi các hàm của riêng Con
			x.sayHi();

	* Ngầm định (Implicit): Tận dụng nguyên lý "Miễn có toạ độ là có thể chấm".
	
		- Sau khi ép kiểu xong, thay vì gán cho biến trung gian, ta trực tiếp chấm luôn.
		- Nhưng vì dấu chấm có độ ưu tiên cao khi có thể can thiệp vùng RAM và gắn liền với kiểu dữ liệu được khai báo phía trước.
			+ Khi đứng giữa hai sự lựa chọn là dấu chấm và ép kiểu, sẽ xảy ra hiện tượng tài lanh, lấy con trỏ đi chấm khi chưa kịp ép kiểu xong.
			+ Vì vậy, để việc ép kiểu được diễn ra trước và sau đó mới tiến hành chấm, ta sẽ sử dụng thêm một cặp dấu ngoặc tròn ở bên ngoài để thay đổi độ ưu tiên.

		* Cú pháp: ((Con)conTrỏCủaCha)

		Ví dụ: Ép kiểu con trỏ ngầm định.

			Parent c2 = new Child(...);

			// Khi này, mặc dù đã ép kiểu,
			// nhưng nếu sử dụng trực tiếp thông qua dấu chấm
			// thay vi gán địa chỉ cho một biến tạm khác
			// thì sẽ chỉ hiển thị những gì của riêng Cha,
			// vì vẫn đang mang kiểu dữ liệu của Cha
			//	-> Dấu chấm chỉ ăn theo biến c2
			//(Child)c2.sayHi();
			
			// Để ép kiểu ngầm định,
			// ta phải sử dụng thêm một cặp dấu ngoặc tròn ở bên ngoài
			// để thay đổi độ ưu tiên
			((Child)c2).sayHi();

--------------------------------------------------------------------------------

* Lưu ý 1: Việc sao chép và dán chỉ là kỹ thuật mánh mung để bắt chước và vẫn phải tốn công sức để thực hiện, nên chưa được gọi là kế thừa; phải "không làm mà vẫn có ăn" thì mới được gọi là kế thừa.

	Ví dụ: Sự khác nhau giữa thừa kế và bắt chước.

		* Bắt chước: Người này muốn có được thứ mà người kia cũng có.
			-> Hai phiên bản giống nhau, nhưng vẫn độc lập với nhau.

		* Ké thừa: Người đi trước để lại cho người đi sau.
			-> Chỉ có duy nhất một phiên bản, có liên kết với nhau.

* Lưu ý 2: Nên sử dụng một hàm trừu tượng làm khuôn gốc để những nơi khác kế thừa / hiện thực hoá thay vì chỉ thiết kế một hàm duy nhất và sau đó sử dụng những câu lệnh điều kiện if để quy định những hàm nhỏ hơn nào được phép thực thi dựa trên if.
	- Việc sử dụng if sẽ khiến cho code thiếu đi tính mở rộng và linh hoạt, không thể thích ứng nếu sau này có thêm nhiều lớp khác tham gia vào nữa.

==========================================================================================

[4. TÍNH ĐA HÌNH / ĐA XẠ - POLYMORPHISM]

Về nguyên tắc, các phần tử trong cùng một mảng thì phải có cùng kiểu dữ liệu / lớp. 
	- Nếu giữa các phần tử khác nhau trong mảng (khác kiểu dữ liệu / khác lớp), nhưng lại có chung tên phương thức.
	- Lúc này, khi thực thi một phương thức nào đó thì mỗi đối tượng sẽ tự động thực hiện phương thức theo cách của riêng mình và cho ra được những kết quả khác nhau.
	-> Cùng một phương thức, nhưng các đối tượng khác nhau khi thực thi sẽ cho ra những kết quả khác nhau.
		=> Có nhiều dạng hình thức / biến thể khác nhau của cùng một ý tưởng.

	[Đa ánh xạ / Đa hình dạng / Đa cách thức / Đa nhân cách / Đa sắc thái]

	Ví dụ 1: cùng một phương thức xácThựcNgườiDùng() / xácThựcĐăngNhập().
		- Apple: xác thực vân tay.
		- Samsung: xác thực mống mắt.
		- Nokia: xác thực khuôn mặt.
		-> Cùng là xácThực(), nhưng cách thức hoạt động của từng điện thoại lại khác nhau.

* Tính đa hình (Polymorphism): Khi nhắc đến một vấn đề thì lại có rất nhiều cách khác nhau để thực hiện vấn đề đó. Dù các đối tượng không chung một lớp, nhưng nếu có chung một nguồn gốc và tên phương thức thì khi được gọi, mỗi đối tượng sẽ có một cách riêng của mình để thực thi phương thức.

Đa hình thường xuất hiện trong các lớp trừu tượng (abstract) khi nhiều lớp Con cùng kế thừa / hiện thực từ một lớp Cha trừu tượng - có sự đồng nhất giữa các lớp Con.

	- Là kỹ thuật mà hàm Cha chỉ cần là trừu tượng (chỉ có tên hàm), sau đó để cho Con thoả sức sáng tạo nhờ kế thừa / hiện thực và @Override.

	- Giúp những sự khác biệt vẫn có thể ở chung với nhau thông qua một tên gọi chung, khi cùng liên quan đến một lớp Cha trừu tượng nào đó.

	- Cho phép có những sự đa dạng trong một lời gọi hàm khỉ cần gọi tên hàm Cha trừu tượng, nhưng tuỳ vào ngữ cảnh (đối tượng) mà một hàm Con phù hợp sẽ vượt mặt để thực thi, tuỳ theo những gì mà mình đã hiện thực (implement) từ Cha.

	- Đảm bảo tính đa dạng của hàm, nhưng vẫn thống nhất với nhau về hành động và mục tiêu thông qua tên gọi.

	-> Vượt mặt (@Override) chính là cách thức hiện thực cho tính đa hình.
		(Sử dụng @Override để biến hoá ra nhiều hình dạng khác nhau.)

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Hàm thuỷ tổ trừu tượng được nhiều hàm Con @Override	│
│	Sử dụng ở mức Cha, nhưng lại được lớp Con hưởng ứng	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Từ ý tưởng ban đầu, song lại có nhiều cách thực hiện khác nhau,	│
│	giúp thống nhất trong hành động, nhưng tự do trong triển khai	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

	[OVERLOAD VS. OVERRIDE]

Đây là một trong những kỹ thuật để hỗ trợ cho việc thực hiện tính đa hình trong lập trình hướng đối tượng.
	-> Đều giúp cho một hàm có nhiều phiên bản khác nhau.

------------------------------------------------------------

	[OVERLOAD - ANH EM BÀ CON]

	* Nạp chồng / Quá tải (Overload): Là hiện tượng có thể xảy ra trong bất kì lớp nào.
	
		- Trong một lớp bất kì, nếu có nhiều hàm trùng tên nhau nhưng lại khác tham số đầu vào thì được gọi là nạp chồng hàm/quá tải hàm (Overload).
			+ Giúp linh hoạt trong việc xử lý khi một hàm có thể nhận bất kì loại tham số nào (hợp lệ - đã được quy định sẵn) mà vẫn trả về được kết quả xử lý mong muốn.
			+ Giúp mở rộng dễ dàng, thay vì phải liên tục thay đổi tên hàm, nay chỉ cần thay đổi tham số là một hàm tương ứng sẽ được gọi để xử lý.
			+ Ngoài ra, khi đã thống nhất sử dụng chung một tên hàm, nếu sau này tên hàm có thay đổi, những nơi có sử dụng cũng sẽ dễ dàng được thay đổi theo nhờ vào cơ chế tái cấu trúc mã nguồn (Refactor) có sẵn trong các IDE.

			-> Tính đa hình (Polymorphism): Cùng một tên gọi, nhưng có nhiều cách thực hiện khác nhau tuỳ thuộc vào từng ngữ cảnh.

			Ví dụ: Cổng USB-C có thể nhận nhiều loại thiết bị khác nhau như: đầu ra video, loa, bàn phím, chuột, điện thoại (sạc, truyền dữ liệu...)...
				- Bên trong đã định nghĩa nhiều phương thức (xử lý) khác nhau cho mỗi loại thiết bị.
				- Trình biên dịch (hệ thống) sẽ dựa vào kiểu thiết bị để xác định phương thức cần được gọi khi kết nối thiết bị tương ứng.
		
		- Việc đặt trùng tên còn giúp tiết kiệm công sức trong việc đặt tên mới, chỉ cần sử dụng một tên thống nhất mà vẫn có thể đáp ứng được những nhu cầu sử dụng đa dạng.
			+ Khi có trùng tên hàm, dựa trên tham số truyền vào hàm, trình biên dịch sẽ tự động phát hiện và biết phải sử dụng hàm nào để tiến hành xử lý.
			+ Tuy các hàm trùng tên nhau, nhưng vẫn phải có cách nào đó để phân biệt giữa các hàm, nếu không sẽ giống như "Sự tích trầu cau" khi gọi hàm này nhưng hàm khác lại thực thi.
			+ Vì vậy, để phân biệt với nhau, danh sách tham số của hàm phải khác về:
				1. Thứ tự liệt kê của tham số
				2. Kiểu dữ liệu của tham số.
				3. Số lượng tham số.

				(Khác tên gọi tắt / tên biến tham số sẽ không được xem là nạp chồng.)

			Ví dụ 1: Nạp chồng hàm in số nguyên tố.

				// Trùng tên hàm cũng được, miễn là khác kiểu dữ liệu
				// và không quan tâm đến tên biến
				public static void printIntegerList(int n) {...}
				public static void printIntegerList(double n) {...}

				// Tuy trùng tên và khác tên biến
				// nhưng lại trùng kiểu dữ liệu -> Báo lỗi
				public static void printIntegerList(int n) {...}
				public static void printIntegerList(int ahihi) {...} // BÁO LỖI

			Ví dụ 2: Nạp chồng hàm tính diện tích tam giác.

				// Tuỳ vào tham số được cung cấp
				// mà hàm xử lý tương ứng sẽ được gọi để xử lý
				public double tinhDTTG(double canh, double chieuCao) {...}
				public double tinhDTTG(double a, double b, double c) {...}
		
		- Chỉ cần đáp ứng đủ hai tiêu chí: trùng tên và khác danh sách tham số, thì sẽ được gọi là nạp chồng.

			+ Việc các hàm khác về phạm vi truy cập sẽ không phải là yếu tố quyết định việc nạp chồng, thậm chí với phạm vi truy cập private vẫn có thể xảy ra nạp chồng nếu được thiết kế ngang cấp với hàm main().

				Ví dụ 1: Hiện tượng khác kiểu dữ liệu trả về & phạm vi truy cập trong nạp chồng hàm.

					// Hàm gốc
					public int tinhSoNguyen(int n) {...}

					// Nạp chồng
					protected long tinhSoNguyen(long n) {...}

				Ví dụ 2: Nạp chồng cho phương thức có phạm vi truy cập là private.
					public class MayTinh {

						private int congSo(int a , int b) {...}

						private int congSo(int a , int b, int c) {...}

						public static void main(String args[]) {
							MayTinh mt = new MayTinh();
							System.out.println(mt.congSo(12, 13));
							System.out.println(mt.congSo(12, 13, 15));
						}
					}

			+ Ngoài ra, trong trường hợp trùng tên, nhưng lại khác kiểu dữ liệu trả về:
				1. Trùng danh sách tham số: Báo lỗi hàm đã được định nghĩa, vì sẽ gây bối rối khi không biết phải sử dụng hàm nào nếu được gọi.
				2. Khác danh sách tham số: Vẫn được xem là nạp chồng vì đã đáp ứng đủ các tiêu chí để nạp chồng (trùng tên hàm + khác tham số đầu vào).

				Ví dụ: Hiện tượng khác kiểu dữ liệu trả về trong nạp chồng hàm.

					// Hàm gốc tính chu vi của hình tròn
					public double tinhChuVi() {...}

					// 1. Khác kiểu dữ liệu trả về & Trùng danh sách tham số
					//	-> Bối rối và báo lỗi
					public float tinhChuVi() {...}

					// 2. Khác kiểu dữ liệu trả về & Khác danh sách tham số
					//	-> Vẫn nạp chồng
					public float tinhChuVi(double R) {...}

			+ Phương thức tĩnh (static method) vẫn có thể nạp chồng, miễn là phương thức nạp chồng cũng phải là phương thức tĩnh.

				Ví dụ: Nạp chồng phương thức tĩnh.

					public static void hienThi() {...}

					public static void hienThi(String a) {...}

		-> Một lớp bất kì có nhiều hàm trùng tên, nhưng khác danh sách tham số đầu vào.
			=> Tạo nên sự đa dạng trong cách sử dụng.
			(Năm dân chơi hàm trùng tên trên một "lớp" xe Wave - Quá tải.)
			(Hàm đến sau vào sống chung và nằm đè lên hàm đến trước - Nạp chồng.)
		(Nhiều thứ gần tương đương nhau, được chất chồng lên nhau trong một đơn vị.)

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Xảy ra trong một lớp bất kì, khi các hàm trùng tên nhau,		│
│	nhưng khác tham số đầu vào (khác số lượng, thứ tự hoặc kiểu dữ liệu),	│
│	không quan tâm kiểu dữ liệu trả về và phạm vi truy cập			│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

	[OVERRIDE - CÒI TO CHO VƯỢT]

	* Vượt mặt / Phủ quyết (Override): Là hiện tượng chỉ xảy ra trong mối quan hệ kế thừa Cha - Con (nhiều lớp khác nhau).
	
		- Trong mối quan hệ kế thừa Cha - Con, khi các hàm Con hoàn toàn trùng tên và kiểu dữ liệu với hàm Cha.
			+ Là tình trạng "Con hơn cha là nhà có phúc", đặc trưng cho tính đa hình / đa xạ (Polymorphism).
			+ Hàm Con mượn lại hoàn toàn tên hàm và danh sách tham số từ Cha, nhưng khước từ những hành động mà Cha đã làm trước đó (hoặc do Cha không làm gì hết - hàm trừu tượng) để tự mình thiết kế lại (vượt mặt) hành động.
			+ Từ khoá @Override sẽ được đặt ở hàm Con để thông báo và làm rõ ý nghĩa, nhưng không bắt buộc phải có.
			
			-> Tính đa hình (Polymorphism): Cùng một tên gọi, nhưng có nhiều cách thực hiện khác nhau tuỳ thuộc vào từng ngữ cảnh.

			Ví dụ: Giống như việc khi còn nhỏ, mọi việc lớn nhỏ trong nhà đều sẽ do cha mẹ thực hiện; nhưng khi lớn lên, con cái sẽ dần dần thay thế thay mẹ trong việc nhà, bếp núc, lái xe...

		- Hàm của lớp Con yêu cầu phải có phạm vi truy cập bằng hoặc rộng hơn của Cha.

			Ví dụ: Lớp Con vượt mặt hàm và có phạm vi truy cập lớn hơn hàm của Cha.

				// Khuôn hình chữ nhật - Khuôn Cha
				public class Rectangle {

					// Hàm gốc của Cha,
					// phạm vi truy cập bị giới hạn
					protected void paint() { ... }
				}

				// Khuôn hình vuông - Khuôn Con
				public class Square extends Rectangle {

					// Hàm vượt mặt của Con,
					// phạm vi truy cập được phép bằng hoặc rộng hơn
					@Override
					public void paint() { ... }
				}
		
		- Nếu hàm của lớp Cha có từ khoá final hoặc có phạm vi truy cập là private thì lớp Con sẽ không được phép vượt mặt, riêng đối với từ khoá static thì vẫn được phép (nhưng sẽ không được gọi là vượt mặt).

			+ Nếu cố tình vượt mặt phương thức final của lớp Cha, lớp Con sẽ nhận được lỗi biên dịch, hoặc nếu cố tình xoá đi từ khoá final sau khi vượt mặt cũng sẽ gây ra lỗi biên dịch do từ đầu thì phương thức final đã không cho vượt mặt.

				Ví dụ: Lớp Con không được vượt mặt hàm final của Cha.

					public class Cha {
						// Hàm mà Cha không cho phép vượt mặt
						public final void hienThi() {...}
					}

					public class Con extends Cha {

						// Cố tình vượt mặt hàm final của Cha
						// mặc kệ cảnh báo rằng hàm final
						// không cho phép vượt mặt
						//	-> Lỗi biên dịch
						@Override
						public final void hienThi() {...}

						// Xoá đi từ khoá final sau khi vượt mặt
						// cũng không thể giải quyết vấn đề,
						// vì vốn dĩ hàm final không cho vượt mặt
						//	-> Vẫn lỗi biên dịch
						@Override
						public void hienThi() {...}
					}

			+ Nếu cố tình vượt mặt phương thức có phạm vi truy cập là private của lớp Cha, lớp Con sẽ không xem đây là vượt mặt mà chỉ đơn giản xem đây là một hàm mới của riêng Con, vì Con không thể biết những gì mà Cha đã che giấu.

				Ví dụ: Lớp Con không thấy hàm private của Cha nên không được gọi là vượt mặt.

					public class Cha {
						private void hienThi() {...}
					}

					public class Con extends Cha {

						// Từ khoá Override trở nên dư thừa
						// và sẽ báo lỗi biên dịch nếu thêm vào,
						// vì trình biên dịch phát hiện
						// có từ khoá Override
						// nhưng lại chưa có hàm vượt mặt
						// @Override

						// Đây được xem là một hàm riêng của lớp Con,
						// không phải vượt mặt
						public void hienThi() {...}
					}

			+ Nếu cố tình vượt mặt phương thức static của lớp Cha, vì static là những thứ sử dụng chung nên đây sẽ không được xem là vượt mặt (lớp Cha sẽ làm lu mờ đi phương thức của Con) và không được phép đi kèm với từ khoá @Override.
				1. Nếu sử dụng tên lớp để gọi, sử dụng tên lớp nào thì phương thức của lớp đó sẽ được gọi.
				2. Nếu sử dụng tên đối tượng, khi khai Cha - new Con, vì Con đã bị Cha làm lu mờ (che mất), nên phương thức của lớp Cha sẽ được gọi.

				Ví dụ: Lớp Con không thấy hàm private của Cha nên không được gọi là vượt mặt.

					public class Cha {
						public static void hienThi() {
							System.out.println("Hàm lớp Cha");
						}
					}

					public class Con extends Cha {

						// Từ khoá Override trở nên dư thừa
						// và sẽ báo lỗi biên dịch nếu thêm vào,
						// vì trình biên dịch phát hiện
						// có từ khoá Override
						// nhưng lại chưa có hàm vượt mặt
						// @Override

						// Đây được xem là một hàm riêng của lớp Con,
						// không phải vượt mặt
						public static void hienThi() {
							System.out.println("Hàm riêng lớp Con");
						}
					}

					public static void main(String[] args) {

						Cha test = new Con();

						// 1.1. Sử dụng tên lớp Cha để gọi,
						//	hàm tương ứng của lớp sẽ được gọi
						Cha.hienThi();	// Hàm lớp Cha

						// 1.2. Sử dụng tên lớp Con để gọi,
						//	hàm tương ứng của lớp sẽ được gọi
						Con.hienThi();	// Hàm riêng lớp Con

						// Cha làm Con bị lu mờ,
						// chỉ có hàm của Cha được gọi
						test.hienThi();	// Hàm lớp Cha
					}

		- Khi vượt mặt, ở hàm Con, tuyệt đối nên cẩn thận khi sử dụng hai từ khoá final và static.

			+ Đối với từ khoá final, lớp Con có thể tự thêm từ khoá này vào hàm của mình sau khi vượt mặt (mặc dù Cha không có) để ngăn một lớp khác vượt mặt mình.

				Ví dụ: Lớp Con sau khi vượt mặt vẫn được phép thêm final.

					class Cha {
						public void hienThi() {...}
					}

					class Con extends Cha {

						// Vượt mặt hàm của Cha,
						// nhưng lại đồng thời sống "ích kỷ",
						// không cho phép ai khác vượt mặt mình
						@Override
						public final void hienThi() {...}
					}

			+ Đối với từ khoá static, nếu lớp Con tự ý thêm static vào hàm vượt mặt (mặc dù Cha không có static), điều này sẽ gây ra lỗi biên dịch.

				Ví dụ: Lỗi biên dịch vì lớp Con tự ý thêm static vào hàm vượt mặt.

					class Cha {

						// Lớp bình thường, không có static
						//	-> Hợp lệ để vượt mặt
						public void hienThi() {...}
					}

					class Con extends Cha {

						// Con tự ý thêm static vào hàm vượt mặt
						//	-> Lỗi biên dịch
						public static void print() {...}
					}

		- Vì hiện tượng nạp chồng (Overload) có thể xảy ra ở bất kì lớp nào.
			+ Bên trong lớp Con có Override phương thức từ Cha thì vẫn có thể có thêm các hàm Overload.
			+ Khi đã Overload một lớp vừa Override từ Cha, từ khoá @Override không còn yêu cầu phải có nữa, vì đang tuân theo luật của Overload.

			Ví dụ: Overload phương thức mà Con đã Override.

				// Khuôn hình vuông - Khuôn Con
				public class Square extends Rectangle {

					// Hàm vượt mặt của Con
					@Override
					public void paint() { ... }

					// Hàm nạp chồng từ hàm vượt mặt
					public void paint(String s) { ... }
				}

		-> Trong lớp Con có hàm trùng tên và tham số với hàm của lớp Cha.
			=> Định nghĩa lại những thứ đã có sẵn.
			(Con hơn cha là nhà có phúc.)
			(Hàm đến sau làm lu mờ đi hàm đến trước - Phủ quyết.)
		(Nhiều thứ giống nhau hoàn toàn, nhưng một rừng không thể có hai cọp.)

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Xảy ra giữa các lớp có mối quan hệ kế thừa,				│
│	khi các hàm giữa các lớp trùng tên, trùng danh sách tham số đầu vào	│
│	và cho phép kế thừa: không có final, static hoặc phạm vi private	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

	* Lưu ý: Đừng nhầm lẫn giữa cách đọc tên và chức năng của các thuật ngữ trong lĩnh vực máy tính.
		- Override: Vượt mặt, đối tượng bị vượt mặt vẫn còn nguyên.
		- Overwrite: Ghi đè, giá trị cũ sẽ bị biến mất vĩnh viễn.

------------------------------------------------------------

	* Bảng so sánh giữa Overload và Override:

	-----------------------------------------------------------------
	|		|	Overload	|	Override	|
	|---------------|-----------------------|-----------------------|
	| Vị trí	| Trong cùng lớp hoặc	| Chỉ trong lớp kế thừa	|
	| trong lớp	| trong lớp kế thừa	|			|
	|---------------|-----------------------|-----------------------|
	| Phạm vi	|			| Lớp Con phải bằng hoặc|
	| truy cập	| Không phải là tiêu chí| rộng hơn của lớp Cha	|
	|---------------| để xem xét nạp chồng	|-----------------------|
	| Kiểu dữ liệu	|			| Bắt buộc trùng với 	|
	| kết quả trả về|			| hàm của lớp Cha	|
	|---------------|-----------------------------------------------|
	| Tên gọi	| 		    Cùng tên			|
	|---------------|-----------------------------------------------|
	| Tham số	| Khác danh sách tham số| Cùng danh sách tham số|
	|---------------|-----------------------|-----------------------|
	| Số lượng hàm	| Có thể có nhiều hàm	| Chỉ có thể có một hàm	|
	|		| trong một lớp		| trong một lớp		|
	-----------------------------------------------------------------

--------------------------------------------------------------------------------

	[RÀNG BUỘC / GẮN KẾT ĐỘNG - DYNAMIC BINDING]

* Ràng buộc / Gắn kết động (Dynamic Binding): Cho phép chỉ định rõ phương thức nào của đối tượng sẽ được gọi tại thời điểm chạy, dựa trên kiểu của đối tượng đó.

	- Khi khai Cha - new Con:
		+ Lớp Cha được gọi là kiểu khai báo (Declared Type) - Kiểu danh nghĩa, đối tượng mượn danh để ra oai.
		+ Lớp Con được gọi là kiểu thực sự (Actual Type) - Kiểu thực sự mà đối tượng tham chiếu đến.

		Ví dụ: Cha doiTuongCha = new Con();
			^			^
			|			|
			|			|
			|			Kiểu thực sự (Actual Type)
			|
			|
			Kiểu khai báo (Declared Type)

			// Việc quyết định phương thức nào sẽ được thực thi
			// khi có kể thừa và nạp chồng
			//	-> Ràng buộc động (Dynamic Binding)
			doiTuongCha.phuongThuc();

	- Trong quan hệ kế thừa (đơn kế thừa - phân tầng), nếu khai Cha - new Con và gọi phương thức mà Con đã vượt mặt Cha.
		+ Khi hiển thị, sẽ chỉ thấy những phương thức của riêng Cha.
		+ Khi thực thi, trình biên dịch sẽ dựa vào kiểu dữ liệu của đối tượng (nằm sau chữ new) để xác định xem phương thức nào sẽ thực sự được gọi.

		-> Mang danh nghĩa của Cha, nhưng lại thực thi phương thức của Con.

		Ví dụ: Khai Cha - new Con, gọi hàm của Con.

			class Animal {
				public void makeSound() {
					System.out.println("Animal makes a sound");
				}
			}

			class Cat extends Animal {

				// Hàm của riêng Con
				public boolean isLiquid() {
					return true;
				}

				// Hàm vượt mặt Cha
				@Override
				public void makeSound() {
					System.out.println("Cat meows");
				}
			}

			Animal animal = new Cat();

			// Đối tượng animal thuộc lớp Animal
			// sẽ không thể thấy những phương của lớp Cat,
			// trừ khi được ép kiểu dữ liệu

			// Gắn kết động sẽ cho phép chương trình
			// xác định phương thức cụ thể để gọi
			// dựa trên kiểu đối tượng thực tế
			animal.makeSound(); // Cat meows

	- Nếu có nhiều lớp kế thừa (theo dạng phân tầng), khi khai Cha - new Con và bắt đầu gọi phương thức.
		+ Trong giai đoạn biên dịch (compile time), JVM sẽ chỉ kiểm tra xem phương thức được gọi có tồn tại trong lớp Cha hay không, nếu không sẽ báo lỗi.
		+ Trong giai đoạn thực thi (runtime), sẽ ưu tiên gọi phương thức của lớp Con nếu lớp Con có vượt mặt, nếu lớp Con không vượt mặt thì sẽ tự động gọi phương thức của lớp Cha gần nhất (nếu vẫn không có thì sẽ truy ngược lại cây kế thừa cho đến khi gặp được lớp Cha đầu tiên).

	- Vì một đối tượng danh nghĩa của Cha có thể tham chiếu đến bất kì đối tượng nào của Con.
		+ Khi sử dụng chỉ cần lấy đối tượng của Cha để gọi phương thức, nhờ vào gắn kết động mà phương thức tương ứng sẽ được gọi.
		+ Từ đó giúp tăng tính mở rộng của chương trình khi cho phép ta quản lý và tương tác trên lớp Cha, những lớp Con kế thừa từ lớp Cha này sẽ tự động được ảnh hưởng theo.

		Ví dụ: Hai lớp Sách và BăngĐĩa kế thừa từ lớp SảnPhẩm.
			- Khi muốn quản lý danh sách các loại sách và băng đĩa, ta chỉ cần thiết kế lớp riêng để quản lý lớp SảnPhẩm.
			- Sau này có mở rộng (thiết kế thêm lớp, ví dụ: VănPhòngPhẩm) thì vẫn giữ nguyên việc tương tác trên lớp SảnPhẩm, chỉ cần cho lớp mới kế thừa từ lớp SảnPhẩm.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Chọn phương thức để thực thi trong chuỗi quan hệ kế thừa	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================
==========================================================================================
==========================================================================================

[MINH HOẠ 4 NGUYÊN LÝ THIẾT KẾ HƯỚNG ĐỐI TƯỢNG
 NHƯNG KHÔNG SỬ DỤNG CÁC KHÁI NIỆM TRONG LẬP TRÌNH]

==========================================================================================

[1. TÍNH TRỪU TƯỢNG / SÚC TÍCH - ABSTRACTION]

Diễn tả việc đơn giản hóa những thứ phức tạp bằng cách chia nhỏ chúng thành những phần nhỏ hơn (chia nhỏ vấn đề thành từng lớp khác nhau, thực hiện một nhiệm vụ cụ thể):

	1. [Danh từ] Sau khi đã phân tích nhiều đối tượng, ta sẽ chắt lọc những thông tin chung và quan trọng nhất, bỏ qua những chi tiết không cần thiết, tạo nên một phiên bản tổng quát (gọi là lớp).
	
	2. [Tính từ] Là điểm kết nối trung gian (giao diện), che giấu đi những chi tiết phức tạp, giúp đôi bên có thể tương tác với nhau mà không cần phải hiểu cấu trúc bên trong.

	-> Chắt lọc thông tin và ẩn đi những chi tiết phức tạp về cách thực hiện.

	Ví dụ 1: Chỉ riêng một SinhViên ở ngoài đời...

		- Có thông tin cá nhân rất phức tạp, bao gồm: tên, tuổi (năm sinh), địa chỉ thường trú, địa chỉ tạm trú, lịch trình di chuyển, gia đình, sở thích, chuyên ngành học, ngành theo học, học lực, các mối quan hệ xã hội...
		
		- Trường đại học lại không cần hết sử dụng tất cả các thông tin chỉ để quản lý một SinhViên.
		
		- Vì vậy, nhà trường chỉ cần rút trích ra những thông tin cần thiết nhất đối với nhà trường, để vẫn đảm bảo đại diện (represent) được cho một SinhViên của mình.
		
		-> [Danh từ] SinhViên (MSSV, email, tên, năm sinh, địa chỉ thường trú, số điện thoại, chuyên ngành học, điểm các môn học);
			(Mô tả ngắn gọn, những vẫn đầy đủ thông tin cần thiết của một SinhViên.)

	Ví dụ 2: Một bài nhạc với phiên bản Extended Mix được rút gọn lại thành phiên bản Original Mix hoặc Radio Edit.
		-> [Danh từ] Ngắn gọn hơn, nhưng vẫn giữ nguyên và truyền tải được tinh thần của bản gốc.

	Ví dụ 3: Ký âm (Music notation / Musical notation) là hệ thống sử dụng các biểu tượng (nốt nhạc) mà một nhạc sĩ có thể đọc và hiểu được, để thể hiện trực quan cho âm nhạc được chơi bằng nhạc cụ hoặc giọng hát.
		-> [Danh từ] Đơn giản hoá các âm thanh trừu tượng do các nhạc cụ hoặc giọng hát tạo ra bằng các nốt nhạc trên bản nhạc thay vì mô phỏng mọi chi tiết của âm thanh thực tế (tần số, thời gian phát thanh...).
			(Người đọc ký âm có thể hiểu và trình diễn một bản nhạc cụ thể mà không cần biết chi tiết về cách chơi hoặc kỹ thuật của từng nhạc cụ.)

	Ví dụ 4: Khi đăng nhập vào một trang web hoặc mạng xã hội...
		- Người dùng chỉ việc nhập tài khoản và mật khẩu, sau đó tương tác (xem, bình luận, chia sẻ...).
		- Những chi tiết phức tạp về việc xử lý dữ liệu đã được che giấu đi.

==========================================================================================

[2. TÍNH ĐÓNG GÓI / CÔ LẬP - ENCAPSULATION]

Diễn tả việc che giấu đi những chi tiết bên trong của một đối tượng với thế giới bên ngoài.
	- Sau khi những thứ có liên quan đến nhau được tập hợp lại thành một đơn vị duy nhất, cần kiểm soát quyền truy cập để tránh những thay đổi không mong muốn lên dữ liệu.
	- Những thông tin cá nhân sẽ được giấu đi, chỉ hiển thị ra bên ngoài những thông tin thật sự cần thiết và có thể / được phép công khai.

	-> Giúp bảo vệ dữ liệu khỏi sự can thiệp trực tiếp từ bên ngoài.

	Ví dụ 1: Phần vỏ của viên thuốc con nhộng (viên nang - capsule).

		- Vỏ ngoài được làm từ chất gelatin – một loại protein được tách từ collagen của mô liên kết, xương, da của động vật (heo, bò...) hoặc gelatin từ thực vật, loại chất này sẽ hòa tan trong dạ dày.

		- Phần vỏ sẽ giúp bảo vệ các thành phần trong công thức thuốc không bị hỏng khi tiếp xúc với các yếu tố của môi trường xung quanh như khí oxy, độ ẩm, ánh sáng, vi khuẩn, nấm mốc.

		- Mặt khác, vỏ nang thuốc còn để che giấu mùi vị khó chịu của thuốc.

		- Và quan trọng nhất là bảo vệ niêm mạc dạ dày khỏi một số loại hoạt chất của thuốc gây kích ứng niêm mạc dạ dày cũng như giúp thuốc tan tại ruột để tránh acid của dịch vị phá hủy thuốc, thường được áp dụng đối với một số kháng sinh.

		-> Thuốc được chứa bên trong, phần vỏ giúp che giấu và bảo vệ cho thuốc.

	Ví dụ 2: Truyền hình (Tivi) và chiếc điều khiển từ xa.

		- Tivi được che đậy bằng một lớp vỏ nhựa màu đen, bạc...

		- Toàn bộ xử lý hậu trường của tivi đều được ẩn giấu đi, ta không hề biết tivi xử lý dữ liệu - quét dữ liệu từ sóng vô tuyến / wifi như thế nào.

		- Ta chỉ có thể tương tác thông qua các nút bấm có sẵn trên tivi hoặc thông qua điều khiển từ xa (các phương thức xử lý public).

		-> Các xử lý được che giấu bên trong tivi và điều khiển từ xa.

	Ví dụ 3: Đồ chơi lắp ráp.

		- Đã được thiết kế sẵn các khối (gạch nhựa) với một loạt các bánh răng ăn khớp hình tròn, những thông tin không cần thiết như: chất liệu, thời gian sản xuất, nơi / quốc gia sản xuất... đều được ẩn giấu.
		
		- Người chơi chỉ việc mua về, sau đó có thể lắp ráp và kết nối theo nhiều cách khác nhau để tạo ra các mô hình độc đáo bằng khả năng sáng tạo và trí tưởng tượng của riêng mình.

		-> Che giấu tất cả thông tin không cần thiết, chỉ chừa ra các khớp nối.

==========================================================================================

[3. TÍNH KẾ THỪA / TÁI SỬ DỤNG - INHERITANCE]

Diễn tả quá trình tạo nên một thứ mới dựa trên một thứ có sẵn.
	- Tận dụng những "giải pháp" sẵn có và tinh chỉnh (nếu cần), tránh tốn thời gian xây dựng lại mọi thứ từ đầu.
	- Cho phép tạo nên một thứ tương đương nhưng mạnh mẽ và khắc phục những nhược điểm của những thứ trước đó.
	- Giúp phân loại và gom nhóm những đối tượng có chung đặc điểm, cho phép điều chỉnh hàng hoạt trên nhóm đối tượng này.

	Ví dụ 1: Con cái sẽ được kế thừa những đặc điểm về tính cách, hành vi (màu da, chiều cao, kết cấu tóc, cách ăn nói, dang đi...) và tài sản của cha mẹ.
		-> Kế thừa những đặc điểm và hành vi từ một khuôn gốc.

	Ví dụ 2: Ngữ hệ / Họ ngôn ngữ (Language family) là một tập hợp các ngôn ngữ được gộp lại dựa trên quan hệ "di truyền". Mỗi ngôn ngữ sẽ có những đặc điểm (từ vựng, ngữ pháp, cú pháp...) độc đáo riêng, nhưng được kế thừa từ một ngôn ngữ chung duy nhất, gọi là ngôn ngữ nguyên thủy (proto-language) hay ngôn ngữ tổ tiên.
		-> Kế thừa những đặc điểm từ một khuôn gốc.

	Ví dụ 3: Trong một công ty, Bộ phận Kế toán có thể có các bộ phận con như Bộ phận Tài chính và Bộ phận Thuế, mỗi bộ phận con chỉ tập trung vào một khía cạnh cụ thể của công việc kế toán.

==========================================================================================

[4. TÍNH ĐA HÌNH / ĐA XẠ - POLYMORPHISM]

Diễn tả việc biến hoá linh hoạt tuỳ theo ngữ cảnh trong hành vi của một đối tượng.
	- Tăng khả năng thích ứng khi sẽ luôn có những thay đổi cho phù hợp với điều kiện mới, yêu cầu mới.
	- Cho phép dù rơi vào tình huống như thế nào thì đều có cách tương ứng để giải quyết.

	Ví dụ 1: Lời kêu gọi Toàn quốc kháng chiến...

		- Sau khi những nỗ lực đàm phán hòa bình giữa Việt Nam Dân chủ Cộng hòa với Pháp vào giữa năm 1946 để công nhận một nước Việt Nam độc lập không thành công.

		- Đứng trước sự tồn vong của dân tộc, tối 19/12/1946, Chủ tịch Hồ Chí Minh đã ra Lời kêu gọi Toàn quốc kháng chiến:

			“Bất kỳ đàn ông, đàn bà, bất kỳ người già, người trẻ, không chia tôn giáo, đảng phái, dân tộc. Hễ là người Việt Nam thì phải đứng lên đánh thực dân Pháp, cứu Tổ quốc. Ai có súng dùng súng. Ai có gươm dùng gươm, không có gươm thì dùng cuốc, thuổng, gậy gộc. Ai cũng phải ra sức chống thực dân Pháp cứu nước.”

		-> [Override] Bác chỉ nói "đứng lên đánh", nhưng lại có đa dạng cách thức tiêu diệt giặc của nhân dân.
			(Hàm tiêuDiệtGiặc() có nhiều cách triển khai khác nhau tuỳ theo đối tượng.)

	Ví dụ 2: Khi được yêu cầu chơi nhạc, mỗi nhạc công sẽ sử dụng những nhạc cụ khác nhau như piano, ghi-ta, kèn, trống... để trình diễn bài hát.
		-> [Override] Chỉ nghe lệnh "chơi nhạc", tuỳ vào vị trí trong ban nhạc mà sẽ chơi những nhạc cụ khác nhau.

	Ví dụ 3: Trong một dựn án Agile / Scrum, khi họp nhóm hằng ngày (Daily Scrum Meeting), mỗi thành viên sẽ phải tự trả lời ba câu hỏi:
		1. Hôm qua đã làm được gì?
		2. Hôm nay dự định sẽ làm gì?
		3. Có đang gặp vướng mắc hay khó khăn gì không?
		
		-> [Override] Chỉ yêu cầu "báo cáo", mỗi thành viên sẽ tự có nội dung riêng để báo cáo.

	Ví dụ 4: Một người có thể đồng thời là đồng nghiệp, phụ huynh và bạn bè. Chỉ là một người (và một tên gọi duy nhất), nhưng tuỳ theo ngữ cảnh/tình huống mà chức vụ và hành vi của người này có thể thay đổi.
		-> [Overload] Tuỳ vào thời điểm mà sẽ có những vai trò và hành vi khác nhau.

	Ví dụ 5: "Nếu cuộc đời cho bạn quả chanh, hãy vắt ngay một ly nước chanh thật đỉnh" - Cùng là một hành động "Chế biến trứng", nhưng tuỳ thuộc vào loại dụng cụ gia dụng và nguyên liệu khác được cung cấp mà sẽ cho những thành phẩm khác nhau.
		- Sử dụng chảo và dầu ăn sẽ cho ra trứng chiên.
		- Sử dụng nồi và nước sôi sẽ cho ra trứng luộc.
		-> [Overload] Tuỳ vào loại đồ gia dụng và nguyên liệu đầu vào mà sẽ có những món ăn khác nhau.

==========================================================================================

Tổng hợp Series bài dịch Thiết kế mẫu "Design Patterns for Dummies":
	- http://diendan.congdongcviet.com/threads/t76502::tong-hop-series-bai-dich-thiet-ke-mau-design-patterns-for-dummies.cpp

	- https://haihth.wordpress.com/category/design-patterns-for-dummies/

	- https://ongchonghaylam.com/series-bai-dich-design-patterns-for-dummies/

==========================================================================================
==========================================================================================
==========================================================================================

[KỸ THUẬT THIẾT KẾ / CÁCH THỨC THIẾT KẾ HƯỚNG ĐỐI TƯỢNG - SOLID]

Theo thời gian, các nhà phát triển phần mềm đã đúc kết ra được những nguyên tắc để thiết kế phần mềm.

Kế thừa từ bốn nguyên tắc thiết kế hướng đối tượng.
	- Cung cấp những hướng dẫn chuyên sâu hơn để tạo ra những phần mềm có cấu trúc tốt.
	- Giúp cho mã nguồn trở nên linh hoạt hơn theo thời gian, dễ bảo trì, sửa đổi, mở rộng, tái sử dụng và có thể kiểm thử được.
	-> Thiết kế code thế nào để đảm bảo đủ bốn nguyên tắc.

Trong đó, tính trừu tượng liên quan đến cả năm nguyên lý SOLID.
	- Tính chất này quy định việc tạo ra những Interface ở mức độ cao, được đơn giản hoá để ẩn giấu những chi tiết trong cách thiết kế với người dùng.
	- Giúp giảm độ phức tạp, tăng tính mô-đun hoá, làm cho hệ thống dễ hiểu, dễ bảo trì và dễ thích ứng với những thay đổi trong tương lai hơn.

==========================================================================================

[01. [S]INGLE RESPONSIBILITY PRICIPLE]

Liên quan đến tính đóng gói, quy định rằng mỗi lớp chỉ giải quyết một công việc duy nhất.

	- Mỗi phương thức chỉ nên đảm nhận một nhiệm vụ duy nhất.
		Ví dụ: Phương thức tính toán nên trả về một giá trị thay vì in luôn giá trị đó ra.

	- Mỗi biến cũng chỉ nên được sử dụng cho một mục tiêu duy nhất.
		Ví dụ: Trong mảng hai chiều, biến i luôn được sử dụng để đại diện cho dòng và biến j luôn được sử dụng để đại diện cho cột.

	- Giúp cho lớp dễ hiểu, ít mắc sai lầm, dễ bảo trì và chuyên sâu hơn về một nhiệm vụ nào đó.

==========================================================================================

[02. [O]PEN/CLOSED PRICIPLE]

Liên quan đến tính kế thừa, quy định rằng lớp nên "tăng thu, giảm chi" - tăng khả năng mở rộng (open for extension), nhưng giảm khả năng sửa đổi (closed for modification).
	- Những tính năng mới nên được thêm vào hệ thống bằng cách tạo ra các lớp Con nhờ vào kế thừa, thay vì sửa đổi trực tiếp trên lớp Cha.

==========================================================================================

[03. [L]ISKOV SUBSTITUTION PRICIPLE]

Liên quan đến tính kế thừa, quy định rằng lớp dẫn xuất (lớp Con) phải được sử dụng để thay thế cho lớp cơ sở (lớp Cha), việc thay thế lẫn nhau này sẽ không làm ảnh hướng đến kết quả tính toán.
	- Là phần mở rộng của nguyên lý Open/Closed.
	- Lớp Con có thể thay đổi các đối tượng kiểu lớp Cha mà không gây ra lỗi (sau khi kế thừa, phải kiểm tra xem có làm vi phạm tính đúng đắn về nghiệp vụ của lớp Cha hay không).
	- Khi thiết kế lớp Cha, những phương thức mà không phải lớp Con nào cũng cần triển khai sẽ được thiết kế là Interface.

	Ví dụ: Khi thiết kế phương thức tính lương cho nhân viên trong một doanh nghiệp.
		- Chỉ nhân viên chính thức (nhân viên toàn thời gian) mới được cấp mã nhân viên và được tính lương tháng.
		- Nhân viên thời vụ (nhân viên bán thời gian) sẽ không có mã nhân viên và nhận lượng theo giờ.
		-> Phương thức tính lương sẽ là Interface để nhân viên nào cần thì mới triển khai.

==========================================================================================

[04. [I]NTERFACE SEGREGATION PRICIPLE]

Liên quan đến tính đa hình, quy định rằng nếu người dùng chỉ cần một Interface nhỏ bên trong một Interface lớn, hãy chia Interface lớn này thành nhiều Interface nhỏ hơn và cung cấp cho người dùng đúng loại Interface mà họ cần, vì người dùng không cần phải quan tấm đến những thứ mà họ không sử dụng đến.
	- Gắn liền với nguyên lý Single-responsibility.
	- Nên tách những Interface lớn (với nhiều chức năng) thành nhiều Interface nhỏ hơn và liên kết với nhau thông qua quan hệ kế thừa. 
	- Điều này sẽ giúp hạn chế được việc coupling khi tích hợp hệ thống.

==========================================================================================

[05. [D]EPENDENCY INVERSION PRICIPLE & DEPENDENCY INJECTION]

Liên quan đến tính trừu tượng, quy định rằng những mô-đun cấp cao không nên phụ thuộc vào những mô-đun cấp thấp. Sự phụ thuộc giữa các lớp nên được đảo ngược, những mô-đun cấp cao sẽ định nghĩa ra những Interface hoặc lớp trừu tượng để những mô-đun cấp thấp triển khai / hiện thực hoá.
	- Khi có diễn ra sự phụ thuộc, nên phụ thuộc vào những cấp cao nhất, tốt nhất là phụ thuộc vào lớp trừu tượng và Interface.

--------------------------------------------------------------------------------

	[DEPENDENCY INJECTION]

	* Đảo ngược kiểm soát (Inversion of Control - IoC): Kỹ thường thường được sử dụng trong các Framework lớn.	
		- Nếu lớp A có phụ thuộc (Dependency) là lớp B, cần phải tạo trực tiếp lớp B bên trong lớp A, nhưng như vậy sẽ gặp vấn đề về liên kết lỏng lẻo (loose coupling).
		- Vì vậy, lớp B sẽ được trừu tượng hoá để lớp A có thể gọi đến như một Interface.
		- Nhưng để lớp A có thể thật sự sử dụng Interface B (lớp B), cần phải có thêm một lớp trung gian để hiện thực hoá bằng cách truyền đối tượng của lớp B vào trong lớp A.

Tính đóng gói (Encapsulation) là một trong bốn tính chất chủ yếu trong lập trình hướng đối tượng, sẽ giúp đóng gói mọi thông tin / dữ liệu vào trong một đơn vị.
	- Mỗi lớp chỉ nên làm tròn trách nhiệm của mình, không nên làm dư (thiết kế tất cả các lớp trong cùng một tập tin).

		Ví dụ: Nếu được sinh ra để lưu trữ dữ liệu...
			- Chỉ nên sử dụng để cung cấp dữ liệu, trả kết quả dựa theo bộ lọc.
			- Không nên sử dụng để xử lý, tính toán trên dữ liệu.

* High Cohesion: Mỗi lớp phải làm tròn phần việc của mình.
	Ví dụ: Vì có quá nhiều dữ liệu nên sẽ tạo ra riêng một lớp DAO chuyên đảm nhận việc xem-thêm-xoá-sửa dữ liệu trong một bảng (table) nào đó.

* Liên kết / Ràng buộc lỏng lẻo (Loose Coupling / Low Coupling): Làm giảm bớt sự phụ thuộc lẫn nhau giữa các thành phần trong hệ thống.
	- Khi phụ thuộc với nhau một cách chặt chẽ, nếu một bên có thay đổi (bảo trì, nâng cấp) thì bên còn lại cũng sẽ bị ảnh hưởng rất nhiều (hiệu ứng dây chuyền - Domino).
	- Vì vậy, đây là một kỹ thuật thiết kế các lớp để hỗ trợ cho việc mở rộng và tương tác giữa các lớp trở nên linh hoạt hơn, ít phụ thuộc vào nhau nhưng khi cần thì vẫn có mặt.
	- Để làm được điều này, thay vì phụ thuộc vào một thứ gì đó cụ thể, hãy phụ thuộc vào một thứ trừu tượng - Interface.

	Ví dụ: Những "ràng buộc lỏng lẻo" trong cuộc sống.
	
		- Trong gia đình, con cái luôn muốn có không gian riêng tư và sự độc lập, nhưng đồng thời vẫn sẽ luôn có sự hỗ trợ tài chính từ phía bố và mẹ trong trường hợp cần thiết.

		- Trong một mối quan hệ, mỗi bên đều bận công việc riêng và không thể luôn luôn ở bên nhau, nhưng vẫn sẽ cố gắng sắp xếp để gặp mặt nhau vào một thời điểm nào đó trong ngày.

	-> Dù có phụ thuộc và tương tác được với nhau, nhưng vẫn lỏng lẻo.
		(Vẫn cần "tín hiệu" từ bên ngoài truyền vào để xử lý, nhưng tín hiệu đó có thể là bất kì dạng / phong cách nào.)

* Dependency Injection: Là kỹ thuật để hiện thực hoá, cách thức để đạt được tính liên kết lỏng lẻo (Loose Coupling) giữa các thành phần trong hệ thống.
	- Thay vì phụ thuộc (Dependency) vào một thứ cụ thể (có xử lý bên trong), nay chỉ nêu lên ý tưởng, còn việc hiện thực hoá sẽ do những bên khác đế gặp và tính (Injection).
	- Là kỹ thuật thiết kế các lớp, để giữa các lớp ngoài việc đảm đảo mỗi lớp một chức năng khác nhau, thì còn có thể giao tiếp với nhau và mở rộng.

	- Là một cách cài đặt IoC.

	-> Đưa điều kiện từ bên vào ngoài để nhận về kết quả tương ứng.

------------------------------------------------------------

Giống như câu lệnh truy vấn SQL (SELECT * FROM ... WHERE ...) để lọc và hiện thị ra những dữ liệu mong muốn, đối với từng điều kiện / tiêu chí được liệt kê trong WHERE thì sẽ có những kết quả trả về tương ứng.

	- Mệnh đề WHERE giống như một sự ràng buộc cho tập dữ liệu, cho phép chọn lọc ra theo một điều kiện nào đó và chỉ trả về những kết quả tương ứng.
		-> Phụ thuộc (Dependency) / Bộ lọc (Filter) để đưa ra cho nơi khác.
			(Điều kiện (Condition) / Tiêu chí (Criteria).)

		Ví dụ: Lọc ra những sinh viên với mã chuyên ngành là SE trong bảng Student.

			SELECT *
			FROM Student
			WHERE majorId = 'SE'

			-> Đưa ràng buộc thông qua WHERE, nhận về kết quả tương ứng.

	- Mỗi bên sẽ có một công việc khác nhau, một bên chuyên cung cấp dữ liệu và một bên sẽ quy định những dữ liệu mà mình mong muốn thấy theo một định dạng nào đó.

		Ví dụ: Thư kí là người nắm được dữ liệu, giám đốc có công việc riêng của mình và cũng không cần xem hết toàn bộ dữ liệu đó, mà sẽ chỉ xem theo một bộ lọc nhất định, chẳng hạn như thống kê xu hướng mua hàng...

	- Trong lập trình, khi gọi hàm và chỉ cần đưa kèm điều kiện vào thì sẽ nhận về một kết quả tương ứng với bộ lọc.
		-> Đưa ra bộ lọc và nhận về kết quả tương ứng.
			(Người dùng tự quyết định kết quả trả về.)

	- 
		-> Đưa vào / Truyền vào (Inject) một loại điều kiện / tiêu chí nào đó.

	-> Mở ngỏ để những nơi khác thoải mái truyền vào (Inject) điều kiện (Dependency).
		(Một câu lệnh duy nhất giúp tương thích với nhiều thứ khác nhau.)

=> Lỏng lẻo (Loose) trong việc nhận bộ lọc từ tất cả mọi người, nhưng vẫn cần phải có (Coupling) để biết đường xử lý.

Giảm nhẹ sự phụ thuộc giữa các lớp mà vẫn giữ nguyên sự liên kết.

------------------------------------------------------------

	[MINH HOẠ VỀ NHỮNG TÌNH HUỐNG SỬ DỤNG CỦA DEPENDENCY INJECTION]

Trong thực tế, hãy tượng tượng nơi chứa dữ liệu (nơi quản lý và cung cấp dữ liệu) giống như một nhà hàng và thực khách giống như một bộ lọc - tình huống sử dụng cụ thể:

	* Thuyền thống:
		- Nhà hàng sẽ là nơi có sẵn nguyên liệu và đầu bếp để chế biến món ăn.
			+ Các món có trong thực đơn, hương vị và khẩu phần sẽ do bếp trưởng lên ý tưởng.
			+ Sau khi các món ăn đã được chế biến xong thì bộ phận tiếp thị sẽ có nhiệm vụ chụp hình và in ấn để tạo thành những quyển thực đơn.
		- Thực khách khi đến nhà hàng chỉ có thể chọn những món có sẵn trong thực đơn.

		-> Nhà hàng đoán những gì thực khách cần và thực khách sẽ chọn những gì sẵn có.

	* Hiện đại:
		- Nhà hàng vẫn có sẵn nguyên liệu và đầu bếp, nhưng món ăn và câu thức nấu sẽ do thực khách tự mang đến và cung cấp cho nhà hàng.
		- Thực khách khi đến nhà hàng sẽ không còn bị gò bó trong những thực đơn có sẵn nữa.
			+ Họ sẽ tự lên thực đơn và câu thức nấu ăn, liệt kê sẵn những món ăn được và không ăn được (bị dị ứng), tỷ lệ nêm nếm gia vị (muối, đường, bột ngọt...).
			+ Sau đó yêu cầu nhà bếp chế biến món sao cho phù hợp nhất với sở thích ăn uống của mình.

		-> Thực khách tự nói lên nhu cầu của họ và nhà hàng sẽ làm theo đúng yêu cầu.

----------------------------------------

Trong lập trình, thay vì phải liên tục phụ thuộc vào mệnh đề if để suy nghĩ và liệt kê (vô số) các trường hợp xử lý.
	- Việc liệt kê một thứ mà ta biết rõ có vô số trường hợp sẽ rất dễ thiếu hoặc trùng lặp.
	- Vì vậy, thay vì phụ thuộc vào những trường hợp cụ thể có thể liệt kê ra, nay chỉ cần phụ thuộc vào một thứ được đưa từ bên ngoài vào (do bên ngoài tự suy nghĩ, liệt kê trường hợp cần sử dụng và đưa vào).
		+ Thống nhất với người sử dụng tên hàm, 

Ví dụ: Dependency Injection trong lập trình.

	// Khởi tạo danh sách sinh viên bằng khối lệnh khởi tạo
	private List<Student> stuList = new ArrayList();
	{
		stuList.add(new Student("SE999999", "CHÍN NGUYỄN", 1999, 9.9, "SE"));
		stuList.add(new Student("SE888888", "TÁM LÊ", 1998, 8.8, "SE"));
		stuList.add(new Student("SE444444", "BỐN PHẠM", 2004, 4.4, "SE"));
		stuList.add(new Student("IA555555", "NĂM LÝ", 2005, 5.5, "IA"));
		stuList.add(new Student("IA333333", "BA MAI", 2003, 3.3, "IA"));
		stuList.add(new Student("GD777777", "BẢY VÕ", 1997, 7.7, "GD"));
		stuList.add(new Student("GD666666", "SÁU TRẦN", 2006, 6.6, "GD"));
		stuList.add(new Student("SS222222", "HAI VŨ", 2002, 2.2, "IB"));
	}


	// 1. TỰ NHIÊN: Thiết kế hàm tương ứng theo từng câu truy vấn,
	//		lọc ra dữ liệu và trả về kết quả tương ứng với từng hàm
	//
	//	- Ưu điểm: Dễ viết, cần truy vấn như thế nào
	//		   thì chỉ cần thiết kế một hàm tương ứng
	//	- Nhược điểm: Phải thiết kế rất nhiều hàm,
	//		      phải dự đoán trước những tình huống sử dụng
	//		      và liên tục thay đổi code nếu có tình huống mới

	// 	1.1. Hiện thị toàn bộ danh sách sinh viên
	//	SQL: SELECT * FROM Student
	public List<Student> getAll() {
		return stuList;
	}

	//	1.2. Trả về danh sách sinh viên ngành SE
	//	SQL: SELECT * FROM Student WHERE Major = 'SE'
	public List<Student> getSEStudents() {
		
		// Danh sách trung gian
		// để nhận kết quả trả về từ danh sách tổng
		// (Vì dữ liệu trả về phải ở dạng đối tượng
		//  để sau đó có thể sử dụng tiếp ở những nơi khác,
		//  nên không thể in ra bằng câu lệnh println())
		List<Student> result = new ArrayList();
		
		// Duyệt toàn bộ danh sách (tổng) sinh viên
		for (int i = 0; i < stuList.size(); i++) {

			// Lấy ra sinh viên thoả điều kiện
			// để sau đó đưa trở lại vào danh sách trung gian
			if (stuList.get(i).getMajor().equalsIgnoreCase("SE"))

				// Nếu có kết quả khớp với điều kiện
				// thì đưa đối tượng đó vào danh sách trung gian
				result.add(stuList.get(i));
		}
		
		// Trả về (các) đối tượng trong danh sách trung gian
		return result;
	}

	//	1.3. Trả về danh sách sinh viên ngành SE
	//	     với điểm trung bình >= 5
	//	SQL: SELECT * FROM Student
	//	     WHERE Major = 'SE' AND GPA >= 5
	public List<Student> getSEStudentsGt5() {
		
		// Danh sách trung gian
		// để nhận kết quả trả về từ danh sách tổng
		List<Student> result = new ArrayList();
		
		// Duyệt danh sách sinh viên
		for (int i = 0; i < stuList.size(); i++) {
		
			// Sử dụng thêm một biến trung gian
			// để thay thế cho từng sinh viên trong danh sách,
			// giúp giảm bớt độ dài cho câu lệnh khi có nhiều điều kiện
			Student x = stuList.get(i);            
			
			if (x.getMajor().equalsIgnoreCase("SE") && x.getGpa() >= 5)
				result.add(x);
			}
		
		return result;
	}


	// 2. TỐI ƯU #1 - Chỉ cần 1 hàm duy nhất kèm với danh sách quy ước
	//		  (danh sách do người thiết kế dự đoán và viết ra),
	//		  người dùng chỉ cần truyền vào hàm
	//		  số thứ tự được quy định sẵn trong danh sách quy ước,
	//		  hàm sẽ có những xử lý tương ứng với tham số nhận được
	//
	//	* Quy ước:
	//		1. Lấy tất cả sinh viên
	//		2. Chỉ lấy sinh viên ngành SE
	//		3. Chỉ lấy sinh viên ngành IA
	//		...
	//
	//	- Ưu điểm: Gọn gàng hơn và giảm thiểu được số lượng hàm phải thiết kế
	//		   bằng cách gộp nhiều bộ lọc vào trong một hàm duy nhất
	//	- Nhược điểm: Không giảm được số lượng câu lệnh cần phải xử lý,
	//		      tốt cả đều dồn vào một hàm sẽ hàm trở nên phức tạp hơn,
	//		      vẫn phải dự đoán trước những tình huống sử dụng
	//		      và cũng phải liên tục thay đổi code nếu có tình huống mới
	//
	//	Sử dụng một biến để làm biến cờ, cho hàm biết cần phải làm gì
	//	(Đưa LỰA CHỌN từ bên ngoài vào và trả về kết quả xử lý tương ứng)
	//		-> Dependency Injection (Phiên bản cơ bản)
	public List<Student> getStudent(int filterType) {
		
		// Danh sách sinh viên được trả về
		// sẽ khác nhau tuỳ theo việc rơi vào trường hợp nào
		List<Student> result = new ArrayList();
		
		// Nhận vào loại bộ lọc do người dùng chọn và sử dụng switch-case{}
		// tương ứng với các tình huống được liệt kê trong quy ước
		switch (filterType) {
		
			// 2.1. Lấy tất cả sinh viên
			case 1:
				result = stuList;
				break;
				
			// 2.2. Chỉ lấy sinh viên ngành SE
			case 2:
				for (Student x : stuList) {
					if (x.getMajor().equalsIgnoreCase("SE"))
						result.add(x);
				}
				break;
				
			// 2.3. Chỉ lấy sinh viên ngành IA
			case 3:
				for (Student x : stuList) {
					if (x.getMajor().equalsIgnoreCase("IA"))
						result.add(x);
				}
				break;
			
			default:
				System.out.println("Please choose the filter type from 1..3");
		}
		
		return result;
	}


	// 3. TỐI ƯU #2 - Cũng là 1 hàm duy nhất, nhưng hàm này đặc biệt ở điểm
	//		  có thể linh hoạt nhận vào bất kì kiểu dữ liệu nào ở tham số
	//		  (thay vì chỉ nhận một kiểu dữ liệu giống như trong thiết kế).
	//		  Lúc này, người dùng sẽ phải chủ động cung cấp bộ lọc
	//		  và cũng tự thiết kế xử lý sao cho phù hợp với mong muốn của mình.
	//
	//		  Mọi thứ (từ nhu cầu, đến cách giải quyết)
	//		  đều đã được người dùng thiết kế sẵn,
	//		  nơi nắm giữ dữ liệu sẽ chỉ việc căn theo bộ lọc mà cung cấp dữ liệu
	//		  (Công việc và trách nhiệm thiết kế bộ lọc, xử lý cho hàm
	//		   được chuyển từ người xử lý dữ liệu ---> người dùng)
	//
	//	- Ưu điểm: Không cần dự đoán trước những tình huống sử dụng,
	//		   hạn chế được những "cuộc rượt đuổi" và bổ sung xử lý
	//		   khi người dùng phát sinh thêm nhu cầu
	//	- Nhược điểm: 
	//
	//	* Tóm tắt lý thuyết cách thức thực hiện:
	//	Người dùng sẽ tự chuẩn bị bộ lọc (là code xử lý) của riêng mình
	//	và nơi chứa dữ liệu sẽ chuẩn bị hàm để đón bộ lọc dưới dạng Interface.
	//	Vì Interface của nơi chứa dữ liệu là một đoạn code chưa hoàn chỉnh,
	//	nên khi sử dụng, phần xử lý cho bộ lọc ở phía người dùng
	//	sẽ được xem là cách hiện thực hoá Interface này.
	//	Sau khi truyền phần xử lý vào hàm, tuỳ vào phần xử lý của người dùng là gì
	//	mà hàm chứa dữ liệu sẽ việc kiểm tra và trả kết quả tương ứng
	//	(Đưa ĐỐI TƯỢNG từ bên ngoài vào và trả về kết quả xử lý tương ứng)
	//		- Nơi quản lý dữ liệu: Có dữ liệu, nhưng không biết cách xử lý
	//		- Người dùng: Biết cách xử lý, nhưng không có dữ liệu
	//		-> Dependency Injection (Phiên bản cao cấp)
	//
	//
	//	* Chi tiết cách thức thực hiện:
	//
	//	Ý tưởng ban đầu về việc đưa hàm xử lý vào bên trong hàm quản lý dữ liệu:
	//
	//		1. Người dùng sẽ tự thiết kế sẵn một bộ lọc với những tiêu chí riêng,
	//	sau đó nhận từng đối tượng một (chứa nhiều thông tin) từ nơi quản lý dữ liệu,
	//	kiểm tra dữ liệu mà mình vừa nhận được, so sánh với yêu cầu dữ liệu của mình
	//	và cuối cùng là trả về kết quả rằng dữ liệu vừa truyền từ bên ngoài vào
	//	có thật sự là dữ liệu mà bản thân đang cần hay không (True/False)
	//
	//		2. Nơi quản lý dữ liệu sẽ chỉ cần thiết kế phần tham số của hàm
	//	sao cho nhận vào mọi loại đối tượng thay vì chỉ một kiểu dữ liệu duy nhất,
	//	sau đó sẽ sử dụng một vòng lặp để duyệt toàn bộ dữ liệu mà mình đang nắm giữ,
	//	trong quá trình duyệt, nơi quản lý dữ liệu sẽ liên tục gọi hàm và đưa dữ liệu
	//	sang cho hàm xử lý dữ liệu của phía người dùng để hàm bên này kiểm tra,
	//	cuối cùng sẽ đưa toàn bộ phần tử thoả điều kiện của bộ lọc phía người dùng
	//	vào trong một mảng trung gian và trả về danh sách trung gian này
	//
	//		* Người dùng - Người cần dữ liệu - Người nhận dữ liệu để xử lý:
	//	Là nơi biết rõ nhất bản thân cần gì nên sẽ có nhiệm vụ thiết kế sẵn yêu cầu
	//
	//	Nhưng phần xử lý sẽ nằm và bắt buộc phải nằm trong một hàm nào đó
	//	chứ không thể truyền trực tiếp code xử lý vào trong tham số của hàm khác được
	//	vì hàm (nói chung) chỉ có khả năng nhận vào giá trị (đơn giản hoặc phức tạp)
	//
	//	Hơn nữa, vấn đề là hàm không thể nào nằm lơ lửng vì hàm là hành động,
	//	mà hành động thì phải thuộc về một đối tượng cụ thể nào đó
	//	và mọi thứ trong lập trình hướng đối tượng đều phải là đối tượng
	//
	//	Vì vậy, trong trường hợp này, hàm xử lý sẽ được nằm bên trong một đối tượng
	//	mà cụ thể hơn là được đóng gói và cho vào trong một lớp,
	//	cách để làm được điều đó là thiết kế hàm trừu tượng trong lớp trừu tượng,
	//	cụ thể là Interface, để khi nào thực sự cần sử dụng thì mới bắt đầu thiết kế
	//		-> Uỷ quyền cho một lớp trung gian
	//
	//	Ngoài công dụng giúp không cần phải tính toán trước các trường hợp
	//	mà khi nào thực sự cần thì chỉ việc lấy Interface ra để hiện thực hoá,
	//	việc sử dụng Interface để chứa hàm xử lý còn giúp thống nhất
	//	kiểu dữ liệu trả về của hàm giữa nơi chứa dữ liệu và nơi xử lý dữ liệu,
	//	đảm bảo rằng hàm luôn linh hoạt chứ không bao giờ phụ thuộc vào một thứ cụ thể
	//	(chỉ một hàm xử lý duy nhất, nhưng giải quyết được cho mọi trường hợp bộ lọc):
	//		- Nơi xử lý dữ liệu: Nơi chứa dữ liệu không cần biết
	//				     bên trong hàm xử lý như thế nào
	//				     và khi nào mới bắt đầu thiết kế xử lý,
	//				     mà chỉ cần biết hàm sẽ trả về kết quả
	//				     thuộc kiểu dữ liệu gì
	//		- Nơi chứa dữ liệu: Căn theo kiểu dữ liệu do hàm xử lý trả về
	//				    mà có những xử lý tương ứng
	//				    để trả về đúng dữ liệu mà người dùng cần
	//
	//	Có những cách khác nhau để thiết kế phần xử lý cho Interface
	//	(mỗi lần thiết kế xử lý là một lần có nhu cầu truy vấn):
	//		1. Trực tiếp thiết kế một lớp rời để hiện thực hoá Interface
	//		2. Hiện thực hoá Interface thông qua lớp nặc danh
	//		   (hoặc thậm chí là có sử dụng thêm biểu thức lambda)
	//
	//	Phần xử lý sẽ nhận vào một đối tượng do nơi quản lý dữ liệu gửi sang
	//	(vì chỉ có đối tượng mới có thể chứa cùng một lúc nhiều thông tin bên trong),
	//	sau đó kiểm tra xem đối tượng vào nhận vào có thoả với điện kiện lọc hay không
	//	và trả về kết quả giống như những gì đã cam kết ở hàm trừu tượng của Interface
	//
	//	Sau khi đã chuẩn bị xong phần xử lý ở phía người dùng,
	//	tiếp theo sẽ đến bước đưa đối tượng (có chứa hàm xử lý)
	//	được tạo ra từ Interface vào phần tham số của hàm chứa dữ liệu
	//
	//	-> Chuyên cung cấp các tiêu chí để lọc dữ liệu
	//	   bằng cách thiết kế sẵn hàm nằm trong một lớp riêng lẻ,
	//	   sau đó sẽ tạo đối tượng từ lớp này,
	//	   truyền tên đối tượng vào phần tham số của hàm quản lý dữ liệu
	//	   để hàm biết tiêu chí lọc là gì và trả về kết quả lọc tương ứng
	//		=> Nơi có tiêu chí lọc để phân phối cho những nơi khác
	//
	//
	//		* Người quản lý - Người có dữ liệu - Người chuyên cung cấp dữ liệu:
	//	Dựa vào kiểu dữ liệu trả về đã thống nhất từ trước với hàm xử lý dữ liệu,
	//	nơi quản lý dữ liệu sẽ chỉ cần thiết kế ra một hàm tổng quát (chung chung) nhất
	//	bằng kỹ thuật tham số hoá kiểu dữ liệu (Generics) -
	//	kỹ thuật này sẽ giúp ta chỉ tốn công thiết kế hàm trả dữ liệu một lần duy nhất
	//	mà vẫn luôn đúng cho mọi trường hợp dữ liệu đầu vào (được truyền vào tham số)
	//
	//	Phần tham số của hàm quản lý dữ liệu sẽ nhận vào một đối tượng
	//	mà đối tượng đó có thể là đối tượng được tạo ra từ bất kì lớp nào
	//	(đối tượng thuộc lớp là phần hiện thực hoá của Interface cung cấp xử lý),
	//	bên trong hàm quản lý sẽ dùng tên đối tượng được truyền vào để gọi hàm xử lý,
	//	vì đã biết trước được kiểu dữ liệu trả về (do đã thống nhất từ trước với nhau)
	//
	//	Khi này, nơi quản lý dữ liệu sẽ không cần phải
	//	tính toán và liệt kê sẵn các trường hợp có thể xảy ra của bộ lọc,
	//	mà người dùng sẽ tự chủ động truyền hàm xử lý của bộ lọc (dưới dạng đối tượng)
	//	vào phần tham số của hàm quản lý dữ liệu mỗi khi có nhu cầu lọc dữ liệu
	//
	//	Hàm quản lý dữ liệu sẽ duyệt từ đầu đến cuối và lần lượt lấy toàn bộ phần tử
	//	mà mình đang có để đưa sang cho hàm xử lý dữ liệu phía người dùng,
	//	hàm xử lý cũng sẽ lần lượt nhận về từng phần tử một,
	//	sau đó tự mình đi kiểm tra và so sánh với điều kiện bộ lọc của chính mình
	//
	//	Kế tiếp, hàm quản lý dữ liệu sẽ lưu những phần tử thoả điều kiện lọc
	//	vào trong một mảng trung gian và thực hiện công đoạn cuối cùng:
	//	Trả về ra danh sách những phần tử thoả điều kiện lọc
	//
	//	-> Thiết kế hàm kiểm tra và trả về dữ liệu dựa theo bộ lọc
	//	   bằng cách nhận vào một đối tượng được tạo ra từ một lớp bất kì,
	//	   sau khi nhận vào đối tượng có chứa hàm bộ lọc ở bên trong,
	//	   hàm quản lý dữ liệu sẽ sử dụng tên đối tượng vừa mới được truyền vào
	//	   để gọi đến hàm chứa điều kiện lọc và kiểm tra với dữ liệu hiện có,
	//	   sau đó trả về danh sách (những) kết quả tương ứng
	//		=> Nơi có dữ liệu, nhận tiêu chí lọc để trả về kết quả tương ứng
	//
	//	=> Đưa bộ lọc dưới dạng đối tượng vào phần tham số của hàm quản lý dữ liệu
	//		(Đưa (Injection) bộ lọc (Dependency) từ bên ngoài vào hàm)

	//	* Thiết kế Interface cho bộ lọc
	//	  (Thông báo rằng sẽ nhận vào một lớp bất kì)
	public interface Filter<T> {

		// Hàm nhận vào một đối tượng
		// được tạo ra từ một lớp bất kì
		public abstract boolean check(T x);
	}

	//		* Phần hiện thực hoá Interface (hoặc có thể thiết kế trong hàm main()
	//						bằng cách sử dụng lớp nặc danh)
	//		  (Khi Interface chỉ nói sẽ nhận vào một lớp bất kì
	//		   thì phần hiện thực hoá sẽ cho biết cụ thể
	//		   lớp nhận vào là một lớp SinhViên)
	public class FilterBySE implements Filter<Student>{

		// Cho biết cụ thể sẽ sử dụng đối tượng
		// được tạo ra từ lớp sinh viên
		// để gọi đến các thuộc tính và phương thức,
		// từ đó kiểm tra điều kiện để tự tạo nên một bộ lọc
		@Override
		public boolean check(Student x) {
			if (x.getMajor().equalsIgnoreCase("SE"))
				return true;
			
			return false;
		}
	
	}

	//	* Thiết kế lớp kiểm tra và cung cấp dữ liệu dựa theo bộ lọc
	public List<Student> getStudents(Filter<Student> condition) {
        
		// Chuẩn bị danh sách trung gian
		List<Student> result = new ArrayList();
		
		for (Student x : stuList) {
		
			// Mặc định, hàm bộ lọc sẽ trả về kết quả là True/False,
			// hàm quản lý dữ liệu sẽ không quan tâm đến xử lý như thế nào.

			// Vì biết trước hàm check() của bên xử lý dữ liệu (bộ lọc)
			// sẽ trả về kết quả là True/False,
			// nên hàm quản lý sẽ đưa từng phần tử trong cả danh sách dữ liệu
			// cho hàm xử lý kiểm tra và nhận về kết quả,
			// sau đó đưa những phần tử thoả mãn bộ lọc vào danh sách trung gian
			if (condition.check(x) == true)
				result.add(x);
		}
		
		return result;
	}

	// 	* Trong hàm main()

	//		* Nếu phần hiện thực hoá của Interface là một lớp rời
	public static void testGetStudentBySEUsingConcreteClass() {

		// Tạo một đối tượng mới từ lớp quản lý dữ liệu
		// để có thể sử dụng các hàm quản lý dữ liệu
		StudentManager sm = new StudentManager();

		// Tạo đối tượng mới từ lớp (đã hiện thực hoá) bộ lọc
		// để sử dụng đối tượng này làm tham số đầu vào
		// cho hàm cung cấp dữ liệu
		// (vì lớp đã hiện thực hoá tất cả các hàm của Interface
		//  nên khi tạo mới đối tượng sẽ không yêu cầu
		//  phải thiết kế thêm xử lý cho các hàm của Interface nữa)
		FilterBySE seFilter = new FilterBySE();
		// seFilter.check(x); // Trả về kết quả True hoặc False

		// Gọi hàm quản lý dữ liệu,
		// nhận tham số đầu vào là một đối tượng
		// được tạo ra từ lớp bộ lọc
		// (chuyên cung cấp các tiêu chí để lọc dữ liệu),
		// sau đó sẽ hiển thị ra toàn bộ phần tử thoả điều kiện lọc
		System.out.println("The list of SE Students");
		List<Student> list = sm.getStudents(seFilter);
		for (Student x : list) {
			x.showProfile();
		}

	}

	//		* Nếu phải hiện thực hoá Interface trực tiếp trong hàm main()
	public static void testGetStudentBySEUsingAnonymousClass() {
		StudentManager sm = new StudentManager();

		// Thiết kế xử lý trực tiếp tại nơi cần sử dụng
		// khi không có nhu cầu sử dụng lại lớp,
		// vì mục đích cuối cùng chỉ là cần một đối tượng để gọi hàm xử lý

		// 1. Chỉ sử dụng lớp nặc danh
		Filter<Student> seFilter = new Filter<Student>() {

			// Không cần sử dụng thêm một lớp mới
			// để hiện thực hoá Interface
			// mà thiết kế xử lý trực tiếp tại nơi gọi hàm
			@Override
			public boolean check(Student x) {
				if (x.getGpa() >= 5 && x.getMajor().equalsIgnoreCase("SE")) {
					return true;
				}

				return false;
			}
		};

		// 2. Kết hợp thêm biểu thực lambda

		//	2.1. Viết đầy đủ và tường mình
		Filter<Student> seFilter = (Student x) -> {
			if (x.getMajor().equalsIgnoreCase("SE") && x.getGpa() < 5) {
				return true;
			}
			return false;
		};

		//	2.2. Viết vắn tắt và ngầm định
		Filter<Student> seFilter = x ->
                	x.getMajor().equalsIgnoreCase("SE") && x.getGpa() < 5;

			// Vì hàm 


		System.out.println("The list of SE Students with GPA >= 5");
		List<Student> list = sm.getStudents(seFilter);
		for (Student x : list) {
			x.showProfile();
		}
	}

―――――――――――――――――――――――――――――――――――――――――――――――――
│	Cách đưa Interface vào trong một hàm	│
―――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

* Data Transfer Object (DTO): Mẫu thiết kế được sử dụng để đóng gói dữ liệu và cung cấp cho nơi khác.
	- Thường được sử dụng để làm đại diện cho những dạng dữ liệu phức tạp.
	- Dữ liệu sẽ được đóng gói và cung cấp ở một định dạng sao cho dễ dàng truyền tải giữa các lớp trong một ứng dụng hoặc giữa các thành phần thông qua Internet.
	- Thường sẽ không có các thành phần xử lý mà chỉ có những phương thức cho phép truy cập và thay đổi thuộc tính.

	-> Giúp trao đổi dữ liệu.

* Đối tượng quản lý dữ liệu (Data Access Object - DAO / Data Manager): Mẫu thiết kế được sử dụng để cung cấp những cách đơn giản khi tương tác với cơ sở dữ liệu.
	- Việc quản lý (tìm kiếm, xem, thêm, xoá, sửa) dữ liệu là nhiệm vụ của một bên trung gian, chứ bản thân dữ liệu không thể tự thực hiện được.
	- DAO là một lớp trừu tượng trung gian, làm đại diện cho dữ liệu, quản lý tập hợp dữ liệu để phục vụ cho việc lưu trữ và xử lý dữ liệu.
	- Chuyên cung cấp các Interface liên quan đến xem-thêm-sửa-xoá (CRUD) để những lớp khác hiện thực hoá.
	- Giúp che giấu sự phức tạp của việc lưu trữ, truy xuất dữ liệu và việc xử lý.
	- Một khi thành phần dữ liệu và thành phần xử lý được tách biệt, từ đó có thể thoải mái thay đổi cơ chế lưu trữ mà vẫn không làm ảnh hưởng đến việc xử lý, hoặc thay đổi cô chế xử lý mà không làm ảnh hưởng đến dữ liệu.

	-> Giúp tương tác với đối tượng dữ liệu.

	Ví dụ: Giống như bảng SinhVien trong cơ sở dữ liệu.
		- Chuyên được sử dụng để quản lý danh sách sinh viên.
		- Cho phép tương tác với từng sinh viên hoặc tất cả các sinh viên.
			+ Xem-Thêm-Sửa-Xoá (CRUD).
			+ Sắp xếp...

=> Giúp giảm sự phụ thuộc giữa các thành phần trong hệ thống.

--------------------------------------------------------------------------------

	[BIỂU THỨC LAMBDA - LAMBDA EXPRESSION]

	* Biểu thức (Expression): Là sự kết hợp giữa các ký hiệu (hằng số, biến số, hàm số, dấu ngoặc, dấu chấm, dấu thay đổi độ ưu tiên...) để tạo nên một công thức toán học.
		Ví dụ: "3 + 7" sẽ là biểu thức gồm có 3 và 7 kết hợp với nhau bằng phép toán cộng.

	* Phép tính lambda (Lambda calculus / λ-calculus): Là một dạng của khái niệm thủ tục không có tên mà không tạo ra hiệu ứng phụ, các hàm là thực thể lớp nhất được truyền vào như các tham số và trả lại kết quả.

* Biểu thức lambda (Lambda expression): Là kỹ thuật viết code thay thế cho lớp nặc danh (Anonymous class).
	- Là cách viết rút gọn và lược bỏ đi tên hàm (và từ khoá new(), thậm chí là cả từ khoá @Override), gọn đến mức chỉ còn lại phần tham số đầu vào và phần xử lý của hàm.
	- Thường thấy trong lập trình hàm (Functional Programming), giúp hiện thực hoá những Interface chỉ có duy nhất một hàm trừu tượng (Functional Interface).
	- Trong JavaScript, kỹ thuật này được gọi là Arrow Function khi một hàm sẽ nhận dữ liệu đầu vào là một hàm khác.
		+ Được thực hiện bằng cách truyền một hàm (kèm xử lý) vào trong danh sách tham số của hàm khác (thay vì truyền giá trị: đơn giản hoặc phức tạp).
		+ Ngoài ra, còn được sử dụng để xử lý song song hoặc tuần tự (Stream API), giúp tối ưu hoá trong việc sử dụng Collections.
	- Biểu thức lambda sẽ rút gọn đến mức không còn thấy được đối tượng và lớp, giúp cho các câu lệnh trở nên ngắn gọn hơn và tránh được những đoạn code bị lặp lại (Boilerplate).

	-> Đưa phần xử lý của hàm (không đưa tên hàm) vào phần tham số của một hàm khác.

----------------------------------------

Bất kì Interface nào chỉ có duy nhất một hàm trừu tượng (Functional Interface) đều sẽ hỗ trợ cho việc sử dụng biểu thức lambda.
	- Khi hiện thực hoá Functional Interface, thay vì phải tạo một lớp rời để vượt mặt hàm rồi sau đó tạo mới đối tượng từ lớp mới này để gọi hàm, ta sẽ tận dụng lớp nặc danh.
		+ Nhưng bỏ luôn từ khoá new() và tên hàm.
		+ Chỉ còn lại phần tham số và xử lý.
		+ Sử dụng dấu mũi tên "->" (nằm giữa, ngăn cách phần tham số và xử lý) để thông báo đâu là câu/cụm xử lý.
	- Vì chỉ có một hàm bên trong nên vốn dĩ cũng không còn cần đến tên hàm.

	-> Vẫn thiết kế xử lý cho Functional Interface, nhưng rút gọn tên hàm (và từ khoá new()).

Vì vậy, có thể xem biểu thức lambda như một hàm nặc danh (Anonymous Method) của lớp nặc danh (Anonymous Class).

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Là kỹ thuật hiện thực hoá Functional Interface		│
│	nhưng theo phong cách trần trụi				│
│	(sử dụng lớp nặc danh, lược bỏ tên hàm và từ khoá new())│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

Tuỳ thuộc vào cấu trúc của những lớp trừu tượng trong Interface mà sẽ có nhiều cách khách nhau để viết biểu thức lambda.

* Cú pháp chung: (danh-sách-tham-số) -> {
						<danh-sách-câu-lệnh-xử-lý>;
						return;
					}
		// Có thể khai báo danh sách tham số theo kiểu tường minh (kèm kiểu dữ liệu)
		// hoặc ngầm định (không bao gồm kiểu dữ liệu),
		// nếu lựa chọn phong cách ngầm định thì hàm cũng sẽ tự động hiểu
		// dựa theo những gì đã được khai báo trong Interface

		// Nếu phần thân hàm chỉ có duy nhất một câu lệnh thì có thể bỏ luôn return,
		// nhưng nếu hàm chứa nhiều câu lệnh thì return là bắt buộc phải có

	- Không có câu lệnh (hàm void()):
		() -> { ... }

	- Một câu lệnh:
		([TênLớp1] tênĐốiTượng1, [TênLớp2] tênĐốiTượng2..)
			-> <một-câu-lệnh / một-biểu thức>

	- Nhiều câu lệnh:
		([TênLớp1] tênĐốiTượng1, [TênLớp2] tênĐốiTượng2..)
			-> {
				<nhiều-câu-lệnh>;
				return;
			}

----------------------------------------

* Tham chiếu phương thức (Method Reference): Là cách viết ngắn gọn hơn cho biểu thức lambda, cho phép tham chiếu đến một phương thức hiện có mà không cần triển khai lại nó.
	- Bỏ qua luôn cả phần tham số của hàm vì bản thân tên hàm đã cho biết sẽ nhận vào và trả ra giá trị gì.
	- Thay dấu mũi tên "->" thành hai dấu hai chấm "::".

* Các dạng của tham chiếu phương thức:

	1. Tham chiếu đến phương thức static: Vì phương thức static có thể sử dụng trực tiếp thông qua tên lớp, nên có thể sử dụng tên lớp và theo sau mà phương thức static của lớp.

		Ví dụ:
			// Interface Function có phương thức apply()
			// giúp chuyển một đối tượng từ kiểu dữ liệu này
			// sang đối tượng kiểu dữ liệu khác
			//
			// Lớp String có phương thức valueOf()
			// giúp chuyển các kiểu dữ liệu đơn giản thành chuỗi

			// Gọi phương thức valueOf()
			// để chuyển đổi tham số đầu vào thành chuỗi,
			// sau đó gán vào đối tượng của Interface Function
			// (Interface đang nhận vào một số nguyên và trả về chuỗi)
			Function<Integer, String> intToString = String::valueOf;

			// Giá trị số nguyên nhận vào
			// sẽ được chuyển thành đối tượng chuỗi
			String result = intToString.apply(10);

	2. Tham chiếu đến phương thức đã tồn tại | kiểu instance (???): 

	3. Tham chiếu đến phương thức chưa tồn tại | kiểu constructor (???): 

(* Tham khảo thêm: https://gpcoder.com/3882-phuong-thuc-tham-chieu-trong-java-8-method-references/)

------------------------------------------------------------

Các bước để sử dụng biểu thức lambda:

	Bước 1: Tạo Functional Interface của riêng mình hoặc sử dụng một cái sẵn có (ví dụ: Comparator, Runnable...).
	Bước 2: Tạo một lớp nặc danh (Anonymous Class) từ lớp Cha trừu tượng.
	Bước 3: Loại bỏ luôn phần new() của lớp nặc danh, chỉ chừa lại phần tham số và xử lý của hàm.

	Ví dụ: Các kiểu thiết kế xử lý khác nhau cho hàm.

		// * Truyền thống - Thiết kế lớp trước, sau đó tạo mới đối tượng:

		//	Tạo lớp rời và hiện thực hoá Functional Interface
		public class XYZ implements FunctionalInterfaceXXX {
			@Override
			public kiểu-dữ-liệu tênHàmTrừuTượngDuyNhất(danh-sách-tham-số) {
				// Những xử lý để hiện thực hoá
			}
		}


		// * Nặc danh - Tạo mới đối tượng và đồng thời thiết kế xử lý:

		//	Tạo mới luôn đối tượng trực tiếp từ Functional Interface,
		//	sau đó thiết kế xử lý ngay trong khi new()
		FunctionalInterfaceXXX tênĐốiTượng = new FunctionalInterfaceXXX {
			@Override
			public kiểu-dữ-liệu tênHàmTrừuTượngDuyNhất(danh-sách-tham-số) {
				// Những xử lý để hiện thực hoá
			}
		};


		// * Trần trụi - Cũng giống nặc danh, nhưng không có new() và tên hàm:

		FunctionalInterfaceXXX tênĐốiTượng = (danh-sách-tham-số) -> {
				// Những xử lý để hiện thực hoá
			}
		;

	Ví dụ 2: Bắt ngoại lệ trong JUnit 5.

		// * Lớp nặc danh
		Executable wrongArgument = new Executable() {
			@Override
			public void execute() throws Throwable {
				MathUtil.getFactorial(-5);
			}
		};
		// ≈ Executable wrongArgument = new Executable();

		// * Biểu thức lambda
		Executable wrongArgument = () -> {
			MathUtil.getFactorial(-5);
			};
		
		//	Rút gọn vì chỉ có duy nhất một câu lệnh xử lý
		Executable wrongArgument = () -> MathUtil.getFactorial(-5);

------------------------------------------------------------

* Stream Programming: Có mặt trong tất cả các Collection Framework.
	- Các câu lệnh nối đuôi nhau, chảy dài giống như một dòng nước.
	- Giúp chương trình gọn gàng hơn và đặc biệt là cải thiện được hiệu năng khi cho phép tận dụng được sức mạnh của những kiến trúc mới.
	- Các câu điều kiện, vòng lặp... dần không còn xuất hiện nữa, thay vào đó là các biểu thức lambda (lambda expression).

	Ví dụ: Áp dụng stream programming trong ArrayList.

		// Tìm số lớn nhất và nhỏ nhất trong một mảng số nguyên
		int max = danhSach.stream().max((x1, x2) -> -(x1 - x2)).get();
		int min = danhSach.stream().max((x1, x2) -> -(x1 - x2)).get();

		// Chỉ hiện thị ra những số nguyên chẳn
		danhSach.stream().filter(x -> ((x % 2) == 0)).forEach(x -> System.out.printf("%d\t", x));

==========================================================================================
==========================================================================================
==========================================================================================

[KHUÔN MẪU THIẾT KẾ PHẦN MỀM - DESIGN PATTERN]

[SINGLETON]

Là cách thức viết code đã được chuẩn hoá.

Chỉ chơi với static.

Không được có hai đối tượng trong RAM.

==========================================================================================

* Tham khảo thêm: khoá học cơ bản về Java
	- https://yellowcodebooks.com/2016/09/28/java-bai-1-tong-quan-ve-java/

* Các câu hỏi về OOP:
	- https://kungfutech.edu.vn/phong-van-pro?categorySlug=oop

==========================================================================================

--------------------------------------------------------------------------------

------------------------------------------------------------

----------------------------------------

--------------------

----------
















